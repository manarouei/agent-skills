#!/usr/bin/env python3
"""
Scope Enforcement Gate

Enforces bounded autonomy by validating:
1. File operations are within the node-derived allowlist
2. Git operations only affect allowed paths
3. No out-of-scope modifications

CRITICAL: This script REQUIRES an allowlist.json file to be present.
The allowlist.json is generated by node-normalize skill and contains
paths derived from the specific node being implemented.

Run: python scripts/enforce_scope.py <correlation_id> [--check-git]
"""

import sys
import subprocess
import json
from pathlib import Path
from typing import Any

import yaml

# Add parent to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

# Note: ScopeAllowlist from contracts is used for runtime validation,
# but this script uses simple lists for flexibility


# Default forbidden paths (always enforced)
DEFAULT_FORBIDDEN_PATHS = [
    # Core system files - NEVER modifiable by skills
    "**/base.py",
    "**/base.ts",
    "**/Base*.ts",
    "**/__init__.py",
    "pyproject.toml",
    "setup.py",
    "setup.cfg",
    "package.json",
    "package-lock.json",
    
    # Configuration
    ".env",
    ".env.*",
    "config/*",
    
    # CI/CD
    ".github/**/*",
    ".gitlab-ci.yml",
    "Dockerfile",
    "docker-compose.yml",
    
    # Database
    "migrations/**/*",
    "alembic/**/*",
]


def load_allowlist(correlation_id: str, artifacts_dir: Path) -> tuple[list[str], list[str]] | None:
    """
    Load node-derived allowlist from allowlist.json.
    
    Returns: (allowed_paths, forbidden_paths) or None if not found
    """
    allowlist_path = artifacts_dir / correlation_id / "allowlist.json"
    
    if not allowlist_path.exists():
        return None
    
    try:
        with open(allowlist_path) as f:
            data = json.load(f)
        
        allowed = data.get("allowed_paths", [])
        forbidden = data.get("forbidden_paths", [])
        
        # Always add default forbidden paths
        forbidden = list(set(forbidden + DEFAULT_FORBIDDEN_PATHS))
        
        return allowed, forbidden
    except (json.JSONDecodeError, KeyError) as e:
        print(f"ERROR: Failed to parse allowlist.json: {e}")
        return None


def match_glob(path: str, pattern: str) -> bool:
    """Simple glob matching for allowlist patterns."""
    import fnmatch
    
    # Handle ** (recursive) - matches any path segment
    if "**" in pattern:
        # Split pattern on **
        parts = pattern.split("**/")
        if len(parts) == 2 and parts[0] == "":
            # Pattern like "**/Base*.py" - match the suffix against any path segment
            suffix_pattern = parts[1]
            # Check if basename matches the pattern after **
            basename = path.split("/")[-1]
            if fnmatch.fnmatch(basename, suffix_pattern):
                return True
            # Also check full path with single * for **
            simplified = pattern.replace("**", "*")
            if fnmatch.fnmatch(path, simplified):
                return True
            return False
        # Other ** patterns - simplify to single *
        pattern = pattern.replace("**", "*")
    
    return fnmatch.fnmatch(path, pattern)


def is_path_allowed(path: str, allowed_paths: list[str], forbidden_paths: list[str]) -> tuple[bool, str]:
    """
    Check if a path is within the allowed scope.
    
    Returns: (is_allowed, reason)
    """
    # Check forbidden first (higher priority)
    for pattern in forbidden_paths:
        if match_glob(path, pattern):
            return False, f"Path matches forbidden pattern: {pattern}"
    
    # Check allowlist
    for pattern in allowed_paths:
        if match_glob(path, pattern):
            return True, f"Path matches allowed pattern: {pattern}"
    
    return False, "Path not in allowlist"


def get_git_changed_files(repo_path: Path = None) -> list[str]:
    """Get list of files changed in git (staged + unstaged)."""
    cmd = ["git", "diff", "--name-only", "HEAD"]
    if repo_path:
        cmd = ["git", "-C", str(repo_path)] + cmd[1:]
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        staged = result.stdout.strip().split("\n") if result.stdout.strip() else []
    except subprocess.CalledProcessError:
        staged = []
    
    # Also get unstaged changes
    cmd_unstaged = ["git", "diff", "--name-only"]
    if repo_path:
        cmd_unstaged = ["git", "-C", str(repo_path)] + cmd_unstaged[1:]
    
    try:
        result = subprocess.run(cmd_unstaged, capture_output=True, text=True, check=True)
        unstaged = result.stdout.strip().split("\n") if result.stdout.strip() else []
    except subprocess.CalledProcessError:
        unstaged = []
    
    # Combine and dedupe
    return list(set(staged + unstaged) - {""})


def load_session_files(correlation_id: str, artifacts_dir: Path) -> list[str]:
    """Load files modified by a session from session manifest."""
    manifest_path = artifacts_dir / correlation_id / "session_manifest.yaml"
    
    if not manifest_path.exists():
        return []
    
    try:
        with open(manifest_path) as f:
            manifest = yaml.safe_load(f)
        return manifest.get("files_modified", [])
    except (yaml.YAMLError, KeyError):
        return []


def validate_scope(
    files: list[str],
    allowed_paths: list[str],
    forbidden_paths: list[str],
) -> tuple[bool, list[dict[str, Any]]]:
    """
    Validate all files are within scope.
    
    Returns: (all_valid, violations_list)
    """
    violations = []
    
    for file_path in files:
        allowed, reason = is_path_allowed(file_path, allowed_paths, forbidden_paths)
        if not allowed:
            violations.append({
                "file": file_path,
                "reason": reason,
                "action": "BLOCKED",
            })
    
    return len(violations) == 0, violations


def generate_report(
    correlation_id: str,
    files: list[str],
    violations: list[dict[str, Any]],
    allowed_paths: list[str],
    forbidden_paths: list[str],
    allowlist_source: str = "default",
) -> dict[str, Any]:
    """Generate scope enforcement report."""
    return {
        "correlation_id": correlation_id,
        "total_files": len(files),
        "allowed_files": len(files) - len(violations),
        "violations": len(violations),
        "passed": len(violations) == 0,
        "details": {
            "files_checked": files,
            "violations": violations,
        },
        "enforcement": {
            "allowlist_source": allowlist_source,
            "allowed_patterns": allowed_paths,
            "forbidden_patterns": forbidden_paths,
        },
    }

def main() -> int:
    """Main scope enforcement function."""
    if len(sys.argv) < 2:
        print("Usage: enforce_scope.py <correlation_id> [--check-git] [--repo-path PATH]")
        print()
        print("Options:")
        print("  --check-git     Also validate git changes against allowlist")
        print("  --repo-path     Path to git repository (default: current dir)")
        print()
        print("Examples:")
        print("  enforce_scope.py ABC123")
        print("  enforce_scope.py ABC123 --check-git --repo-path /home/user/n8n/back")
        return 1
    
    correlation_id = sys.argv[1]
    check_git = "--check-git" in sys.argv
    
    repo_path = None
    if "--repo-path" in sys.argv:
        idx = sys.argv.index("--repo-path")
        if idx + 1 < len(sys.argv):
            repo_path = Path(sys.argv[idx + 1])
    
    # Determine artifacts directory
    script_dir = Path(__file__).parent.parent
    artifacts_dir = script_dir / "artifacts"
    
    print(f"Scope Enforcement Gate")
    print(f"  Correlation ID: {correlation_id}")
    print(f"  Check git: {check_git}")
    print()
    
    # Load node-derived allowlist (REQUIRED for bounded autonomy)
    allowlist_result = load_allowlist(correlation_id, artifacts_dir)
    if allowlist_result is None:
        print("ERROR: No allowlist.json found for this session.")
        print("       Bounded autonomy requires node-derived scope definition.")
        print(f"       Expected: {artifacts_dir / correlation_id / 'allowlist.json'}")
        print()
        print("Hint: Run the node-normalize skill first to generate allowlist.json")
        return 1
    
    allowed_paths, forbidden_paths = allowlist_result
    allowlist_path = artifacts_dir / correlation_id / "allowlist.json"
    print(f"Loaded allowlist from: {allowlist_path}")
    print(f"  Allowed patterns: {len(allowed_paths)}")
    print(f"  Forbidden patterns: {len(forbidden_paths)}")
    print()
    
    # Collect files to check
    files_to_check = []
    
    # From session manifest
    session_files = load_session_files(correlation_id, artifacts_dir)
    if session_files:
        print(f"Files from session manifest: {len(session_files)}")
        files_to_check.extend(session_files)
    
    # From git (if requested)
    if check_git:
        git_files = get_git_changed_files(repo_path)
        print(f"Files from git diff: {len(git_files)}")
        files_to_check.extend(git_files)
    
    # Dedupe
    files_to_check = list(set(files_to_check))
    
    if not files_to_check:
        print("No files to check - scope gate passes by default")
        return 0
    
    print(f"\nChecking {len(files_to_check)} files...")
    
    # Validate against the loaded allowlist
    passed, violations = validate_scope(files_to_check, allowed_paths, forbidden_paths)
    
    # Generate report with allowlist info
    report = generate_report(
        correlation_id,
        files_to_check,
        violations,
        allowed_paths,
        forbidden_paths,
        allowlist_source=str(allowlist_path),
    )
    
    # Output results
    if passed:
        print("\n✓ All files within allowed scope")
        for f in files_to_check:
            print(f"  ✓ {f}")
    else:
        print(f"\n✗ Scope violations detected ({len(violations)}):")
        for v in violations:
            print(f"  ✗ {v['file']}")
            print(f"    Reason: {v['reason']}")
    
    # Save report
    report_path = artifacts_dir / correlation_id / "scope_report.json"
    report_path.parent.mkdir(parents=True, exist_ok=True)
    with open(report_path, "w") as f:
        json.dump(report, f, indent=2)
    print(f"\nReport saved: {report_path}")
    
    return 0 if passed else 1


if __name__ == "__main__":
    sys.exit(main())
