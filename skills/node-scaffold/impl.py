#!/usr/bin/env python3
"""
Node Scaffold Skill Implementation

Generates BaseNode implementation scaffold from a validated schema.
This skill is SYNCHRONOUS - no async patterns allowed (Celery constraint).

Contract: skills/node-scaffold/SKILL.md
"""

from __future__ import annotations

import json
import re
from datetime import datetime
from pathlib import Path
from string import Template
from typing import Any, TYPE_CHECKING

if TYPE_CHECKING:
    from runtime.executor import ExecutionContext


# =============================================================================
# NODE SCAFFOLD TEMPLATES (string.Template for sync-safe templating)
# =============================================================================

NODE_CLASS_TEMPLATE = Template('''#!/usr/bin/env python3
"""
${display_name} Node

Auto-generated scaffold by agent-skills/node-scaffold
Generated: ${generated_at}
Correlation ID: ${correlation_id}

TODO: Implement execute() method
"""

from __future__ import annotations
from typing import Any, Dict, List

# BaseNode import - adjust path based on your project structure
from .base import BaseNode


class ${class_name}Node(BaseNode):
    """
    ${display_name} node.
    
    ${description}
    """

    type = "${node_type}"
    version = ${version}

    description = {
        "displayName": "${display_name}",
        "name": "${node_name}",
        "description": "${description}",
        "icon": "${icon}",
        "group": ${group},
        "version": ${version},
        "defaults": {
            "name": "${display_name}",
        },
        "inputs": ${inputs},
        "outputs": ${outputs},
        "credentials": ${credentials},
    }

    properties = {
        "parameters": ${parameters},
    }

    def execute(self) -> List[List[Dict[str, Any]]]:
        """
        Execute the node operation.

        Returns:
            List[List[Dict]]: Nested list of execution results.
            - Outer list = output branches
            - Inner list = items in that branch
        """
        # Get input data from previous node
        input_data = self.get_input_data()
        results: List[Dict[str, Any]] = []

        for item_index, item in enumerate(input_data):
            # Get operation parameter if exists
            operation = self.get_node_parameter("operation", item_index)
            
            # TODO: Implement operation handlers
            # Each operation from the schema should have a handler
            result = {
                "json": {
                    "operation": operation,
                    "status": "not_implemented",
                    "message": f"Operation '{operation}' not yet implemented",
                },
                "pairedItem": {"item": item_index},
            }
            results.append(result)

        return [results]

    # =========================================================================
    # Operation Handlers (TODO: Implement based on schema operations)
    # =========================================================================
${operation_stubs}
''')

OPERATION_STUB_TEMPLATE = Template('''
    def _handle_${operation_name}(
        self,
        item_index: int,
        item_data: Dict[str, Any],
    ) -> Dict[str, Any]:
        """
        Handle '${operation_value}' operation.
        
        TODO: Implement this operation
        
        Args:
            item_index: Index of current item
            item_data: Input item data
            
        Returns:
            NodeExecutionData dict with 'json' and optionally 'binary'
        """
        # Get credentials if needed
        # credentials = self.get_credentials("${credential_name}")
        
        # Get operation-specific parameters
${parameter_gets}
        
        # TODO: Implement API call or operation logic
        raise NotImplementedError("Operation '${operation_value}' not implemented")
''')

INIT_TEMPLATE = Template('''"""
${display_name} Node Package

Auto-generated by agent-skills/node-scaffold
"""

from .${module_name} import ${class_name}Node

__all__ = ["${class_name}Node"]
''')


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def normalize_to_class_name(name: str) -> str:
    """Convert node name to PascalCase class name."""
    # Remove common prefixes
    name = re.sub(r'^n8n-nodes-base\.', '', name)
    # Split on non-alphanumeric and capitalize
    parts = re.split(r'[^a-zA-Z0-9]+', name)
    return ''.join(word.capitalize() for word in parts if word)


def normalize_to_module_name(name: str) -> str:
    """Convert node name to snake_case module name."""
    # Remove common prefixes
    name = re.sub(r'^n8n-nodes-base\.', '', name)
    # Convert to snake_case
    name = re.sub(r'([A-Z])', r'_\1', name)
    name = re.sub(r'[^a-zA-Z0-9]+', '_', name)
    name = re.sub(r'_+', '_', name)
    return name.lower().strip('_')


def normalize_operation_name(value: str) -> str:
    """Convert operation value to valid Python method name."""
    # Convert camelCase to snake_case
    name = re.sub(r'([A-Z])', r'_\1', value)
    name = re.sub(r'[^a-zA-Z0-9]+', '_', name)
    name = re.sub(r'_+', '_', name)
    return name.lower().strip('_')


def _to_python_literal(value: Any, indent: int = 0) -> str:
    """
    Convert a value to a Python literal string.
    
    Unlike json.dumps(), this outputs True/False/None instead of true/false/null.
    """
    indent_str = " " * indent
    next_indent = indent + 4
    
    if value is None:
        return "None"
    if isinstance(value, bool):
        return "True" if value else "False"
    if isinstance(value, str):
        # Use repr for proper escaping
        return repr(value)
    if isinstance(value, (int, float)):
        return str(value)
    if isinstance(value, list):
        if not value:
            return "[]"
        items = [_to_python_literal(v, next_indent) for v in value]
        inner = f",\n{' ' * next_indent}".join(items)
        return f"[\n{' ' * next_indent}{inner},\n{indent_str}]"
    if isinstance(value, dict):
        if not value:
            return "{}"
        items = [f"{repr(k)}: {_to_python_literal(v, next_indent)}" for k, v in value.items()]
        inner = f",\n{' ' * next_indent}".join(items)
        return f"{{\n{' ' * next_indent}{inner},\n{indent_str}}}"
    # Fallback
    return repr(value)


def format_python_value(value: Any) -> str:
    """Format a Python value for template substitution."""
    return _to_python_literal(value, indent=8)


def extract_operations(parameters: list[dict]) -> list[dict]:
    """Extract operation options from parameters."""
    for param in parameters:
        if param.get("name") == "operation" and param.get("type") == "options":
            return param.get("options", [])
    return []


def extract_credentials(schema: dict) -> list[dict]:
    """Extract credential definitions from schema."""
    # Check description.credentials first
    desc_creds = schema.get("description", {}).get("credentials", [])
    if desc_creds:
        return desc_creds
    # Fall back to properties.credentials
    return schema.get("properties", {}).get("credentials", [])


def generate_parameter_gets(parameters: list[dict], operation: str | None = None) -> str:
    """Generate get_node_parameter calls for operation-specific parameters."""
    lines = []
    for param in parameters:
        param_name = param.get("name", "")
        if param_name == "operation":
            continue  # Skip operation parameter itself
        
        # Check displayOptions to see if parameter is operation-specific
        display_opts = param.get("displayOptions", {})
        show_ops = display_opts.get("show", {}).get("operation", [])
        
        if operation and show_ops and operation not in show_ops:
            continue  # Parameter not relevant to this operation
        
        param_type = param.get("type", "string")
        default = param.get("default")
        default_str = f" or {format_python_value(default)}" if default is not None else ""
        
        lines.append(
            f'        {param_name} = self.get_node_parameter("{param_name}", item_index){default_str}'
        )
    
    return "\n".join(lines) if lines else "        pass  # No additional parameters"


def generate_operation_stubs(
    operations: list[dict],
    parameters: list[dict],
    credentials: list[dict],
) -> str:
    """Generate operation handler stubs."""
    if not operations:
        return ""
    
    stubs = []
    credential_name = credentials[0].get("name", "apiCredentials") if credentials else "apiCredentials"
    
    for op in operations:
        op_value = op.get("value", "")
        op_name = normalize_operation_name(op_value)
        param_gets = generate_parameter_gets(parameters, op_value)
        
        stub = OPERATION_STUB_TEMPLATE.substitute(
            operation_name=op_name,
            operation_value=op_value,
            credential_name=credential_name,
            parameter_gets=param_gets,
        )
        stubs.append(stub)
    
    return "\n".join(stubs)


# =============================================================================
# MAIN IMPLEMENTATION FUNCTION
# =============================================================================

def execute_node_scaffold(ctx: "ExecutionContext") -> dict[str, Any]:
    """
    Execute the node-scaffold skill.
    
    Generates BaseNode implementation scaffold from validated schema.
    
    Args:
        ctx: ExecutionContext with correlation_id, inputs, artifacts_dir
        
    Returns:
        dict with files_created and allowlist
        
    Raises:
        ValueError: If required inputs are missing or invalid
    """
    # Extract inputs
    correlation_id = ctx.inputs.get("correlation_id", ctx.correlation_id)
    node_schema = ctx.inputs.get("node_schema", {})
    normalized_name = ctx.inputs.get("normalized_name", "")
    
    # Optional: target directory (defaults to artifacts for safety)
    target_dir = ctx.inputs.get("target_dir")
    if target_dir:
        target_path = Path(target_dir)
    else:
        # Default: write to artifacts directory for review
        target_path = ctx.artifacts_dir / "generated_node"
    
    # Validate inputs
    if not node_schema:
        raise ValueError("node_schema is required")
    if not normalized_name:
        raise ValueError("normalized_name is required")
    
    # Extract schema components
    node_type = node_schema.get("type", normalized_name)
    version = node_schema.get("version", 1)
    description_data = node_schema.get("description", {})
    properties_data = node_schema.get("properties", {})
    
    display_name = description_data.get("displayName", normalized_name.title())
    node_name = description_data.get("name", normalized_name.lower())
    description_text = description_data.get("description", f"{display_name} node")
    icon = description_data.get("icon", f"file:{node_name}.svg")
    group = description_data.get("group", ["output"])
    inputs = description_data.get("inputs", ["main"])
    outputs = description_data.get("outputs", ["main"])
    
    parameters = properties_data.get("parameters", [])
    credentials = extract_credentials(node_schema)
    operations = extract_operations(parameters)
    
    # Generate names
    class_name = normalize_to_class_name(normalized_name)
    module_name = normalize_to_module_name(normalized_name)
    
    ctx.log("scaffold_config", {
        "class_name": class_name,
        "module_name": module_name,
        "node_type": node_type,
        "operation_count": len(operations),
        "parameter_count": len(parameters),
    })
    
    # Generate operation stubs
    operation_stubs = generate_operation_stubs(operations, parameters, credentials)
    
    # Generate main node file content
    node_content = NODE_CLASS_TEMPLATE.substitute(
        display_name=display_name,
        description=description_text,
        class_name=class_name,
        node_type=node_type,
        node_name=node_name,
        version=version,
        icon=icon,
        group=format_python_value(group),
        inputs=format_python_value(inputs),
        outputs=format_python_value(outputs),
        credentials=format_python_value(credentials),
        parameters=format_python_value(parameters),
        operation_stubs=operation_stubs,
        generated_at=datetime.utcnow().isoformat(),
        correlation_id=correlation_id,
    )
    
    # Generate __init__.py content
    init_content = INIT_TEMPLATE.substitute(
        display_name=display_name,
        module_name=module_name,
        class_name=class_name,
    )
    
    # Create target directory
    target_path.mkdir(parents=True, exist_ok=True)
    
    # Write files
    files_created = []
    
    # Main node file
    node_file = target_path / f"{module_name}.py"
    node_file.write_text(node_content)
    files_created.append(str(node_file))
    ctx.log("file_created", {"path": str(node_file), "type": "node_class"})
    
    # __init__.py
    init_file = target_path / "__init__.py"
    init_file.write_text(init_content)
    files_created.append(str(init_file))
    ctx.log("file_created", {"path": str(init_file), "type": "init"})
    
    # Generate allowlist patterns
    allowlist = {
        "node_name": normalized_name,
        "allowed_paths": [
            f"nodes/{module_name}*",
            f"nodes/{normalized_name}*",
            f"tests/*{module_name}*",
            f"tests/*{normalized_name}*",
            f"credentials/*{module_name}*",
            f"credentials/*{normalized_name}*",
        ],
        "forbidden_paths": [
            "**/base.py",
            "**/Base*.py",
            "**/__init__.py",  # Except the one we generate
        ],
        "generated_at": datetime.utcnow().isoformat(),
        "correlation_id": correlation_id,
    }
    
    # Write artifacts
    ctx.artifacts_dir.mkdir(parents=True, exist_ok=True)
    
    # scaffold_manifest.json
    manifest = {
        "correlation_id": correlation_id,
        "node_name": normalized_name,
        "class_name": class_name,
        "module_name": module_name,
        "files_created": files_created,
        "generated_at": datetime.utcnow().isoformat(),
        "schema_summary": {
            "type": node_type,
            "version": version,
            "operation_count": len(operations),
            "parameter_count": len(parameters),
            "credential_count": len(credentials),
        },
    }
    manifest_path = ctx.artifacts_dir / "scaffold_manifest.json"
    manifest_path.write_text(json.dumps(manifest, indent=2))
    ctx.log("artifact_created", {"path": str(manifest_path), "type": "manifest"})
    
    # allowlist.json
    allowlist_path = ctx.artifacts_dir / "allowlist.json"
    allowlist_path.write_text(json.dumps(allowlist, indent=2))
    ctx.log("artifact_created", {"path": str(allowlist_path), "type": "allowlist"})
    
    return {
        "files_created": files_created,
        "allowlist": {
            "node_name": allowlist["node_name"],
            "patterns": allowlist["allowed_paths"],
        },
    }
