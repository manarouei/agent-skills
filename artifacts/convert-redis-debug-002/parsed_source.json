{
  "version": "1.0",
  "created_at": "2026-02-02T05:32:58.407153+00:00",
  "correlation_id": "convert-redis-debug-002",
  "sections": {
    "class_name": "Redis",
    "node_type": "password",
    "version": 1.0,
    "description": "{\n\t\tdisplayName: 'Redis',\n\t\tname: 'redis',\n\t\ticon: 'file:redis.svg',\n\t\tgroup: ['input'],\n\t\tversion: 1,\n\t\tdescription: 'Get, send and update data in Redis',\n\t\tdefaults: {\n\t\t\tname: 'Redis',\n\t\t},\n\t\tinputs: [NodeConnectionTypes.Main],\n\t\toutputs: [NodeConnectionTypes.Main],\n\t\tusableAsTool: true,\n\t\tcredentials: [\n\t\t\t{\n\t\t\t\tname: 'redis',\n\t\t\t\trequired: true,\n\t\t\t\ttestedBy: 'redisConnectionTest',\n\t\t\t},\n\t\t],\n\t\tproperties: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Operation',\n\t\t\t\tname: 'operation',\n\t\t\t\ttype: 'options',\n\t\t\t\t...",
    "properties": [],
    "methods": [
      "execute"
    ],
    "credentials": [
      "redisConnectionTest"
    ],
    "resources": [],
    "files": [
      "Redis.credentials.ts",
      "Redis.node.ts",
      "types.ts",
      "utils.ts"
    ],
    "code": [
      {
        "file": "Redis.credentials.ts",
        "content": "import type { ICredentialType, INodeProperties } from 'n8n-workflow';\n\nexport class Redis implements ICredentialType {\n\tname = 'redis';\n\n\tdisplayName = 'Redis';\n\n\tdocumentationUrl = 'redis';\n\n\tproperties: INodeProperties[] = [\n\t\t{\n\t\t\tdisplayName: 'Password',\n\t\t\tname: 'password',\n\t\t\ttype: 'string',\n\t\t\ttypeOptions: {\n\t\t\t\tpassword: true,\n\t\t\t},\n\t\t\tdefault: '',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'User',\n\t\t\tname: 'user',\n\t\t\ttype: 'string',\n\t\t\tdefault: '',\n\t\t\thint: 'Leave blank for password-only auth',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Host',\n\t\t\tname: 'host',\n\t\t\ttype: 'string',\n\t\t\tdefault: 'localhost',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Port',\n\t\t\tname: 'port',\n\t\t\ttype: 'number',\n\t\t\tdefault: 6379,\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Database Number',\n\t\t\tname: 'database',\n\t\t\ttype: 'number',\n\t\t\tdefault: 0,\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'SSL',\n\t\t\tname: 'ssl',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t},\n\t];\n}\n"
      },
      {
        "file": "Redis.node.ts",
        "content": "import set from 'lodash/set';\nimport type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\nimport { NodeConnectionTypes, NodeOperationError } from 'n8n-workflow';\n\nimport type { RedisCredential } from './types';\nimport {\n\tsetupRedisClient,\n\tredisConnectionTest,\n\tconvertInfoToObject,\n\tgetValue,\n\tsetValue,\n} from './utils';\n\nexport class Redis implements INodeType {\n\tdescription: INodeTypeDescription = {\n\t\tdisplayName: 'Redis',\n\t\tname: 'redis',\n\t\ticon: 'file:redis.svg',\n\t\tgroup: ['input'],\n\t\tversion: 1,\n\t\tdescription: 'Get, send and update data in Redis',\n\t\tdefaults: {\n\t\t\tname: 'Redis',\n\t\t},\n\t\tinputs: [NodeConnectionTypes.Main],\n\t\toutputs: [NodeConnectionTypes.Main],\n\t\tusableAsTool: true,\n\t\tcredentials: [\n\t\t\t{\n\t\t\t\tname: 'redis',\n\t\t\t\trequired: true,\n\t\t\t\ttestedBy: 'redisConnectionTest',\n\t\t\t},\n\t\t],\n\t\tproperties: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Operation',\n\t\t\t\tname: 'operation',\n\t\t\t\ttype: 'options',\n\t\t\t\tnoDataExpression: true,\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Delete',\n\t\t\t\t\t\tvalue: 'delete',\n\t\t\t\t\t\tdescription: 'Delete a key from Redis',\n\t\t\t\t\t\taction: 'Delete a key from Redis',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Get',\n\t\t\t\t\t\tvalue: 'get',\n\t\t\t\t\t\tdescription: 'Get the value of a key from Redis',\n\t\t\t\t\t\taction: 'Get the value of a key from Redis',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Increment',\n\t\t\t\t\t\tvalue: 'incr',\n\t\t\t\t\t\tdescription: 'Atomically increments a key by 1. Creates the key if it does not exist.',\n\t\t\t\t\t\taction: 'Atomically increment a key by 1. Creates the key if it does not exist.',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Info',\n\t\t\t\t\t\tvalue: 'info',\n\t\t\t\t\t\tdescription: 'Returns generic information about the Redis instance',\n\t\t\t\t\t\taction: 'Return generic information about the Redis instance',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Keys',\n\t\t\t\t\t\tvalue: 'keys',\n\t\t\t\t\t\tdescription: 'Returns all the keys matching a pattern',\n\t\t\t\t\t\taction: 'Return all keys matching a pattern',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Pop',\n\t\t\t\t\t\tvalue: 'pop',\n\t\t\t\t\t\tdescription: 'Pop data from a redis list',\n\t\t\t\t\t\taction: 'Pop data from a redis list',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Publish',\n\t\t\t\t\t\tvalue: 'publish',\n\t\t\t\t\t\tdescription: 'Publish message to redis channel',\n\t\t\t\t\t\taction: 'Publish message to redis channel',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Push',\n\t\t\t\t\t\tvalue: 'push',\n\t\t\t\t\t\tdescription: 'Push data to a redis list',\n\t\t\t\t\t\taction: 'Push data to a redis list',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Set',\n\t\t\t\t\t\tvalue: 'set',\n\t\t\t\t\t\tdescription: 'Set the value of a key in redis',\n\t\t\t\t\t\taction: 'Set the value of a key in redis',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'info',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         delete\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['delete'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to delete from Redis',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         get\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Name',\n\t\t\t\tname: 'propertyName',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 'propertyName',\n\t\t\t\trequired: true,\n\t\t\t\tdescription:\n\t\t\t\t\t'Name of the property to write received data to. Supports dot-notation. Example: \"data.person[0].name\".',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to get from Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Type',\n\t\t\t\tname: 'keyType',\n\t\t\t\ttype: 'options',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Automatic',\n\t\t\t\t\t\tvalue: 'automatic',\n\t\t\t\t\t\tdescription: 'Requests the type before requesting the data (slower)',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Hash',\n\t\t\t\t\t\tvalue: 'hash',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'hash'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'List',\n\t\t\t\t\t\tvalue: 'list',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'lists'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Sets',\n\t\t\t\t\t\tvalue: 'sets',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'sets'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'String',\n\t\t\t\t\t\tvalue: 'string',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'string'\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'automatic',\n\t\t\t\tdescription: 'The type of the key to get',\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'Options',\n\t\t\t\tname: 'options',\n\t\t\t\ttype: 'collection',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tplaceholder: 'Add option',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Dot Notation',\n\t\t\t\t\t\tname: 'dotNotation',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-boolean-without-whether\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'<p>By default, dot-notation is used in property names. This means that \"a.b\" will set the property \"b\" underneath \"a\" so { \"a\": { \"b\": value} }.<p></p>If that is not intended this can be deactivated, it will then set { \"a.b\": value } instead.</p>.',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         incr\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to increment',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Expire',\n\t\t\t\tname: 'expire',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to set a timeout on key',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'TTL',\n\t\t\t\tname: 'ttl',\n\t\t\t\ttype: 'number',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 1,\n\t\t\t\t},\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t\texpire: [true],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 60,\n\t\t\t\tdescription: 'Number of seconds before key expiration',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         keys\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Pattern',\n\t\t\t\tname: 'keyPattern',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['keys'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'The key pattern for the keys to return',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Get Values',\n\t\t\t\tname: 'getValues',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['keys'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: true,\n\t\t\t\tdescription: 'Whether to get the value of matching keys',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         set\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to set in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Value',\n\t\t\t\tname: 'value',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'The value to write in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Type',\n\t\t\t\tname: 'keyType',\n\t\t\t\ttype: 'options',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Automatic',\n\t\t\t\t\t\tvalue: 'automatic',\n\t\t\t\t\t\tdescription: 'Tries to figure out the type automatically depending on the data',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Hash',\n\t\t\t\t\t\tvalue: 'hash',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'hash'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'List',\n\t\t\t\t\t\tvalue: 'list',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'lists'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Sets',\n\t\t\t\t\t\tvalue: 'sets',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'sets'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'String',\n\t\t\t\t\t\tvalue: 'string',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'string'\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'automatic',\n\t\t\t\tdescription: 'The type of the key to set',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Value Is JSON',\n\t\t\t\tname: 'valueIsJSON',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\tkeyType: ['hash'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: true,\n\t\t\t\tdescription: 'Whether the value is JSON or key value pairs',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Expire',\n\t\t\t\tname: 'expire',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to set a timeout on key',\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'TTL',\n\t\t\t\tname: 'ttl',\n\t\t\t\ttype: 'number',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 1,\n\t\t\t\t},\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t\texpire: [true],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 60,\n\t\t\t\tdescription: 'Number of seconds before key expiration',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         publish\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Channel',\n\t\t\t\tname: 'channel',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['publish'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Channel name',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Data',\n\t\t\t\tname: 'messageData',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['publish'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Data to publish',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         push/pop\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'List',\n\t\t\t\tname: 'list',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['push', 'pop'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the list in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Data',\n\t\t\t\tname: 'messageData',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['push'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Data to push',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Tail',\n\t\t\t\tname: 'tail',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['push', 'pop'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to push or pop data from the end of the list',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Name',\n\t\t\t\tname: 'propertyName',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['pop'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 'propertyName',\n\t\t\t\tdescription:\n\t\t\t\t\t'Optional name of the property to write received data to. Supports dot-notation. Example: \"data.person[0].name\".',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Options',\n\t\t\t\tname: 'options',\n\t\t\t\ttype: 'collection',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['pop'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tplaceholder: 'Add option',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Dot Notation',\n\t\t\t\t\t\tname: 'dotNotation',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-boolean-without-whether\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'<p>By default, dot-notation is used in property names. This means that \"a.b\" will set the property \"b\" underneath \"a\" so { \"a\": { \"b\": value} }.<p></p>If that is not intended this can be deactivated, it will then set { \"a.b\": value } instead.</p>.',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t};\n\n\tmethods = {\n\t\tcredentialTest: { redisConnectionTest },\n\t};\n\n\tasync execute(this: IExecuteFunctions) {\n\t\t// TODO: For array and object fields it should not have a \"value\" field it should\n\t\t//       have a parameter field for a path. Because it is not possible to set\n\t\t//       array, object via parameter directly (should maybe be possible?!?!)\n\t\t//       Should maybe have a parameter which is JSON.\n\t\tconst credentials = await this.getCredentials<RedisCredential>('redis');\n\n\t\tconst client = setupRedisClient(credentials);\n\t\tawait client.connect();\n\t\tawait client.ping();\n\n\t\tconst operation = this.getNodeParameter('operation', 0);\n\t\tconst returnItems: INodeExecutionData[] = [];\n\n\t\tif (operation === 'info') {\n\t\t\ttry {\n\t\t\t\tconst result = await client.info();\n\t\t\t\treturnItems.push({ json: convertInfoToObject(result) });\n\t\t\t} catch (error) {\n\t\t\t\tif (this.continueOnFail()) {\n\t\t\t\t\treturnItems.push({\n\t\t\t\t\t\tjson: {\n\t\t\t\t\t\t\terror: error.message,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait client.quit();\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), error);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (\n\t\t\t['delete', 'get', 'keys', 'set', 'incr', 'publish', 'push', 'pop'].includes(operation)\n\t\t) {\n\t\t\tconst items = this.getInputData();\n\n\t\t\tlet item: INodeExecutionData;\n\t\t\tfor (let itemIndex = 0; itemIndex < items.length; itemIndex++) {\n\t\t\t\ttry {\n\t\t\t\t\titem = { json: {}, pairedItem: { item: itemIndex } };\n\n\t\t\t\t\tif (operation === 'delete') {\n\t\t\t\t\t\tconst keyDelete = this.getNodeParameter('key', itemIndex) as string;\n\n\t\t\t\t\t\tawait client.del(keyDelete);\n\t\t\t\t\t\treturnItems.push(items[itemIndex]);\n\t\t\t\t\t} else if (operation === 'get') {\n\t\t\t\t\t\tconst propertyName = this.getNodeParameter('propertyName', itemIndex) as string;\n\t\t\t\t\t\tconst keyGet = this.getNodeParameter('key', itemIndex) as string;\n\t\t\t\t\t\tconst keyType = this.getNodeParameter('keyType', itemIndex) as string;\n\n\t\t\t\t\t\tconst value = (await getValue(client, keyGet, keyType)) ?? null;\n\n\t\t\t\t\t\tconst options = this.getNodeParameter('options', itemIndex, {});\n\n\t\t\t\t\t\tif (options.dotNotation === false) {\n\t\t\t\t\t\t\titem.json[propertyName] = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tset(item.json, propertyName, value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturnItems.push(item);\n\t\t\t\t\t} else if (operation === 'keys') {\n\t\t\t\t\t\tconst keyPattern = this.getNodeParameter('keyPattern', itemIndex) as string;\n\t\t\t\t\t\tconst getValues = this.getNodeParameter('getValues', itemIndex, true) as boolean;\n\n\t\t\t\t\t\tconst keys = await client.keys(keyPattern);\n\n\t\t\t\t\t\tif (!getValues) {\n\t\t\t\t\t\t\treturnItems.push({ json: { keys } });\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const keyName of keys) {\n\t\t\t\t\t\t\titem.json[keyName] = await getValue(client, keyName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturnItems.push(item);\n\t\t\t\t\t} else if (operation === 'set') {\n\t\t\t\t\t\tconst keySet = this.getNodeParameter('key', itemIndex) as string;\n\t\t\t\t\t\tconst value = this.getNodeParameter('value', itemIndex) as string;\n\t\t\t\t\t\tconst keyType = this.getNodeParameter('keyType', itemIndex) as string;\n\t\t\t\t\t\tconst valueIsJSON = this.getNodeParameter('valueIsJSON', itemIndex, true) as boolean;\n\t\t\t\t\t\tconst expire = this.getNodeParameter('expire', itemIndex, false) as boolean;\n\t\t\t\t\t\tconst ttl = this.getNodeParameter('ttl', itemIndex, -1) as number;\n\n\t\t\t\t\t\tawait setValue.call(this, client, keySet, value, expire, ttl, keyType, valueIsJSON);\n\t\t\t\t\t\treturnItems.push(items[itemIndex]);\n\t\t\t\t\t} else if (operation === 'incr') {\n\t\t\t\t\t\tconst keyIncr = this.getNodeParameter('key', itemIndex) as string;\n\t\t\t\t\t\tconst expire = this.getNodeParameter('expire', itemIndex, false) as boolean;\n\t\t\t\t\t\tconst ttl = this.getNodeParameter('ttl', itemIndex, -1) as number;\n\t\t\t\t\t\tconst incrementVal = await client.incr(keyIncr);\n\t\t\t\t\t\tif (expire && ttl > 0) {\n\t\t\t\t\t\t\tawait client.expire(keyIncr, ttl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturnItems.push({ json: { [keyIncr]: incrementVal } });\n\t\t\t\t\t} else if (operation === 'publish') {\n\t\t\t\t\t\tconst channel = this.getNodeParameter('channel', itemIndex) as string;\n\t\t\t\t\t\tconst messageData = this.getNodeParameter('messageData', itemIndex) as string;\n\t\t\t\t\t\tawait client.publish(channel, messageData);\n\t\t\t\t\t\treturnItems.push(items[itemIndex]);\n\t\t\t\t\t} else if (operation === 'push') {\n\t\t\t\t\t\tconst redisList = this.getNodeParameter('list', itemIndex) as string;\n\t\t\t\t\t\tconst messageData = this.getNodeParameter('messageData', itemIndex) as string;\n\t\t\t\t\t\tconst tail = this.getNodeParameter('tail', itemIndex, false) as boolean;\n\t\t\t\t\t\tawait client[tail ? 'rPush' : 'lPush'](redisList, messageData);\n\t\t\t\t\t\treturnItems.push(items[itemIndex]);\n\t\t\t\t\t} else if (operation === 'pop') {\n\t\t\t\t\t\tconst redisList = this.getNodeParameter('list', itemIndex) as string;\n\t\t\t\t\t\tconst tail = this.getNodeParameter('tail', itemIndex, false) as boolean;\n\t\t\t\t\t\tconst propertyName = this.getNodeParameter(\n\t\t\t\t\t\t\t'propertyName',\n\t\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\t\t'propertyName',\n\t\t\t\t\t\t) as string;\n\n\t\t\t\t\t\tconst value = await client[tail ? 'rPop' : 'lPop'](redisList);\n\n\t\t\t\t\t\tlet outputValue;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\toutputValue = value && JSON.parse(value);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\toutputValue = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst options = this.getNodeParameter('options', itemIndex, {});\n\t\t\t\t\t\tif (options.dotNotation === false) {\n\t\t\t\t\t\t\titem.json[propertyName] = outputValue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tset(item.json, propertyName, outputValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturnItems.push(item);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (this.continueOnFail()) {\n\t\t\t\t\t\treturnItems.push({\n\t\t\t\t\t\t\tjson: {\n\t\t\t\t\t\t\t\terror: error.message,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpairedItem: {\n\t\t\t\t\t\t\t\titem: itemIndex,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tawait client.quit();\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), error, { itemIndex });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tawait client.quit();\n\t\treturn [returnItems];\n\t}\n}\n"
      },
      {
        "file": "types.ts",
        "content": "import type { createClient } from 'redis';\n\nexport type RedisClient = ReturnType<typeof createClient>;\n\nexport type RedisCredential = {\n\thost: string;\n\tport: number;\n\tssl?: boolean;\n\tdatabase: number;\n\tuser?: string;\n\tpassword?: string;\n};\n"
      },
      {
        "file": "utils.ts",
        "content": "import type {\n\tICredentialTestFunctions,\n\tICredentialsDecrypted,\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeCredentialTestResult,\n} from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\nimport { createClient } from 'redis';\n\nimport type { RedisCredential, RedisClient } from './types';\n\nexport function setupRedisClient(credentials: RedisCredential): RedisClient {\n\treturn createClient({\n\t\tsocket: {\n\t\t\thost: credentials.host,\n\t\t\tport: credentials.port,\n\t\t\ttls: credentials.ssl === true,\n\t\t},\n\t\tdatabase: credentials.database,\n\t\tusername: credentials.user || undefined,\n\t\tpassword: credentials.password || undefined,\n\t});\n}\n\nexport async function redisConnectionTest(\n\tthis: ICredentialTestFunctions,\n\tcredential: ICredentialsDecrypted,\n): Promise<INodeCredentialTestResult> {\n\tconst credentials = credential.data as RedisCredential;\n\n\ttry {\n\t\tconst client = setupRedisClient(credentials);\n\t\tawait client.connect();\n\t\tawait client.ping();\n\t\treturn {\n\t\t\tstatus: 'OK',\n\t\t\tmessage: 'Connection successful!',\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tstatus: 'Error',\n\t\t\tmessage: error.message,\n\t\t};\n\t}\n}\n\n/** Parses the given value in a number if it is one else returns a string */\nfunction getParsedValue(value: string): string | number {\n\tif (value.match(/^[\\d\\.]+$/) === null) {\n\t\t// Is a string\n\t\treturn value;\n\t} else {\n\t\t// Is a number\n\t\treturn parseFloat(value);\n\t}\n}\n\n/** Converts the Redis Info String into an object */\nexport function convertInfoToObject(stringData: string): IDataObject {\n\tconst returnData: IDataObject = {};\n\n\tlet key: string, value: string;\n\tfor (const line of stringData.split('\\n')) {\n\t\tif (['#', ''].includes(line.charAt(0))) {\n\t\t\tcontinue;\n\t\t}\n\t\t[key, value] = line.split(':');\n\t\tif (key === undefined || value === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tvalue = value.trim();\n\n\t\tif (value.includes('=')) {\n\t\t\treturnData[key] = {};\n\t\t\tlet key2: string, value2: string;\n\t\t\tfor (const keyValuePair of value.split(',')) {\n\t\t\t\t[key2, value2] = keyValuePair.split('=');\n\t\t\t\t(returnData[key] as IDataObject)[key2] = getParsedValue(value2);\n\t\t\t}\n\t\t} else {\n\t\t\treturnData[key] = getParsedValue(value);\n\t\t}\n\t}\n\n\treturn returnData;\n}\n\nexport async function getValue(client: RedisClient, keyName: string, type?: string) {\n\tif (type === undefined || type === 'automatic') {\n\t\t// Request the type first\n\t\ttype = await client.type(keyName);\n\t}\n\n\tif (type === 'string') {\n\t\treturn await client.get(keyName);\n\t} else if (type === 'hash') {\n\t\treturn await client.hGetAll(keyName);\n\t} else if (type === 'list') {\n\t\treturn await client.lRange(keyName, 0, -1);\n\t} else if (type === 'sets') {\n\t\treturn await client.sMembers(keyName);\n\t}\n}\n\nexport async function setValue(\n\tthis: IExecuteFunctions,\n\tclient: RedisClient,\n\tkeyName: string,\n\tvalue: string | number | object | string[] | number[],\n\texpire: boolean,\n\tttl: number,\n\ttype?: string,\n\tvalueIsJSON?: boolean,\n) {\n\tif (type === undefined || type === 'automatic') {\n\t\t// Request the type first\n\t\tif (typeof value === 'string') {\n\t\t\ttype = 'string';\n\t\t} else if (Array.isArray(value)) {\n\t\t\ttype = 'list';\n\t\t} else if (typeof value === 'object') {\n\t\t\ttype = 'hash';\n\t\t} else {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t'Could not identify the type to set. Please set it manually!',\n\t\t\t);\n\t\t}\n\t}\n\n\tif (type === 'string') {\n\t\tawait client.set(keyName, value.toString());\n\t} else if (type === 'hash') {\n\t\tif (valueIsJSON) {\n\t\t\tlet values: unknown;\n\t\t\tif (typeof value === 'string') {\n\t\t\t\ttry {\n\t\t\t\t\tvalues = JSON.parse(value);\n\t\t\t\t} catch {\n\t\t\t\t\t// This is how we originally worked and prevents a breaking change\n\t\t\t\t\tvalues = value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalues = value;\n\t\t\t}\n\t\t\tfor (const key of Object.keys(values as object)) {\n\t\t\t\tawait client.hSet(keyName, key, (values as IDataObject)[key]!.toString());\n\t\t\t}\n\t\t} else {\n\t\t\tconst values = value.toString().split(' ');\n\t\t\tawait client.hSet(keyName, values);\n\t\t}\n\t} else if (type === 'list') {\n\t\tfor (let index = 0; index < (value as string[]).length; index++) {\n\t\t\tawait client.lSet(keyName, index, (value as IDataObject)[index]!.toString());\n\t\t}\n\t} else if (type === 'sets') {\n\t\t//@ts-ignore\n\t\tawait client.sAdd(keyName, value);\n\t}\n\n\tif (expire) {\n\t\tawait client.expire(keyName, ttl);\n\t}\n\treturn;\n}\n"
      }
    ]
  },
  "metadata": {
    "fetch_time": "2026-02-02T05:32:58.405000+00:00",
    "source_type": "TYPE1",
    "source_path": "input_sources/redis",
    "file_count": 4,
    "content_hash": "972043f953c8f801"
  }
}