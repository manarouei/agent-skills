{
  "pipeline_name": "type1-convert",
  "correlation_id": "convert-redis-final-001",
  "status": "completed",
  "started_at": "2026-02-02T05:33:47.588607",
  "completed_at": "2026-02-02T05:33:48.123677",
  "duration_ms": 535,
  "steps": [
    {
      "step_name": "ingest",
      "skill_name": "source-ingest",
      "status": "completed",
      "started_at": "2026-02-02T05:33:47.588839",
      "completed_at": "2026-02-02T05:33:47.596550",
      "duration_ms": 7,
      "outputs": {
        "raw_content": "// === File: Redis.credentials.ts ===\nimport type { ICredentialType, INodeProperties } from 'n8n-workflow';\n\nexport class Redis implements ICredentialType {\n\tname = 'redis';\n\n\tdisplayName = 'Redis';\n\n\tdocumentationUrl = 'redis';\n\n\tproperties: INodeProperties[] = [\n\t\t{\n\t\t\tdisplayName: 'Password',\n\t\t\tname: 'password',\n\t\t\ttype: 'string',\n\t\t\ttypeOptions: {\n\t\t\t\tpassword: true,\n\t\t\t},\n\t\t\tdefault: '',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'User',\n\t\t\tname: 'user',\n\t\t\ttype: 'string',\n\t\t\tdefault: '',\n\t\t\thint: 'Leave blank for password-only auth',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Host',\n\t\t\tname: 'host',\n\t\t\ttype: 'string',\n\t\t\tdefault: 'localhost',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Port',\n\t\t\tname: 'port',\n\t\t\ttype: 'number',\n\t\t\tdefault: 6379,\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Database Number',\n\t\t\tname: 'database',\n\t\t\ttype: 'number',\n\t\t\tdefault: 0,\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'SSL',\n\t\t\tname: 'ssl',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t},\n\t];\n}\n\n\n// === File: Redis.node.ts ===\nimport set from 'lodash/set';\nimport type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\nimport { NodeConnectionTypes, NodeOperationError } from 'n8n-workflow';\n\nimport type { RedisCredential } from './types';\nimport {\n\tsetupRedisClient,\n\tredisConnectionTest,\n\tconvertInfoToObject,\n\tgetValue,\n\tsetValue,\n} from './utils';\n\nexport class Redis implements INodeType {\n\tdescription: INodeTypeDescription = {\n\t\tdisplayName: 'Redis',\n\t\tname: 'redis',\n\t\ticon: 'file:redis.svg',\n\t\tgroup: ['input'],\n\t\tversion: 1,\n\t\tdescription: 'Get, send and update data in Redis',\n\t\tdefaults: {\n\t\t\tname: 'Redis',\n\t\t},\n\t\tinputs: [NodeConnectionTypes.Main],\n\t\toutputs: [NodeConnectionTypes.Main],\n\t\tusableAsTool: true,\n\t\tcredentials: [\n\t\t\t{\n\t\t\t\tname: 'redis',\n\t\t\t\trequired: true,\n\t\t\t\ttestedBy: 'redisConnectionTest',\n\t\t\t},\n\t\t],\n\t\tproperties: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Operation',\n\t\t\t\tname: 'operation',\n\t\t\t\ttype: 'options',\n\t\t\t\tnoDataExpression: true,\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Delete',\n\t\t\t\t\t\tvalue: 'delete',\n\t\t\t\t\t\tdescription: 'Delete a key from Redis',\n\t\t\t\t\t\taction: 'Delete a key from Redis',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Get',\n\t\t\t\t\t\tvalue: 'get',\n\t\t\t\t\t\tdescription: 'Get the value of a key from Redis',\n\t\t\t\t\t\taction: 'Get the value of a key from Redis',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Increment',\n\t\t\t\t\t\tvalue: 'incr',\n\t\t\t\t\t\tdescription: 'Atomically increments a key by 1. Creates the key if it does not exist.',\n\t\t\t\t\t\taction: 'Atomically increment a key by 1. Creates the key if it does not exist.',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Info',\n\t\t\t\t\t\tvalue: 'info',\n\t\t\t\t\t\tdescription: 'Returns generic information about the Redis instance',\n\t\t\t\t\t\taction: 'Return generic information about the Redis instance',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Keys',\n\t\t\t\t\t\tvalue: 'keys',\n\t\t\t\t\t\tdescription: 'Returns all the keys matching a pattern',\n\t\t\t\t\t\taction: 'Return all keys matching a pattern',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Pop',\n\t\t\t\t\t\tvalue: 'pop',\n\t\t\t\t\t\tdescription: 'Pop data from a redis list',\n\t\t\t\t\t\taction: 'Pop data from a redis list',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Publish',\n\t\t\t\t\t\tvalue: 'publish',\n\t\t\t\t\t\tdescription: 'Publish message to redis channel',\n\t\t\t\t\t\taction: 'Publish message to redis channel',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Push',\n\t\t\t\t\t\tvalue: 'push',\n\t\t\t\t\t\tdescription: 'Push data to a redis list',\n\t\t\t\t\t\taction: 'Push data to a redis list',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Set',\n\t\t\t\t\t\tvalue: 'set',\n\t\t\t\t\t\tdescription: 'Set the value of a key in redis',\n\t\t\t\t\t\taction: 'Set the value of a key in redis',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'info',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         delete\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['delete'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to delete from Redis',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         get\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Name',\n\t\t\t\tname: 'propertyName',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 'propertyName',\n\t\t\t\trequired: true,\n\t\t\t\tdescription:\n\t\t\t\t\t'Name of the property to write received data to. Supports dot-notation. Example: \"data.person[0].name\".',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to get from Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Type',\n\t\t\t\tname: 'keyType',\n\t\t\t\ttype: 'options',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Automatic',\n\t\t\t\t\t\tvalue: 'automatic',\n\t\t\t\t\t\tdescription: 'Requests the type before requesting the data (slower)',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Hash',\n\t\t\t\t\t\tvalue: 'hash',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'hash'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'List',\n\t\t\t\t\t\tvalue: 'list',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'lists'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Sets',\n\t\t\t\t\t\tvalue: 'sets',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'sets'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'String',\n\t\t\t\t\t\tvalue: 'string',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'string'\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'automatic',\n\t\t\t\tdescription: 'The type of the key to get',\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'Options',\n\t\t\t\tname: 'options',\n\t\t\t\ttype: 'collection',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tplaceholder: 'Add option',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Dot Notation',\n\t\t\t\t\t\tname: 'dotNotation',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-boolean-without-whether\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'<p>By default, dot-notation is used in property names. This means that \"a.b\" will set the property \"b\" underneath \"a\" so { \"a\": { \"b\": value} }.<p></p>If that is not intended this can be deactivated, it will then set { \"a.b\": value } instead.</p>.',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         incr\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to increment',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Expire',\n\t\t\t\tname: 'expire',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to set a timeout on key',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'TTL',\n\t\t\t\tname: 'ttl',\n\t\t\t\ttype: 'number',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 1,\n\t\t\t\t},\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t\texpire: [true],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 60,\n\t\t\t\tdescription: 'Number of seconds before key expiration',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         keys\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Pattern',\n\t\t\t\tname: 'keyPattern',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['keys'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'The key pattern for the keys to return',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Get Values',\n\t\t\t\tname: 'getValues',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['keys'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: true,\n\t\t\t\tdescription: 'Whether to get the value of matching keys',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         set\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to set in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Value',\n\t\t\t\tname: 'value',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'The value to write in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Type',\n\t\t\t\tname: 'keyType',\n\t\t\t\ttype: 'options',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Automatic',\n\t\t\t\t\t\tvalue: 'automatic',\n\t\t\t\t\t\tdescription: 'Tries to figure out the type automatically depending on the data',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Hash',\n\t\t\t\t\t\tvalue: 'hash',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'hash'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'List',\n\t\t\t\t\t\tvalue: 'list',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'lists'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Sets',\n\t\t\t\t\t\tvalue: 'sets',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'sets'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'String',\n\t\t\t\t\t\tvalue: 'string',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'string'\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'automatic',\n\t\t\t\tdescription: 'The type of the key to set',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Value Is JSON',\n\t\t\t\tname: 'valueIsJSON',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\tkeyType: ['hash'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: true,\n\t\t\t\tdescription: 'Whether the value is JSON or key value pairs',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Expire',\n\t\t\t\tname: 'expire',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to set a timeout on key',\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'TTL',\n\t\t\t\tname: 'ttl',\n\t\t\t\ttype: 'number',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 1,\n\t\t\t\t},\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t\texpire: [true],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 60,\n\t\t\t\tdescription: 'Number of seconds before key expiration',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         publish\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Channel',\n\t\t\t\tname: 'channel',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['publish'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t",
        "parsed_sections": {
          "class_name": "Redis",
          "node_type": "password",
          "version": 1.0,
          "description": "{\n\t\tdisplayName: 'Redis',\n\t\tname: 'redis',\n\t\ticon: 'file:redis.svg',\n\t\tgroup: ['input'],\n\t\tversion: 1,\n\t\tdescription: 'Get, send and update data in Redis',\n\t\tdefaults: {\n\t\t\tname: 'Redis',\n\t\t},\n\t\tinputs: [NodeConnectionTypes.Main],\n\t\toutputs: [NodeConnectionTypes.Main],\n\t\tusableAsTool: true,\n\t\tcredentials: [\n\t\t\t{\n\t\t\t\tname: 'redis',\n\t\t\t\trequired: true,\n\t\t\t\ttestedBy: 'redisConnectionTest',\n\t\t\t},\n\t\t],\n\t\tproperties: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Operation',\n\t\t\t\tname: 'operation',\n\t\t\t\ttype: 'options',\n\t\t\t\t...",
          "properties": [],
          "methods": [
            "execute"
          ],
          "credentials": [
            "redisConnectionTest"
          ],
          "resources": [],
          "files": [
            "Redis.credentials.ts",
            "Redis.node.ts",
            "types.ts",
            "utils.ts"
          ],
          "code": [
            {
              "file": "Redis.credentials.ts",
              "content": "import type { ICredentialType, INodeProperties } from 'n8n-workflow';\n\nexport class Redis implements ICredentialType {\n\tname = 'redis';\n\n\tdisplayName = 'Redis';\n\n\tdocumentationUrl = 'redis';\n\n\tproperties: INodeProperties[] = [\n\t\t{\n\t\t\tdisplayName: 'Password',\n\t\t\tname: 'password',\n\t\t\ttype: 'string',\n\t\t\ttypeOptions: {\n\t\t\t\tpassword: true,\n\t\t\t},\n\t\t\tdefault: '',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'User',\n\t\t\tname: 'user',\n\t\t\ttype: 'string',\n\t\t\tdefault: '',\n\t\t\thint: 'Leave blank for password-only auth',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Host',\n\t\t\tname: 'host',\n\t\t\ttype: 'string',\n\t\t\tdefault: 'localhost',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Port',\n\t\t\tname: 'port',\n\t\t\ttype: 'number',\n\t\t\tdefault: 6379,\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Database Number',\n\t\t\tname: 'database',\n\t\t\ttype: 'number',\n\t\t\tdefault: 0,\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'SSL',\n\t\t\tname: 'ssl',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t},\n\t];\n}\n"
            },
            {
              "file": "Redis.node.ts",
              "content": "import set from 'lodash/set';\nimport type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\nimport { NodeConnectionTypes, NodeOperationError } from 'n8n-workflow';\n\nimport type { RedisCredential } from './types';\nimport {\n\tsetupRedisClient,\n\tredisConnectionTest,\n\tconvertInfoToObject,\n\tgetValue,\n\tsetValue,\n} from './utils';\n\nexport class Redis implements INodeType {\n\tdescription: INodeTypeDescription = {\n\t\tdisplayName: 'Redis',\n\t\tname: 'redis',\n\t\ticon: 'file:redis.svg',\n\t\tgroup: ['input'],\n\t\tversion: 1,\n\t\tdescription: 'Get, send and update data in Redis',\n\t\tdefaults: {\n\t\t\tname: 'Redis',\n\t\t},\n\t\tinputs: [NodeConnectionTypes.Main],\n\t\toutputs: [NodeConnectionTypes.Main],\n\t\tusableAsTool: true,\n\t\tcredentials: [\n\t\t\t{\n\t\t\t\tname: 'redis',\n\t\t\t\trequired: true,\n\t\t\t\ttestedBy: 'redisConnectionTest',\n\t\t\t},\n\t\t],\n\t\tproperties: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Operation',\n\t\t\t\tname: 'operation',\n\t\t\t\ttype: 'options',\n\t\t\t\tnoDataExpression: true,\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Delete',\n\t\t\t\t\t\tvalue: 'delete',\n\t\t\t\t\t\tdescription: 'Delete a key from Redis',\n\t\t\t\t\t\taction: 'Delete a key from Redis',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Get',\n\t\t\t\t\t\tvalue: 'get',\n\t\t\t\t\t\tdescription: 'Get the value of a key from Redis',\n\t\t\t\t\t\taction: 'Get the value of a key from Redis',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Increment',\n\t\t\t\t\t\tvalue: 'incr',\n\t\t\t\t\t\tdescription: 'Atomically increments a key by 1. Creates the key if it does not exist.',\n\t\t\t\t\t\taction: 'Atomically increment a key by 1. Creates the key if it does not exist.',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Info',\n\t\t\t\t\t\tvalue: 'info',\n\t\t\t\t\t\tdescription: 'Returns generic information about the Redis instance',\n\t\t\t\t\t\taction: 'Return generic information about the Redis instance',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Keys',\n\t\t\t\t\t\tvalue: 'keys',\n\t\t\t\t\t\tdescription: 'Returns all the keys matching a pattern',\n\t\t\t\t\t\taction: 'Return all keys matching a pattern',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Pop',\n\t\t\t\t\t\tvalue: 'pop',\n\t\t\t\t\t\tdescription: 'Pop data from a redis list',\n\t\t\t\t\t\taction: 'Pop data from a redis list',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Publish',\n\t\t\t\t\t\tvalue: 'publish',\n\t\t\t\t\t\tdescription: 'Publish message to redis channel',\n\t\t\t\t\t\taction: 'Publish message to redis channel',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Push',\n\t\t\t\t\t\tvalue: 'push',\n\t\t\t\t\t\tdescription: 'Push data to a redis list',\n\t\t\t\t\t\taction: 'Push data to a redis list',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Set',\n\t\t\t\t\t\tvalue: 'set',\n\t\t\t\t\t\tdescription: 'Set the value of a key in redis',\n\t\t\t\t\t\taction: 'Set the value of a key in redis',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'info',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         delete\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['delete'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to delete from Redis',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         get\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Name',\n\t\t\t\tname: 'propertyName',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 'propertyName',\n\t\t\t\trequired: true,\n\t\t\t\tdescription:\n\t\t\t\t\t'Name of the property to write received data to. Supports dot-notation. Example: \"data.person[0].name\".',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to get from Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Type',\n\t\t\t\tname: 'keyType',\n\t\t\t\ttype: 'options',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Automatic',\n\t\t\t\t\t\tvalue: 'automatic',\n\t\t\t\t\t\tdescription: 'Requests the type before requesting the data (slower)',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Hash',\n\t\t\t\t\t\tvalue: 'hash',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'hash'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'List',\n\t\t\t\t\t\tvalue: 'list',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'lists'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Sets',\n\t\t\t\t\t\tvalue: 'sets',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'sets'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'String',\n\t\t\t\t\t\tvalue: 'string',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'string'\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'automatic',\n\t\t\t\tdescription: 'The type of the key to get',\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'Options',\n\t\t\t\tname: 'options',\n\t\t\t\ttype: 'collection',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tplaceholder: 'Add option',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Dot Notation',\n\t\t\t\t\t\tname: 'dotNotation',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-boolean-without-whether\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'<p>By default, dot-notation is used in property names. This means that \"a.b\" will set the property \"b\" underneath \"a\" so { \"a\": { \"b\": value} }.<p></p>If that is not intended this can be deactivated, it will then set { \"a.b\": value } instead.</p>.',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         incr\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to increment',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Expire',\n\t\t\t\tname: 'expire',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to set a timeout on key',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'TTL',\n\t\t\t\tname: 'ttl',\n\t\t\t\ttype: 'number',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 1,\n\t\t\t\t},\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t\texpire: [true],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 60,\n\t\t\t\tdescription: 'Number of seconds before key expiration',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         keys\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Pattern',\n\t\t\t\tname: 'keyPattern',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['keys'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'The key pattern for the keys to return',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Get Values',\n\t\t\t\tname: 'getValues',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['keys'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: true,\n\t\t\t\tdescription: 'Whether to get the value of matching keys',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         set\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to set in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Value',\n\t\t\t\tname: 'value',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'The value to write in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Type',\n\t\t\t\tname: 'keyType',\n\t\t\t\ttype: 'options',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Automatic',\n\t\t\t\t\t\tvalue: 'automatic',\n\t\t\t\t\t\tdescription: 'Tries to figure out the type automatically depending on the data',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Hash',\n\t\t\t\t\t\tvalue: 'hash',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'hash'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'List',\n\t\t\t\t\t\tvalue: 'list',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'lists'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Sets',\n\t\t\t\t\t\tvalue: 'sets',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'sets'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'String',\n\t\t\t\t\t\tvalue: 'string',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'string'\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'automatic',\n\t\t\t\tdescription: 'The type of the key to set',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Value Is JSON',\n\t\t\t\tname: 'valueIsJSON',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\tkeyType: ['hash'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: true,\n\t\t\t\tdescription: 'Whether the value is JSON or key value pairs',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Expire',\n\t\t\t\tname: 'expire',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to set a timeout on key',\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'TTL',\n\t\t\t\tname: 'ttl',\n\t\t\t\ttype: 'number',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 1,\n\t\t\t\t},\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t\texpire: [true],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 60,\n\t\t\t\tdescription: 'Number of seconds before key expiration',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         publish\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Channel',\n\t\t\t\tname: 'channel',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['publish'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Channel name',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Data',\n\t\t\t\tname: 'messageData',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['publish'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Data to publish',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         push/pop\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'List',\n\t\t\t\tname: 'list',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['push', 'pop'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the list in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Data',\n\t\t\t\tname: 'messageData',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['push'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Data to push',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Tail',\n\t\t\t\tname: 'tail',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['push', 'pop'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to push or pop data from the end of the list',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Name',\n\t\t\t\tname: 'propertyName',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['pop'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 'propertyName',\n\t\t\t\tdescription:\n\t\t\t\t\t'Optional name of the property to write received data to. Supports dot-notation. Example: \"data.person[0].name\".',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Options',\n\t\t\t\tname: 'options',\n\t\t\t\ttype: 'collection',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['pop'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tplaceholder: 'Add option',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Dot Notation',\n\t\t\t\t\t\tname: 'dotNotation',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-boolean-without-whether\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'<p>By default, dot-notation is used in property names. This means that \"a.b\" will set the property \"b\" underneath \"a\" so { \"a\": { \"b\": value} }.<p></p>If that is not intended this can be deactivated, it will then set { \"a.b\": value } instead.</p>.',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t};\n\n\tmethods = {\n\t\tcredentialTest: { redisConnectionTest },\n\t};\n\n\tasync execute(this: IExecuteFunctions) {\n\t\t// TODO: For array and object fields it should not have a \"value\" field it should\n\t\t//       have a parameter field for a path. Because it is not possible to set\n\t\t//       array, object via parameter directly (should maybe be possible?!?!)\n\t\t//       Should maybe have a parameter which is JSON.\n\t\tconst credentials = await this.getCredentials<RedisCredential>('redis');\n\n\t\tconst client = setupRedisClient(credentials);\n\t\tawait client.connect();\n\t\tawait client.ping();\n\n\t\tconst operation = this.getNodeParameter('operation', 0);\n\t\tconst returnItems: INodeExecutionData[] = [];\n\n\t\tif (operation === 'info') {\n\t\t\ttry {\n\t\t\t\tconst result = await client.info();\n\t\t\t\treturnItems.push({ json: convertInfoToObject(result) });\n\t\t\t} catch (error) {\n\t\t\t\tif (this.continueOnFail()) {\n\t\t\t\t\treturnItems.push({\n\t\t\t\t\t\tjson: {\n\t\t\t\t\t\t\terror: error.message,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait client.quit();\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), error);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (\n\t\t\t['delete', 'get', 'keys', 'set', 'incr', 'publish', 'push', 'pop'].includes(operation)\n\t\t) {\n\t\t\tconst items = this.getInputData();\n\n\t\t\tlet item: INodeExecutionData;\n\t\t\tfor (let itemIndex = 0; itemIndex < items.length; itemIndex++) {\n\t\t\t\ttry {\n\t\t\t\t\titem = { json: {}, pairedItem: { item: itemIndex } };\n\n\t\t\t\t\tif (operation === 'delete') {\n\t\t\t\t\t\tconst keyDelete = this.getNodeParameter('key', itemIndex) as string;\n\n\t\t\t\t\t\tawait client.del(keyDelete);\n\t\t\t\t\t\treturnItems.push(items[itemIndex]);\n\t\t\t\t\t} else if (operation === 'get') {\n\t\t\t\t\t\tconst propertyName = this.getNodeParameter('propertyName', itemIndex) as string;\n\t\t\t\t\t\tconst keyGet = this.getNodeParameter('key', itemIndex) as string;\n\t\t\t\t\t\tconst keyType = this.getNodeParameter('keyType', itemIndex) as string;\n\n\t\t\t\t\t\tconst value = (await getValue(client, keyGet, keyType)) ?? null;\n\n\t\t\t\t\t\tconst options = this.getNodeParameter('options', itemIndex, {});\n\n\t\t\t\t\t\tif (options.dotNotation === false) {\n\t\t\t\t\t\t\titem.json[propertyName] = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tset(item.json, propertyName, value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturnItems.push(item);\n\t\t\t\t\t} else if (operation === 'keys') {\n\t\t\t\t\t\tconst keyPattern = this.getNodeParameter('keyPattern', itemIndex) as string;\n\t\t\t\t\t\tconst getValues = this.getNodeParameter('getValues', itemIndex, true) as boolean;\n\n\t\t\t\t\t\tconst keys = await client.keys(keyPattern);\n\n\t\t\t\t\t\tif (!getValues) {\n\t\t\t\t\t\t\treturnItems.push({ json: { keys } });\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const keyName of keys) {\n\t\t\t\t\t\t\titem.json[keyName] = await getValue(client, keyName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturnItems.push(item);\n\t\t\t\t\t} else if (operation === 'set') {\n\t\t\t\t\t\tconst keySet = this.getNodeParameter('key', itemIndex) as string;\n\t\t\t\t\t\tconst value = this.getNodeParameter('value', itemIndex) as string;\n\t\t\t\t\t\tconst keyType = this.getNodeParameter('keyType', itemIndex) as string;\n\t\t\t\t\t\tconst valueIsJSON = this.getNodeParameter('valueIsJSON', itemIndex, true) as boolean;\n\t\t\t\t\t\tconst expire = this.getNodeParameter('expire', itemIndex, false) as boolean;\n\t\t\t\t\t\tconst ttl = this.getNodeParameter('ttl', itemIndex, -1) as number;\n\n\t\t\t\t\t\tawait setValue.call(this, client, keySet, value, expire, ttl, keyType, valueIsJSON);\n\t\t\t\t\t\treturnItems.push(items[itemIndex]);\n\t\t\t\t\t} else if (operation === 'incr') {\n\t\t\t\t\t\tconst keyIncr = this.getNodeParameter('key', itemIndex) as string;\n\t\t\t\t\t\tconst expire = this.getNodeParameter('expire', itemIndex, false) as boolean;\n\t\t\t\t\t\tconst ttl = this.getNodeParameter('ttl', itemIndex, -1) as number;\n\t\t\t\t\t\tconst incrementVal = await client.incr(keyIncr);\n\t\t\t\t\t\tif (expire && ttl > 0) {\n\t\t\t\t\t\t\tawait client.expire(keyIncr, ttl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturnItems.push({ json: { [keyIncr]: incrementVal } });\n\t\t\t\t\t} else if (operation === 'publish') {\n\t\t\t\t\t\tconst channel = this.getNodeParameter('channel', itemIndex) as string;\n\t\t\t\t\t\tconst messageData = this.getNodeParameter('messageData', itemIndex) as string;\n\t\t\t\t\t\tawait client.publish(channel, messageData);\n\t\t\t\t\t\treturnItems.push(items[itemIndex]);\n\t\t\t\t\t} else if (operation === 'push') {\n\t\t\t\t\t\tconst redisList = this.getNodeParameter('list', itemIndex) as string;\n\t\t\t\t\t\tconst messageData = this.getNodeParameter('messageData', itemIndex) as string;\n\t\t\t\t\t\tconst tail = this.getNodeParameter('tail', itemIndex, false) as boolean;\n\t\t\t\t\t\tawait client[tail ? 'rPush' : 'lPush'](redisList, messageData);\n\t\t\t\t\t\treturnItems.push(items[itemIndex]);\n\t\t\t\t\t} else if (operation === 'pop') {\n\t\t\t\t\t\tconst redisList = this.getNodeParameter('list', itemIndex) as string;\n\t\t\t\t\t\tconst tail = this.getNodeParameter('tail', itemIndex, false) as boolean;\n\t\t\t\t\t\tconst propertyName = this.getNodeParameter(\n\t\t\t\t\t\t\t'propertyName',\n\t\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\t\t'propertyName',\n\t\t\t\t\t\t) as string;\n\n\t\t\t\t\t\tconst value = await client[tail ? 'rPop' : 'lPop'](redisList);\n\n\t\t\t\t\t\tlet outputValue;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\toutputValue = value && JSON.parse(value);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\toutputValue = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst options = this.getNodeParameter('options', itemIndex, {});\n\t\t\t\t\t\tif (options.dotNotation === false) {\n\t\t\t\t\t\t\titem.json[propertyName] = outputValue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tset(item.json, propertyName, outputValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturnItems.push(item);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (this.continueOnFail()) {\n\t\t\t\t\t\treturnItems.push({\n\t\t\t\t\t\t\tjson: {\n\t\t\t\t\t\t\t\terror: error.message,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpairedItem: {\n\t\t\t\t\t\t\t\titem: itemIndex,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tawait client.quit();\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), error, { itemIndex });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tawait client.quit();\n\t\treturn [returnItems];\n\t}\n}\n"
            },
            {
              "file": "types.ts",
              "content": "import type { createClient } from 'redis';\n\nexport type RedisClient = ReturnType<typeof createClient>;\n\nexport type RedisCredential = {\n\thost: string;\n\tport: number;\n\tssl?: boolean;\n\tdatabase: number;\n\tuser?: string;\n\tpassword?: string;\n};\n"
            },
            {
              "file": "utils.ts",
              "content": "import type {\n\tICredentialTestFunctions,\n\tICredentialsDecrypted,\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeCredentialTestResult,\n} from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\nimport { createClient } from 'redis';\n\nimport type { RedisCredential, RedisClient } from './types';\n\nexport function setupRedisClient(credentials: RedisCredential): RedisClient {\n\treturn createClient({\n\t\tsocket: {\n\t\t\thost: credentials.host,\n\t\t\tport: credentials.port,\n\t\t\ttls: credentials.ssl === true,\n\t\t},\n\t\tdatabase: credentials.database,\n\t\tusername: credentials.user || undefined,\n\t\tpassword: credentials.password || undefined,\n\t});\n}\n\nexport async function redisConnectionTest(\n\tthis: ICredentialTestFunctions,\n\tcredential: ICredentialsDecrypted,\n): Promise<INodeCredentialTestResult> {\n\tconst credentials = credential.data as RedisCredential;\n\n\ttry {\n\t\tconst client = setupRedisClient(credentials);\n\t\tawait client.connect();\n\t\tawait client.ping();\n\t\treturn {\n\t\t\tstatus: 'OK',\n\t\t\tmessage: 'Connection successful!',\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tstatus: 'Error',\n\t\t\tmessage: error.message,\n\t\t};\n\t}\n}\n\n/** Parses the given value in a number if it is one else returns a string */\nfunction getParsedValue(value: string): string | number {\n\tif (value.match(/^[\\d\\.]+$/) === null) {\n\t\t// Is a string\n\t\treturn value;\n\t} else {\n\t\t// Is a number\n\t\treturn parseFloat(value);\n\t}\n}\n\n/** Converts the Redis Info String into an object */\nexport function convertInfoToObject(stringData: string): IDataObject {\n\tconst returnData: IDataObject = {};\n\n\tlet key: string, value: string;\n\tfor (const line of stringData.split('\\n')) {\n\t\tif (['#', ''].includes(line.charAt(0))) {\n\t\t\tcontinue;\n\t\t}\n\t\t[key, value] = line.split(':');\n\t\tif (key === undefined || value === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tvalue = value.trim();\n\n\t\tif (value.includes('=')) {\n\t\t\treturnData[key] = {};\n\t\t\tlet key2: string, value2: string;\n\t\t\tfor (const keyValuePair of value.split(',')) {\n\t\t\t\t[key2, value2] = keyValuePair.split('=');\n\t\t\t\t(returnData[key] as IDataObject)[key2] = getParsedValue(value2);\n\t\t\t}\n\t\t} else {\n\t\t\treturnData[key] = getParsedValue(value);\n\t\t}\n\t}\n\n\treturn returnData;\n}\n\nexport async function getValue(client: RedisClient, keyName: string, type?: string) {\n\tif (type === undefined || type === 'automatic') {\n\t\t// Request the type first\n\t\ttype = await client.type(keyName);\n\t}\n\n\tif (type === 'string') {\n\t\treturn await client.get(keyName);\n\t} else if (type === 'hash') {\n\t\treturn await client.hGetAll(keyName);\n\t} else if (type === 'list') {\n\t\treturn await client.lRange(keyName, 0, -1);\n\t} else if (type === 'sets') {\n\t\treturn await client.sMembers(keyName);\n\t}\n}\n\nexport async function setValue(\n\tthis: IExecuteFunctions,\n\tclient: RedisClient,\n\tkeyName: string,\n\tvalue: string | number | object | string[] | number[],\n\texpire: boolean,\n\tttl: number,\n\ttype?: string,\n\tvalueIsJSON?: boolean,\n) {\n\tif (type === undefined || type === 'automatic') {\n\t\t// Request the type first\n\t\tif (typeof value === 'string') {\n\t\t\ttype = 'string';\n\t\t} else if (Array.isArray(value)) {\n\t\t\ttype = 'list';\n\t\t} else if (typeof value === 'object') {\n\t\t\ttype = 'hash';\n\t\t} else {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t'Could not identify the type to set. Please set it manually!',\n\t\t\t);\n\t\t}\n\t}\n\n\tif (type === 'string') {\n\t\tawait client.set(keyName, value.toString());\n\t} else if (type === 'hash') {\n\t\tif (valueIsJSON) {\n\t\t\tlet values: unknown;\n\t\t\tif (typeof value === 'string') {\n\t\t\t\ttry {\n\t\t\t\t\tvalues = JSON.parse(value);\n\t\t\t\t} catch {\n\t\t\t\t\t// This is how we originally worked and prevents a breaking change\n\t\t\t\t\tvalues = value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalues = value;\n\t\t\t}\n\t\t\tfor (const key of Object.keys(values as object)) {\n\t\t\t\tawait client.hSet(keyName, key, (values as IDataObject)[key]!.toString());\n\t\t\t}\n\t\t} else {\n\t\t\tconst values = value.toString().split(' ');\n\t\t\tawait client.hSet(keyName, values);\n\t\t}\n\t} else if (type === 'list') {\n\t\tfor (let index = 0; index < (value as string[]).length; index++) {\n\t\t\tawait client.lSet(keyName, index, (value as IDataObject)[index]!.toString());\n\t\t}\n\t} else if (type === 'sets') {\n\t\t//@ts-ignore\n\t\tawait client.sAdd(keyName, value);\n\t}\n\n\tif (expire) {\n\t\tawait client.expire(keyName, ttl);\n\t}\n\treturn;\n}\n"
            }
          ]
        },
        "metadata": {
          "fetch_time": "2026-02-02T05:33:47.593980+00:00",
          "source_type": "TYPE1",
          "source_path": "input_sources/redis",
          "file_count": 4,
          "content_hash": "972043f953c8f801"
        },
        "artifacts": {
          "raw_source": "/home/toni/agent-skills/artifacts/convert-redis-final-001/raw_source.txt",
          "parsed_source": "/home/toni/agent-skills/artifacts/convert-redis-final-001/parsed_source.json",
          "source_bundle": "/home/toni/agent-skills/artifacts/convert-redis-final-001/source_bundle"
        }
      },
      "artifacts_produced": [
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/raw_source.txt",
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/parsed_source.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "infer-schema",
      "skill_name": "schema-infer",
      "status": "completed",
      "started_at": "2026-02-02T05:33:47.596576",
      "completed_at": "2026-02-02T05:33:47.957319",
      "duration_ms": 360,
      "outputs": {
        "inferred_schema": {
          "type": "redis",
          "version": 1,
          "description": {
            "displayName": "Redis",
            "name": "redis",
            "inputs": [
              {
                "name": "main",
                "type": "main"
              }
            ],
            "outputs": [
              {
                "name": "main",
                "type": "main"
              }
            ]
          },
          "properties": {
            "parameters": [
              {
                "name": "operation",
                "display_name": "Operation",
                "type": "OPTIONS",
                "options": [
                  {
                    "name": "Delete",
                    "value": "delete",
                    "description": "Delete a key from Redis"
                  },
                  {
                    "name": "Get",
                    "value": "get",
                    "description": "Get the value of a key from Redis"
                  },
                  {
                    "name": "Increment",
                    "value": "incr",
                    "description": "Atomically increments a key by 1. Creates the key if it does not exist."
                  },
                  {
                    "name": "Info",
                    "value": "info",
                    "description": "Returns generic information about the Redis instance"
                  },
                  {
                    "name": "Keys",
                    "value": "keys",
                    "description": "Returns all the keys matching a pattern"
                  },
                  {
                    "name": "Pop",
                    "value": "pop",
                    "description": "Pop data from a redis list"
                  },
                  {
                    "name": "Publish",
                    "value": "publish",
                    "description": "Publish message to redis channel"
                  },
                  {
                    "name": "Push",
                    "value": "push",
                    "description": "Push data to a redis list"
                  },
                  {
                    "name": "Set",
                    "value": "set",
                    "description": "Set the value of a key in redis"
                  }
                ],
                "default": "delete",
                "description": "Operation to perform"
              },
              {
                "name": "key",
                "display_name": "Key",
                "type": "STRING",
                "default": "",
                "required": true,
                "description": "Name of the key to delete from Redis",
                "display_options": {
                  "show": {
                    "operation": [
                      "delete"
                    ]
                  }
                }
              },
              {
                "name": "propertyName",
                "display_name": "Name",
                "type": "STRING",
                "default": "propertyName",
                "required": true,
                "description": "Name of the property to write received data to. Supports dot-notation. Example: ",
                "display_options": {
                  "show": {
                    "operation": [
                      "get"
                    ]
                  }
                }
              },
              {
                "name": "keyType",
                "display_name": "Key Type",
                "type": "OPTIONS",
                "default": "automatic",
                "description": "Requests the type before requesting the data (slower)",
                "display_options": {
                  "show": {
                    "operation": [
                      "get"
                    ]
                  }
                },
                "options": [
                  {
                    "name": "Automatic",
                    "value": "automatic"
                  },
                  {
                    "name": "Hash",
                    "value": "hash"
                  },
                  {
                    "name": "List",
                    "value": "list"
                  },
                  {
                    "name": "Sets",
                    "value": "sets"
                  },
                  {
                    "name": "String",
                    "value": "string"
                  }
                ]
              },
              {
                "name": "options",
                "display_name": "Options",
                "type": "COLLECTION",
                "default": "",
                "description": "<p>By default, dot-notation is used in property names. This means that ",
                "display_options": {
                  "show": {
                    "operation": [
                      "get"
                    ]
                  }
                }
              },
              {
                "name": "expire",
                "display_name": "Expire",
                "type": "BOOLEAN",
                "default": false,
                "description": "Whether to set a timeout on key",
                "display_options": {
                  "show": {
                    "operation": [
                      "incr"
                    ]
                  }
                }
              },
              {
                "name": "ttl",
                "display_name": "TTL",
                "type": "NUMBER",
                "default": 60,
                "description": "Number of seconds before key expiration",
                "display_options": {
                  "show": {
                    "operation": [
                      "incr"
                    ]
                  }
                }
              },
              {
                "name": "keyPattern",
                "display_name": "Key Pattern",
                "type": "STRING",
                "default": "",
                "required": true,
                "description": "The key pattern for the keys to return",
                "display_options": {
                  "show": {
                    "operation": [
                      "keys"
                    ]
                  }
                }
              },
              {
                "name": "getValues",
                "display_name": "Get Values",
                "type": "BOOLEAN",
                "default": true,
                "description": "Whether to get the value of matching keys",
                "display_options": {
                  "show": {
                    "operation": [
                      "keys"
                    ]
                  }
                }
              },
              {
                "name": "value",
                "display_name": "Value",
                "type": "STRING",
                "default": "",
                "description": "The value to write in Redis",
                "display_options": {
                  "show": {
                    "operation": [
                      "set"
                    ]
                  }
                }
              },
              {
                "name": "valueIsJSON",
                "display_name": "Value Is JSON",
                "type": "BOOLEAN",
                "default": true,
                "description": "Whether the value is JSON or key value pairs"
              },
              {
                "name": "channel",
                "display_name": "Channel",
                "type": "STRING",
                "default": "",
                "required": true,
                "description": "Channel name",
                "display_options": {
                  "show": {
                    "operation": [
                      "publish"
                    ]
                  }
                }
              },
              {
                "name": "messageData",
                "display_name": "Data",
                "type": "STRING",
                "default": "",
                "required": true,
                "description": "Data to publish",
                "display_options": {
                  "show": {
                    "operation": [
                      "publish"
                    ]
                  }
                }
              },
              {
                "name": "list",
                "display_name": "List",
                "type": "STRING",
                "default": "",
                "required": true,
                "description": "Name of the list in Redis",
                "display_options": {
                  "show": {
                    "operation": [
                      "push",
                      "pop"
                    ]
                  }
                }
              },
              {
                "name": "tail",
                "display_name": "Tail",
                "type": "BOOLEAN",
                "default": false,
                "description": "Whether to push or pop data from the end of the list",
                "display_options": {
                  "show": {
                    "operation": [
                      "push",
                      "pop"
                    ]
                  }
                }
              }
            ],
            "credentials": [
              {
                "name": "redis",
                "required": true
              }
            ]
          },
          "operations": [
            {
              "name": "delete",
              "display_name": "Delete",
              "description": "Delete a key from Redis"
            },
            {
              "name": "get",
              "display_name": "Get",
              "description": "Get the value of a key from Redis"
            },
            {
              "name": "incr",
              "display_name": "Increment",
              "description": "Atomically increments a key by 1. Creates the key if it does not exist."
            },
            {
              "name": "info",
              "display_name": "Info",
              "description": "Returns generic information about the Redis instance"
            },
            {
              "name": "keys",
              "display_name": "Keys",
              "description": "Returns all the keys matching a pattern"
            },
            {
              "name": "pop",
              "display_name": "Pop",
              "description": "Pop data from a redis list"
            },
            {
              "name": "publish",
              "display_name": "Publish",
              "description": "Publish message to redis channel"
            },
            {
              "name": "push",
              "display_name": "Push",
              "description": "Push data to a redis list"
            },
            {
              "name": "set",
              "display_name": "Set",
              "description": "Set the value of a key in redis"
            }
          ],
          "resources": [],
          "credentials": [
            {
              "name": "redis",
              "required": true
            }
          ],
          "execution_contract": {
            "semantic_class": "tcp_client",
            "io_cardinality": {
              "input_count": 1,
              "input_required": [
                0
              ],
              "output_count": 1,
              "output_names": [
                "main"
              ],
              "item_mapping": "1:1"
            },
            "connection": {
              "type": "tcp",
              "factory_method": "_get_redis_client",
              "library": "redis",
              "pooling": false,
              "cleanup": "context_manager"
            },
            "state": {
              "cross_execution": "none",
              "within_execution": "none",
              "persistence_key": null
            },
            "credentials": {
              "type": "redisApi",
              "resolution": "direct",
              "selector_param": null,
              "connection_params": []
            },
            "http_config": null,
            "sdk_config": null,
            "transform_config": null
          }
        },
        "trace_map": {
          "correlation_id": "convert-redis-final-001",
          "node_type": "redis",
          "trace_entries": [
            {
              "field_path": "operations[0].name",
              "source": "SOURCE_CODE",
              "evidence": "n8n operation 'delete' (display: 'Delete') in Redis.node.ts",
              "confidence": "high",
              "source_file": "Redis.node.ts",
              "line_range": "L42",
              "excerpt_hash": "762cadbe0268"
            },
            {
              "field_path": "operations[1].name",
              "source": "SOURCE_CODE",
              "evidence": "n8n operation 'get' (display: 'Get') in Redis.node.ts",
              "confidence": "high",
              "source_file": "Redis.node.ts",
              "line_range": "L42",
              "excerpt_hash": "c9d917f6e0c5"
            },
            {
              "field_path": "operations[2].name",
              "source": "SOURCE_CODE",
              "evidence": "n8n operation 'incr' (display: 'Increment') in Redis.node.ts",
              "confidence": "high",
              "source_file": "Redis.node.ts",
              "line_range": "L42",
              "excerpt_hash": "fd79c76ae160"
            },
            {
              "field_path": "operations[3].name",
              "source": "SOURCE_CODE",
              "evidence": "n8n operation 'info' (display: 'Info') in Redis.node.ts",
              "confidence": "high",
              "source_file": "Redis.node.ts",
              "line_range": "L42",
              "excerpt_hash": "b65c974301fb"
            },
            {
              "field_path": "operations[4].name",
              "source": "SOURCE_CODE",
              "evidence": "n8n operation 'keys' (display: 'Keys') in Redis.node.ts",
              "confidence": "high",
              "source_file": "Redis.node.ts",
              "line_range": "L42",
              "excerpt_hash": "e095cc304207"
            },
            {
              "field_path": "operations[5].name",
              "source": "SOURCE_CODE",
              "evidence": "n8n operation 'pop' (display: 'Pop') in Redis.node.ts",
              "confidence": "high",
              "source_file": "Redis.node.ts",
              "line_range": "L42",
              "excerpt_hash": "7b6e2846d044"
            },
            {
              "field_path": "operations[6].name",
              "source": "SOURCE_CODE",
              "evidence": "n8n operation 'publish' (display: 'Publish') in Redis.node.ts",
              "confidence": "high",
              "source_file": "Redis.node.ts",
              "line_range": "L42",
              "excerpt_hash": "89c2f708a4fa"
            },
            {
              "field_path": "operations[7].name",
              "source": "SOURCE_CODE",
              "evidence": "n8n operation 'push' (display: 'Push') in Redis.node.ts",
              "confidence": "high",
              "source_file": "Redis.node.ts",
              "line_range": "L42",
              "excerpt_hash": "c15d260785b8"
            },
            {
              "field_path": "operations[8].name",
              "source": "SOURCE_CODE",
              "evidence": "n8n operation 'set' (display: 'Set') in Redis.node.ts",
              "confidence": "high",
              "source_file": "Redis.node.ts",
              "line_range": "L42",
              "excerpt_hash": "ed0d55c489a4"
            },
            {
              "field_path": "description.displayName",
              "source": "SOURCE_CODE",
              "evidence": "displayName: 'Redis' in Redis.node.ts",
              "confidence": "high",
              "source_file": "Redis.node.ts"
            },
            {
              "field_path": "parameters.operation",
              "source": "SOURCE_CODE",
              "evidence": "Operation parameter with 9 options in Redis.node.ts",
              "confidence": "high",
              "source_file": "Redis.node.ts"
            },
            {
              "field_path": "credentials[0]",
              "source": "SOURCE_CODE",
              "evidence": "Credential 'redis' (required=True) in Redis.node.ts",
              "confidence": "high",
              "source_file": "Redis.node.ts"
            },
            {
              "field_path": "execution_contract.semantic_class",
              "source": "SOURCE_CODE",
              "evidence": "Detected semantic class 'tcp_client' from code patterns and node type",
              "confidence": "high",
              "source_file": "multiple"
            }
          ],
          "generated_at": "2026-02-02T05:33:47.737323",
          "skill_version": "1.0.0",
          "_hybrid_metadata": {
            "source_type": "TYPE1",
            "extraction_confidence": 0.935,
            "advisor_used": false,
            "assumption_ratio": 0.0,
            "deterministic_operations": 13,
            "assumption_operations": 0
          }
        },
        "schema": {
          "type": "redis",
          "version": 1,
          "description": {
            "displayName": "Redis",
            "name": "redis",
            "inputs": [
              {
                "name": "main",
                "type": "main"
              }
            ],
            "outputs": [
              {
                "name": "main",
                "type": "main"
              }
            ]
          },
          "properties": {
            "parameters": [
              {
                "name": "operation",
                "display_name": "Operation",
                "type": "OPTIONS",
                "options": [
                  {
                    "name": "Delete",
                    "value": "delete",
                    "description": "Delete a key from Redis"
                  },
                  {
                    "name": "Get",
                    "value": "get",
                    "description": "Get the value of a key from Redis"
                  },
                  {
                    "name": "Increment",
                    "value": "incr",
                    "description": "Atomically increments a key by 1. Creates the key if it does not exist."
                  },
                  {
                    "name": "Info",
                    "value": "info",
                    "description": "Returns generic information about the Redis instance"
                  },
                  {
                    "name": "Keys",
                    "value": "keys",
                    "description": "Returns all the keys matching a pattern"
                  },
                  {
                    "name": "Pop",
                    "value": "pop",
                    "description": "Pop data from a redis list"
                  },
                  {
                    "name": "Publish",
                    "value": "publish",
                    "description": "Publish message to redis channel"
                  },
                  {
                    "name": "Push",
                    "value": "push",
                    "description": "Push data to a redis list"
                  },
                  {
                    "name": "Set",
                    "value": "set",
                    "description": "Set the value of a key in redis"
                  }
                ],
                "default": "delete",
                "description": "Operation to perform"
              },
              {
                "name": "key",
                "display_name": "Key",
                "type": "STRING",
                "default": "",
                "required": true,
                "description": "Name of the key to delete from Redis",
                "display_options": {
                  "show": {
                    "operation": [
                      "delete"
                    ]
                  }
                }
              },
              {
                "name": "propertyName",
                "display_name": "Name",
                "type": "STRING",
                "default": "propertyName",
                "required": true,
                "description": "Name of the property to write received data to. Supports dot-notation. Example: ",
                "display_options": {
                  "show": {
                    "operation": [
                      "get"
                    ]
                  }
                }
              },
              {
                "name": "keyType",
                "display_name": "Key Type",
                "type": "OPTIONS",
                "default": "automatic",
                "description": "Requests the type before requesting the data (slower)",
                "display_options": {
                  "show": {
                    "operation": [
                      "get"
                    ]
                  }
                },
                "options": [
                  {
                    "name": "Automatic",
                    "value": "automatic"
                  },
                  {
                    "name": "Hash",
                    "value": "hash"
                  },
                  {
                    "name": "List",
                    "value": "list"
                  },
                  {
                    "name": "Sets",
                    "value": "sets"
                  },
                  {
                    "name": "String",
                    "value": "string"
                  }
                ]
              },
              {
                "name": "options",
                "display_name": "Options",
                "type": "COLLECTION",
                "default": "",
                "description": "<p>By default, dot-notation is used in property names. This means that ",
                "display_options": {
                  "show": {
                    "operation": [
                      "get"
                    ]
                  }
                }
              },
              {
                "name": "expire",
                "display_name": "Expire",
                "type": "BOOLEAN",
                "default": false,
                "description": "Whether to set a timeout on key",
                "display_options": {
                  "show": {
                    "operation": [
                      "incr"
                    ]
                  }
                }
              },
              {
                "name": "ttl",
                "display_name": "TTL",
                "type": "NUMBER",
                "default": 60,
                "description": "Number of seconds before key expiration",
                "display_options": {
                  "show": {
                    "operation": [
                      "incr"
                    ]
                  }
                }
              },
              {
                "name": "keyPattern",
                "display_name": "Key Pattern",
                "type": "STRING",
                "default": "",
                "required": true,
                "description": "The key pattern for the keys to return",
                "display_options": {
                  "show": {
                    "operation": [
                      "keys"
                    ]
                  }
                }
              },
              {
                "name": "getValues",
                "display_name": "Get Values",
                "type": "BOOLEAN",
                "default": true,
                "description": "Whether to get the value of matching keys",
                "display_options": {
                  "show": {
                    "operation": [
                      "keys"
                    ]
                  }
                }
              },
              {
                "name": "value",
                "display_name": "Value",
                "type": "STRING",
                "default": "",
                "description": "The value to write in Redis",
                "display_options": {
                  "show": {
                    "operation": [
                      "set"
                    ]
                  }
                }
              },
              {
                "name": "valueIsJSON",
                "display_name": "Value Is JSON",
                "type": "BOOLEAN",
                "default": true,
                "description": "Whether the value is JSON or key value pairs"
              },
              {
                "name": "channel",
                "display_name": "Channel",
                "type": "STRING",
                "default": "",
                "required": true,
                "description": "Channel name",
                "display_options": {
                  "show": {
                    "operation": [
                      "publish"
                    ]
                  }
                }
              },
              {
                "name": "messageData",
                "display_name": "Data",
                "type": "STRING",
                "default": "",
                "required": true,
                "description": "Data to publish",
                "display_options": {
                  "show": {
                    "operation": [
                      "publish"
                    ]
                  }
                }
              },
              {
                "name": "list",
                "display_name": "List",
                "type": "STRING",
                "default": "",
                "required": true,
                "description": "Name of the list in Redis",
                "display_options": {
                  "show": {
                    "operation": [
                      "push",
                      "pop"
                    ]
                  }
                }
              },
              {
                "name": "tail",
                "display_name": "Tail",
                "type": "BOOLEAN",
                "default": false,
                "description": "Whether to push or pop data from the end of the list",
                "display_options": {
                  "show": {
                    "operation": [
                      "push",
                      "pop"
                    ]
                  }
                }
              }
            ],
            "credentials": [
              {
                "name": "redis",
                "required": true
              }
            ]
          },
          "operations": [
            {
              "name": "delete",
              "display_name": "Delete",
              "description": "Delete a key from Redis"
            },
            {
              "name": "get",
              "display_name": "Get",
              "description": "Get the value of a key from Redis"
            },
            {
              "name": "incr",
              "display_name": "Increment",
              "description": "Atomically increments a key by 1. Creates the key if it does not exist."
            },
            {
              "name": "info",
              "display_name": "Info",
              "description": "Returns generic information about the Redis instance"
            },
            {
              "name": "keys",
              "display_name": "Keys",
              "description": "Returns all the keys matching a pattern"
            },
            {
              "name": "pop",
              "display_name": "Pop",
              "description": "Pop data from a redis list"
            },
            {
              "name": "publish",
              "display_name": "Publish",
              "description": "Publish message to redis channel"
            },
            {
              "name": "push",
              "display_name": "Push",
              "description": "Push data to a redis list"
            },
            {
              "name": "set",
              "display_name": "Set",
              "description": "Set the value of a key in redis"
            }
          ],
          "resources": [],
          "credentials": [
            {
              "name": "redis",
              "required": true
            }
          ],
          "execution_contract": {
            "semantic_class": "tcp_client",
            "io_cardinality": {
              "input_count": 1,
              "input_required": [
                0
              ],
              "output_count": 1,
              "output_names": [
                "main"
              ],
              "item_mapping": "1:1"
            },
            "connection": {
              "type": "tcp",
              "factory_method": "_get_redis_client",
              "library": "redis",
              "pooling": false,
              "cleanup": "context_manager"
            },
            "state": {
              "cross_execution": "none",
              "within_execution": "none",
              "persistence_key": null
            },
            "credentials": {
              "type": "redisApi",
              "resolution": "direct",
              "selector_param": null,
              "connection_params": []
            },
            "http_config": null,
            "sdk_config": null,
            "transform_config": null
          }
        },
        "assumptions": [],
        "artifacts_written": [
          "/home/toni/agent-skills/artifacts/convert-redis-final-001/schema/inferred_schema.json",
          "/home/toni/agent-skills/artifacts/convert-redis-final-001/schema/trace_map.json"
        ],
        "extraction_confidence": 0.935,
        "advisor_used": false
      },
      "artifacts_produced": [
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/inferred_schema.json",
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/trace_map.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "scaffold",
      "skill_name": "node-scaffold",
      "status": "completed",
      "started_at": "2026-02-02T05:33:47.957367",
      "completed_at": "2026-02-02T05:33:47.966188",
      "duration_ms": 8,
      "outputs": {
        "files_created": [
          "/home/toni/agent-skills/artifacts/convert-redis-final-001/generated_node/redis.py",
          "/home/toni/agent-skills/artifacts/convert-redis-final-001/generated_node/__init__.py"
        ],
        "allowlist": {
          "node_name": "redis",
          "patterns": [
            "nodes/redis*",
            "nodes/redis*",
            "tests/*redis*",
            "tests/*redis*",
            "credentials/*redis*",
            "credentials/*redis*"
          ]
        }
      },
      "artifacts_produced": [
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/scaffold_manifest.json",
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/allowlist.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "ground",
      "skill_name": "repo-ground",
      "status": "completed",
      "started_at": "2026-02-02T05:33:47.966222",
      "completed_at": "2026-02-02T05:33:48.068879",
      "duration_ms": 102,
      "outputs": {
        "repo_facts_path": "/home/toni/agent-skills/artifacts/convert-redis-final-001/repo_facts.json",
        "repo_facts": {
          "basenode_contract_path": "contracts/BASENODE_CONTRACT.md",
          "node_loader_paths": [
            "runtime/kb/loader.py"
          ],
          "golden_node_paths": [
            "nodepacks/core/nodes.py",
            "src/node_sdk/basenode.py"
          ],
          "test_command": "pytest tests/"
        },
        "target_repo_layout_path": "/home/toni/agent-skills/artifacts/convert-redis-final-001/target_repo_layout.json",
        "target_repo_layout": {
          "target_repo_root": "/home/toni/agent-skills",
          "node_output_base_dir": "nodes",
          "registry_file": "nodes/__init__.py",
          "registry_strategy": "dict_import",
          "registry_dict_name": "node_definitions",
          "base_class_file": "nodes/base.py",
          "base_class_name": "BaseNode",
          "tests_dir": "tests",
          "python_version": null,
          "venv_path": ".venv",
          "extra_allowlist_patterns": []
        }
      },
      "artifacts_produced": [
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/repo_facts.json",
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/target_repo_layout.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "convert",
      "skill_name": "code-convert",
      "status": "completed",
      "started_at": "2026-02-02T05:33:48.068941",
      "completed_at": "2026-02-02T05:33:48.102531",
      "duration_ms": 33,
      "outputs": {
        "files_modified": [
          "nodes/redis.py"
        ],
        "all_target_files": [
          "nodes/redis.py",
          "nodes/__init__.py"
        ],
        "artifact_paths": [
          "/home/toni/agent-skills/artifacts/convert-redis-final-001/converted/redis.py",
          "/home/toni/agent-skills/artifacts/convert-redis-final-001/converted/__init__.py"
        ],
        "conversion_notes": [
          "Selected Redis.node.ts as main node (name match)",
          "Found main node class for Redis",
          "Found 9 operation handlers",
          "Converted /info",
          "Converted /delete",
          "Converted /get",
          "Converted /keys",
          "Converted /set",
          "Converted /incr",
          "Converted /publish",
          "Converted /push",
          "Converted /pop",
          "Using 15 parameters from inferred schema",
          "Using 9 handlers from tcp_client backend",
          "Using tcp_client backend for conversion",
          "Using tcp_client backend for Redis",
          "Library: redis",
          "Credential type: redisApi",
          "Connection params: ['host', 'port', 'database', 'password', 'user', 'ssl']",
          "Added resource-based display_options to operation parameter",
          " Schema validation warnings: [\"Schema validation failed: 15 validation errors for BaseNodeSchema\\nproperties.parameters.0.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='OPTIONS', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.1.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.2.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.3.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='OPTIONS', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.4.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='COLLECTION', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.5.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='BOOLEAN', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.6.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='NUMBER', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.7.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.8.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='BOOLEAN', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.9.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.10.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='BOOLEAN', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.11.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.12.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.13.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.14.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='BOOLEAN', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\"]",
          " No stubs or placeholders detected"
        ],
        "generated_code": {
          "redis.py": "#!/usr/bin/env python3\n\"\"\"\nRedis Node\n\nConverted from TypeScript by agent-skills/code-convert\nCorrelation ID: convert-redis-final-001\nGenerated: 2026-02-02T05:33:48.091539\n\nSYNC-CELERY SAFE: All methods are synchronous with timeouts.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List\nfrom urllib.parse import quote\n\nimport requests\n\nfrom .base import BaseNode, NodeParameterType, NodeExecutionData\n\nlogger = logging.getLogger(__name__)\n\n\nclass RedisNode(BaseNode):\n    \"\"\"\n    Redis node.\n    \n    \n    \"\"\"\n\n    type = \"redis\"\n    version = 1\n    \n    description = {\n        \"displayName\": \"Redis\",\n        \"name\": \"redis\",\n        \"icon\": \"file:redis.svg\",\n        \"group\": ['output'],\n        \"description\": \"\",\n        \"inputs\": [{\"name\": \"main\", \"type\": \"main\", \"required\": True}],\n        \"outputs\": [{\"name\": \"main\", \"type\": \"main\", \"required\": True}],\n    }\n    \n    properties = {\n        \"parameters\": [\n            {\"name\": \"operation\", \"type\": NodeParameterType.OPTIONS, \"display_name\": \"Operation\", \"options\": [\n                {\"name\": \"Delete\", \"value\": \"delete\", \"description\": \"Delete a key from Redis\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Get\", \"value\": \"get\", \"description\": \"Get the value of a key from Redis\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Increment\", \"value\": \"incr\", \"description\": \"Atomically increments a key by 1. Creates the key if it does not exist.\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Info\", \"value\": \"info\", \"description\": \"Returns generic information about the Redis instance\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Keys\", \"value\": \"keys\", \"description\": \"Returns all the keys matching a pattern\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Pop\", \"value\": \"pop\", \"description\": \"Pop data from a redis list\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Publish\", \"value\": \"publish\", \"description\": \"Publish message to redis channel\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Push\", \"value\": \"push\", \"description\": \"Push data to a redis list\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Set\", \"value\": \"set\", \"description\": \"Set the value of a key in redis\", \"display_options\": {'show': {'resource': ['']}}}\n            ], \"default\": \"delete\", \"description\": \"Operation to perform\"},\n            {\"name\": \"key\", \"type\": NodeParameterType.STRING, \"display_name\": \"Key\", \"default\": \"\", \"required\": True, \"description\": \"Name of the key to delete from Redis\", \"display_options\": {'show': {'operation': ['delete']}}},\n            {\"name\": \"propertyName\", \"type\": NodeParameterType.STRING, \"display_name\": \"Name\", \"default\": \"propertyName\", \"required\": True, \"description\": \"Name of the property to write received data to. Supports dot-notation. Example: \", \"display_options\": {'show': {'operation': ['get']}}},\n            {\"name\": \"keyType\", \"type\": NodeParameterType.OPTIONS, \"display_name\": \"Key Type\", \"options\": [\n                {\"name\": \"Automatic\", \"value\": \"automatic\"},\n                {\"name\": \"Hash\", \"value\": \"hash\"},\n                {\"name\": \"List\", \"value\": \"list\"},\n                {\"name\": \"Sets\", \"value\": \"sets\"},\n                {\"name\": \"String\", \"value\": \"string\"}\n            ], \"default\": \"automatic\", \"description\": \"Requests the type before requesting the data (slower)\", \"display_options\": {'show': {'operation': ['get']}}},\n            {\"name\": \"options\", \"type\": NodeParameterType.COLLECTION, \"display_name\": \"Options\", \"default\": \"\", \"description\": \"<p>By default, dot-notation is used in property names. This means that \", \"display_options\": {'show': {'operation': ['get']}}},\n            {\"name\": \"expire\", \"type\": NodeParameterType.BOOLEAN, \"display_name\": \"Expire\", \"default\": False, \"description\": \"Whether to set a timeout on key\", \"display_options\": {'show': {'operation': ['incr']}}},\n            {\"name\": \"ttl\", \"type\": NodeParameterType.NUMBER, \"display_name\": \"TTL\", \"default\": 60, \"description\": \"Number of seconds before key expiration\", \"display_options\": {'show': {'operation': ['incr']}}},\n            {\"name\": \"keyPattern\", \"type\": NodeParameterType.STRING, \"display_name\": \"Key Pattern\", \"default\": \"\", \"required\": True, \"description\": \"The key pattern for the keys to return\", \"display_options\": {'show': {'operation': ['keys']}}},\n            {\"name\": \"getValues\", \"type\": NodeParameterType.BOOLEAN, \"display_name\": \"Get Values\", \"default\": True, \"description\": \"Whether to get the value of matching keys\", \"display_options\": {'show': {'operation': ['keys']}}},\n            {\"name\": \"value\", \"type\": NodeParameterType.STRING, \"display_name\": \"Value\", \"default\": \"\", \"description\": \"The value to write in Redis\", \"display_options\": {'show': {'operation': ['set']}}},\n            {\"name\": \"valueIsJSON\", \"type\": NodeParameterType.BOOLEAN, \"display_name\": \"Value Is JSON\", \"default\": True, \"description\": \"Whether the value is JSON or key value pairs\"},\n            {\"name\": \"channel\", \"type\": NodeParameterType.STRING, \"display_name\": \"Channel\", \"default\": \"\", \"required\": True, \"description\": \"Channel name\", \"display_options\": {'show': {'operation': ['publish']}}},\n            {\"name\": \"messageData\", \"type\": NodeParameterType.STRING, \"display_name\": \"Data\", \"default\": \"\", \"required\": True, \"description\": \"Data to publish\", \"display_options\": {'show': {'operation': ['publish']}}},\n            {\"name\": \"list\", \"type\": NodeParameterType.STRING, \"display_name\": \"List\", \"default\": \"\", \"required\": True, \"description\": \"Name of the list in Redis\", \"display_options\": {'show': {'operation': ['push', 'pop']}}},\n            {\"name\": \"tail\", \"type\": NodeParameterType.BOOLEAN, \"display_name\": \"Tail\", \"default\": False, \"description\": \"Whether to push or pop data from the end of the list\", \"display_options\": {'show': {'operation': ['push', 'pop']}}}\n        ],\n        \"credentials\": [\n            {\"name\": \"redis\", \"required\": True}\n        ]\n    }\n    \n    icon = \"redis.svg\"\n\n    def execute(self) -> List[List[NodeExecutionData]]:\n        \"\"\"\n        Execute the node operations.\n        \n        SYNC-CELERY SAFE: All HTTP calls use timeout parameter.\n        \n        Returns:\n            List[List[NodeExecutionData]]: Nested list where outer list is output branches,\n            inner list is items in that branch.\n        \"\"\"\n        # Get input data from previous node\n        input_data = self.get_input_data()\n        \n        # FIX #40: Handle empty input - create default item so nodes work from Start\n        if not input_data:\n            input_data = [NodeExecutionData(json_data={})]\n        \n        return_items: List[NodeExecutionData] = []\n\n        for i, item in enumerate(input_data):\n            try:\n                operation = self.get_node_parameter(\"operation\", i)\n                item_data = item.json_data if hasattr(item, 'json_data') else item.get('json', {})\n                \n                if operation == \"delete\":\n                    result = self._delete(i, item_data)\n                elif operation == \"get\":\n                    result = self._get(i, item_data)\n                elif operation == \"incr\":\n                    result = self._incr(i, item_data)\n                elif operation == \"info\":\n                    result = self._info(i, item_data)\n                elif operation == \"keys\":\n                    result = self._keys(i, item_data)\n                elif operation == \"pop\":\n                    result = self._pop(i, item_data)\n                elif operation == \"publish\":\n                    result = self._publish(i, item_data)\n                elif operation == \"push\":\n                    result = self._push(i, item_data)\n                elif operation == \"set\":\n                    result = self._set(i, item_data)\n                else:\n                    raise ValueError(f\"Unknown operation: {operation}\")\n                \n                # Handle array results\n                if isinstance(result, list):\n                    for r in result:\n                        return_items.append(NodeExecutionData(json_data=r))\n                else:\n                    return_items.append(NodeExecutionData(json_data=result))\n                    \n            except Exception as e:\n                logger.error(f\"Error in operation {operation}: {e}\")\n                # Platform doesn't support continue_on_fail - always raise\n                raise\n        \n        return [return_items]\n\n    def _get_redis_client(self) -> \"redis.Redis\":\n        \"\"\"\n        Create and return a Redis client using configured credentials.\n        \n        SYNC-CELERY SAFE: Synchronous connection with timeout.\n        \n        Returns:\n            redis.Redis: Configured Redis client instance\n        \"\"\"\n        credentials = self.get_credentials(\"redisApi\")\n        \n        if not credentials:\n            raise Exception(\"Redis credentials not configured\")\n        \n        host = credentials.get(\"host\", \"localhost\")\n        port = int(credentials.get(\"port\", 6379))\n        database = int(credentials.get(\"database\", 0))\n        user = credentials.get(\"user\", \"\") or None\n        password = credentials.get(\"password\", \"\") or None\n        ssl = credentials.get(\"ssl\", False)\n        connection_timeout = int(credentials.get(\"connectionTimeout\", 10))\n        socket_timeout = int(credentials.get(\"socketTimeout\", 30))\n        \n        client = redis.Redis(\n            host=host,\n            port=port,\n            db=database,\n            username=user if user else None,\n            password=password if password else None,\n            ssl=ssl,\n            socket_timeout=socket_timeout,\n            socket_connect_timeout=connection_timeout,\n            decode_responses=True,\n        )\n        \n        return client\n    \n    def _execute_redis_operation(\n        self,\n        operation: str,\n        **kwargs,\n    ) -> Any:\n        \"\"\"\n        Execute a Redis operation with proper connection handling.\n        \n        SYNC-CELERY SAFE: All operations are synchronous.\n        \"\"\"\n        client = self._get_redis_client()\n        \n        try:\n            # Get the operation method\n            op_method = getattr(client, operation, None)\n            if not op_method:\n                raise ValueError(f\"Unknown Redis operation: {operation}\")\n            \n            return op_method(**kwargs)\n        finally:\n            # Redis client doesn't need explicit close for single operations\n            pass\n\n\n    def _delete(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        delete operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Delete operation\n        key = self.get_node_parameter(\"key\", item_index, \"\")\n        if not key:\n            raise ValueError(\"Key is required for delete operation\")\n        \n        client = self._get_redis_client()\n        result = client.delete(key)\n        \n        return {\n            \"json\": {\"key\": key, \"deleted\": result > 0, \"count\": result},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _get(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        get operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Get operation\n        key = self.get_node_parameter(\"key\", item_index, \"\")\n        key_type = self.get_node_parameter(\"keyType\", item_index, \"automatic\")\n        property_name = self.get_node_parameter(\"propertyName\", item_index, \"propertyName\")\n        \n        if not key:\n            raise ValueError(\"Key is required for get operation\")\n        \n        client = self._get_redis_client()\n        \n        # Detect key type if automatic\n        if key_type == \"automatic\":\n            key_type = client.type(key)\n        \n        # Get value based on type\n        if key_type == \"string\":\n            value = client.get(key)\n        elif key_type == \"hash\":\n            value = client.hgetall(key)\n        elif key_type == \"list\":\n            value = client.lrange(key, 0, -1)\n        elif key_type == \"set\":\n            value = list(client.smembers(key))\n        elif key_type == \"zset\":\n            value = client.zrange(key, 0, -1, withscores=True)\n        else:\n            value = client.get(key)\n        \n        return {\n            \"json\": {property_name: value},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _incr(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        incr operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Increment operation\n        key = self.get_node_parameter(\"key\", item_index, \"\")\n        value = self.get_node_parameter(\"value\", item_index, 1)\n        \n        if not key:\n            raise ValueError(\"Key is required for incr operation\")\n        \n        client = self._get_redis_client()\n        \n        if value == 1:\n            result = client.incr(key)\n        else:\n            result = client.incrby(key, int(value))\n        \n        return {\n            \"json\": {\"key\": key, \"value\": result},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _info(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        info operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Info operation\n        client = self._get_redis_client()\n        info = client.info()\n        \n        return {\n            \"json\": info,\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _keys(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        keys operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Keys operation\n        pattern = self.get_node_parameter(\"keyPattern\", item_index, \"*\")\n        \n        client = self._get_redis_client()\n        keys = client.keys(pattern)\n        \n        return {\n            \"json\": {\"keys\": keys, \"count\": len(keys)},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _pop(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        pop operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Pop operation\n        list_name = self.get_node_parameter(\"list\", item_index, \"\")\n        tail = self.get_node_parameter(\"tail\", item_index, False)\n        property_name = self.get_node_parameter(\"propertyName\", item_index, \"propertyName\")\n        \n        if not list_name:\n            raise ValueError(\"List name is required for pop operation\")\n        \n        client = self._get_redis_client()\n        \n        if tail:\n            value = client.rpop(list_name)\n        else:\n            value = client.lpop(list_name)\n        \n        return {\n            \"json\": {property_name: value},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _publish(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        publish operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Publish operation\n        channel = self.get_node_parameter(\"channel\", item_index, \"\")\n        message = self.get_node_parameter(\"messageData\", item_index, \"\")\n        \n        if not channel:\n            raise ValueError(\"Channel is required for publish operation\")\n        \n        client = self._get_redis_client()\n        result = client.publish(channel, message)\n        \n        return {\n            \"json\": {\"channel\": channel, \"subscribers\": result},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _push(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        push operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Push operation\n        list_name = self.get_node_parameter(\"list\", item_index, \"\")\n        values = self.get_node_parameter(\"messageData\", item_index, \"\")\n        tail = self.get_node_parameter(\"tail\", item_index, False)\n        \n        if not list_name:\n            raise ValueError(\"List name is required for push operation\")\n        \n        client = self._get_redis_client()\n        \n        if tail:\n            result = client.rpush(list_name, values)\n        else:\n            result = client.lpush(list_name, values)\n        \n        return {\n            \"json\": {\"list\": list_name, \"length\": result},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _set(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        set operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Set operation\n        key = self.get_node_parameter(\"key\", item_index, \"\")\n        value = self.get_node_parameter(\"value\", item_index, \"\")\n        key_type = self.get_node_parameter(\"keyType\", item_index, \"string\")\n        expire = self.get_node_parameter(\"expire\", item_index, False)\n        ttl = self.get_node_parameter(\"ttl\", item_index, None)\n        \n        if not key:\n            raise ValueError(\"Key is required for set operation\")\n        \n        client = self._get_redis_client()\n        \n        if key_type == \"string\":\n            if expire and ttl:\n                client.setex(key, int(ttl), value)\n            else:\n                client.set(key, value)\n        elif key_type == \"hash\":\n            if isinstance(value, dict):\n                client.hset(key, mapping=value)\n            else:\n                # Try to parse as JSON\n                import json\n                try:\n                    value = json.loads(value)\n                    client.hset(key, mapping=value)\n                except json.JSONDecodeError:\n                    client.set(key, value)\n        elif key_type == \"list\":\n            if isinstance(value, list):\n                client.rpush(key, *value)\n            else:\n                client.rpush(key, value)\n        elif key_type == \"set\":\n            if isinstance(value, (list, set)):\n                client.sadd(key, *value)\n            else:\n                client.sadd(key, value)\n        else:\n            client.set(key, value)\n        \n        return {\n            \"json\": {\"key\": key, \"success\": True},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n",
          "__init__.py": "\"\"\"\nRedis Node Package\nConverted from TypeScript by agent-skills/code-convert\n\"\"\"\n\nfrom .redis import RedisNode\n\n__all__ = [\"RedisNode\"]\n"
        }
      },
      "artifacts_produced": [
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/conversion_log.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "generate-tests",
      "skill_name": "test-generate",
      "status": "completed",
      "started_at": "2026-02-02T05:33:48.102561",
      "completed_at": "2026-02-02T05:33:48.118009",
      "duration_ms": 15,
      "outputs": {
        "stub": true,
        "message": "Skill test-generate has no implementation registered"
      },
      "artifacts_produced": [],
      "errors": [
        "Missing required output: test_files_created",
        "Missing required output: test_count"
      ],
      "skipped_reason": null
    },
    {
      "step_name": "validate",
      "skill_name": "code-validate",
      "status": "failed",
      "started_at": "2026-02-02T05:33:48.118038",
      "completed_at": "2026-02-02T05:33:48.123660",
      "duration_ms": 5,
      "outputs": {},
      "artifacts_produced": [],
      "errors": [
        "Missing required input: test_files",
        "Input validation failed"
      ],
      "skipped_reason": null
    }
  ],
  "outputs": {
    "ingest": {
      "raw_content": "// === File: Redis.credentials.ts ===\nimport type { ICredentialType, INodeProperties } from 'n8n-workflow';\n\nexport class Redis implements ICredentialType {\n\tname = 'redis';\n\n\tdisplayName = 'Redis';\n\n\tdocumentationUrl = 'redis';\n\n\tproperties: INodeProperties[] = [\n\t\t{\n\t\t\tdisplayName: 'Password',\n\t\t\tname: 'password',\n\t\t\ttype: 'string',\n\t\t\ttypeOptions: {\n\t\t\t\tpassword: true,\n\t\t\t},\n\t\t\tdefault: '',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'User',\n\t\t\tname: 'user',\n\t\t\ttype: 'string',\n\t\t\tdefault: '',\n\t\t\thint: 'Leave blank for password-only auth',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Host',\n\t\t\tname: 'host',\n\t\t\ttype: 'string',\n\t\t\tdefault: 'localhost',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Port',\n\t\t\tname: 'port',\n\t\t\ttype: 'number',\n\t\t\tdefault: 6379,\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Database Number',\n\t\t\tname: 'database',\n\t\t\ttype: 'number',\n\t\t\tdefault: 0,\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'SSL',\n\t\t\tname: 'ssl',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t},\n\t];\n}\n\n\n// === File: Redis.node.ts ===\nimport set from 'lodash/set';\nimport type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\nimport { NodeConnectionTypes, NodeOperationError } from 'n8n-workflow';\n\nimport type { RedisCredential } from './types';\nimport {\n\tsetupRedisClient,\n\tredisConnectionTest,\n\tconvertInfoToObject,\n\tgetValue,\n\tsetValue,\n} from './utils';\n\nexport class Redis implements INodeType {\n\tdescription: INodeTypeDescription = {\n\t\tdisplayName: 'Redis',\n\t\tname: 'redis',\n\t\ticon: 'file:redis.svg',\n\t\tgroup: ['input'],\n\t\tversion: 1,\n\t\tdescription: 'Get, send and update data in Redis',\n\t\tdefaults: {\n\t\t\tname: 'Redis',\n\t\t},\n\t\tinputs: [NodeConnectionTypes.Main],\n\t\toutputs: [NodeConnectionTypes.Main],\n\t\tusableAsTool: true,\n\t\tcredentials: [\n\t\t\t{\n\t\t\t\tname: 'redis',\n\t\t\t\trequired: true,\n\t\t\t\ttestedBy: 'redisConnectionTest',\n\t\t\t},\n\t\t],\n\t\tproperties: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Operation',\n\t\t\t\tname: 'operation',\n\t\t\t\ttype: 'options',\n\t\t\t\tnoDataExpression: true,\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Delete',\n\t\t\t\t\t\tvalue: 'delete',\n\t\t\t\t\t\tdescription: 'Delete a key from Redis',\n\t\t\t\t\t\taction: 'Delete a key from Redis',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Get',\n\t\t\t\t\t\tvalue: 'get',\n\t\t\t\t\t\tdescription: 'Get the value of a key from Redis',\n\t\t\t\t\t\taction: 'Get the value of a key from Redis',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Increment',\n\t\t\t\t\t\tvalue: 'incr',\n\t\t\t\t\t\tdescription: 'Atomically increments a key by 1. Creates the key if it does not exist.',\n\t\t\t\t\t\taction: 'Atomically increment a key by 1. Creates the key if it does not exist.',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Info',\n\t\t\t\t\t\tvalue: 'info',\n\t\t\t\t\t\tdescription: 'Returns generic information about the Redis instance',\n\t\t\t\t\t\taction: 'Return generic information about the Redis instance',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Keys',\n\t\t\t\t\t\tvalue: 'keys',\n\t\t\t\t\t\tdescription: 'Returns all the keys matching a pattern',\n\t\t\t\t\t\taction: 'Return all keys matching a pattern',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Pop',\n\t\t\t\t\t\tvalue: 'pop',\n\t\t\t\t\t\tdescription: 'Pop data from a redis list',\n\t\t\t\t\t\taction: 'Pop data from a redis list',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Publish',\n\t\t\t\t\t\tvalue: 'publish',\n\t\t\t\t\t\tdescription: 'Publish message to redis channel',\n\t\t\t\t\t\taction: 'Publish message to redis channel',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Push',\n\t\t\t\t\t\tvalue: 'push',\n\t\t\t\t\t\tdescription: 'Push data to a redis list',\n\t\t\t\t\t\taction: 'Push data to a redis list',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Set',\n\t\t\t\t\t\tvalue: 'set',\n\t\t\t\t\t\tdescription: 'Set the value of a key in redis',\n\t\t\t\t\t\taction: 'Set the value of a key in redis',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'info',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         delete\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['delete'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to delete from Redis',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         get\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Name',\n\t\t\t\tname: 'propertyName',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 'propertyName',\n\t\t\t\trequired: true,\n\t\t\t\tdescription:\n\t\t\t\t\t'Name of the property to write received data to. Supports dot-notation. Example: \"data.person[0].name\".',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to get from Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Type',\n\t\t\t\tname: 'keyType',\n\t\t\t\ttype: 'options',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Automatic',\n\t\t\t\t\t\tvalue: 'automatic',\n\t\t\t\t\t\tdescription: 'Requests the type before requesting the data (slower)',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Hash',\n\t\t\t\t\t\tvalue: 'hash',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'hash'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'List',\n\t\t\t\t\t\tvalue: 'list',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'lists'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Sets',\n\t\t\t\t\t\tvalue: 'sets',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'sets'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'String',\n\t\t\t\t\t\tvalue: 'string',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'string'\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'automatic',\n\t\t\t\tdescription: 'The type of the key to get',\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'Options',\n\t\t\t\tname: 'options',\n\t\t\t\ttype: 'collection',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tplaceholder: 'Add option',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Dot Notation',\n\t\t\t\t\t\tname: 'dotNotation',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-boolean-without-whether\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'<p>By default, dot-notation is used in property names. This means that \"a.b\" will set the property \"b\" underneath \"a\" so { \"a\": { \"b\": value} }.<p></p>If that is not intended this can be deactivated, it will then set { \"a.b\": value } instead.</p>.',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         incr\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to increment',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Expire',\n\t\t\t\tname: 'expire',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to set a timeout on key',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'TTL',\n\t\t\t\tname: 'ttl',\n\t\t\t\ttype: 'number',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 1,\n\t\t\t\t},\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t\texpire: [true],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 60,\n\t\t\t\tdescription: 'Number of seconds before key expiration',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         keys\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Pattern',\n\t\t\t\tname: 'keyPattern',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['keys'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'The key pattern for the keys to return',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Get Values',\n\t\t\t\tname: 'getValues',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['keys'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: true,\n\t\t\t\tdescription: 'Whether to get the value of matching keys',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         set\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to set in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Value',\n\t\t\t\tname: 'value',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'The value to write in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Type',\n\t\t\t\tname: 'keyType',\n\t\t\t\ttype: 'options',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Automatic',\n\t\t\t\t\t\tvalue: 'automatic',\n\t\t\t\t\t\tdescription: 'Tries to figure out the type automatically depending on the data',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Hash',\n\t\t\t\t\t\tvalue: 'hash',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'hash'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'List',\n\t\t\t\t\t\tvalue: 'list',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'lists'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Sets',\n\t\t\t\t\t\tvalue: 'sets',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'sets'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'String',\n\t\t\t\t\t\tvalue: 'string',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'string'\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'automatic',\n\t\t\t\tdescription: 'The type of the key to set',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Value Is JSON',\n\t\t\t\tname: 'valueIsJSON',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\tkeyType: ['hash'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: true,\n\t\t\t\tdescription: 'Whether the value is JSON or key value pairs',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Expire',\n\t\t\t\tname: 'expire',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to set a timeout on key',\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'TTL',\n\t\t\t\tname: 'ttl',\n\t\t\t\ttype: 'number',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 1,\n\t\t\t\t},\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t\texpire: [true],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 60,\n\t\t\t\tdescription: 'Number of seconds before key expiration',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         publish\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Channel',\n\t\t\t\tname: 'channel',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['publish'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t",
      "parsed_sections": {
        "class_name": "Redis",
        "node_type": "password",
        "version": 1.0,
        "description": "{\n\t\tdisplayName: 'Redis',\n\t\tname: 'redis',\n\t\ticon: 'file:redis.svg',\n\t\tgroup: ['input'],\n\t\tversion: 1,\n\t\tdescription: 'Get, send and update data in Redis',\n\t\tdefaults: {\n\t\t\tname: 'Redis',\n\t\t},\n\t\tinputs: [NodeConnectionTypes.Main],\n\t\toutputs: [NodeConnectionTypes.Main],\n\t\tusableAsTool: true,\n\t\tcredentials: [\n\t\t\t{\n\t\t\t\tname: 'redis',\n\t\t\t\trequired: true,\n\t\t\t\ttestedBy: 'redisConnectionTest',\n\t\t\t},\n\t\t],\n\t\tproperties: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Operation',\n\t\t\t\tname: 'operation',\n\t\t\t\ttype: 'options',\n\t\t\t\t...",
        "properties": [],
        "methods": [
          "execute"
        ],
        "credentials": [
          "redisConnectionTest"
        ],
        "resources": [],
        "files": [
          "Redis.credentials.ts",
          "Redis.node.ts",
          "types.ts",
          "utils.ts"
        ],
        "code": [
          {
            "file": "Redis.credentials.ts",
            "content": "import type { ICredentialType, INodeProperties } from 'n8n-workflow';\n\nexport class Redis implements ICredentialType {\n\tname = 'redis';\n\n\tdisplayName = 'Redis';\n\n\tdocumentationUrl = 'redis';\n\n\tproperties: INodeProperties[] = [\n\t\t{\n\t\t\tdisplayName: 'Password',\n\t\t\tname: 'password',\n\t\t\ttype: 'string',\n\t\t\ttypeOptions: {\n\t\t\t\tpassword: true,\n\t\t\t},\n\t\t\tdefault: '',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'User',\n\t\t\tname: 'user',\n\t\t\ttype: 'string',\n\t\t\tdefault: '',\n\t\t\thint: 'Leave blank for password-only auth',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Host',\n\t\t\tname: 'host',\n\t\t\ttype: 'string',\n\t\t\tdefault: 'localhost',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Port',\n\t\t\tname: 'port',\n\t\t\ttype: 'number',\n\t\t\tdefault: 6379,\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Database Number',\n\t\t\tname: 'database',\n\t\t\ttype: 'number',\n\t\t\tdefault: 0,\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'SSL',\n\t\t\tname: 'ssl',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t},\n\t];\n}\n"
          },
          {
            "file": "Redis.node.ts",
            "content": "import set from 'lodash/set';\nimport type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\nimport { NodeConnectionTypes, NodeOperationError } from 'n8n-workflow';\n\nimport type { RedisCredential } from './types';\nimport {\n\tsetupRedisClient,\n\tredisConnectionTest,\n\tconvertInfoToObject,\n\tgetValue,\n\tsetValue,\n} from './utils';\n\nexport class Redis implements INodeType {\n\tdescription: INodeTypeDescription = {\n\t\tdisplayName: 'Redis',\n\t\tname: 'redis',\n\t\ticon: 'file:redis.svg',\n\t\tgroup: ['input'],\n\t\tversion: 1,\n\t\tdescription: 'Get, send and update data in Redis',\n\t\tdefaults: {\n\t\t\tname: 'Redis',\n\t\t},\n\t\tinputs: [NodeConnectionTypes.Main],\n\t\toutputs: [NodeConnectionTypes.Main],\n\t\tusableAsTool: true,\n\t\tcredentials: [\n\t\t\t{\n\t\t\t\tname: 'redis',\n\t\t\t\trequired: true,\n\t\t\t\ttestedBy: 'redisConnectionTest',\n\t\t\t},\n\t\t],\n\t\tproperties: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Operation',\n\t\t\t\tname: 'operation',\n\t\t\t\ttype: 'options',\n\t\t\t\tnoDataExpression: true,\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Delete',\n\t\t\t\t\t\tvalue: 'delete',\n\t\t\t\t\t\tdescription: 'Delete a key from Redis',\n\t\t\t\t\t\taction: 'Delete a key from Redis',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Get',\n\t\t\t\t\t\tvalue: 'get',\n\t\t\t\t\t\tdescription: 'Get the value of a key from Redis',\n\t\t\t\t\t\taction: 'Get the value of a key from Redis',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Increment',\n\t\t\t\t\t\tvalue: 'incr',\n\t\t\t\t\t\tdescription: 'Atomically increments a key by 1. Creates the key if it does not exist.',\n\t\t\t\t\t\taction: 'Atomically increment a key by 1. Creates the key if it does not exist.',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Info',\n\t\t\t\t\t\tvalue: 'info',\n\t\t\t\t\t\tdescription: 'Returns generic information about the Redis instance',\n\t\t\t\t\t\taction: 'Return generic information about the Redis instance',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Keys',\n\t\t\t\t\t\tvalue: 'keys',\n\t\t\t\t\t\tdescription: 'Returns all the keys matching a pattern',\n\t\t\t\t\t\taction: 'Return all keys matching a pattern',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Pop',\n\t\t\t\t\t\tvalue: 'pop',\n\t\t\t\t\t\tdescription: 'Pop data from a redis list',\n\t\t\t\t\t\taction: 'Pop data from a redis list',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Publish',\n\t\t\t\t\t\tvalue: 'publish',\n\t\t\t\t\t\tdescription: 'Publish message to redis channel',\n\t\t\t\t\t\taction: 'Publish message to redis channel',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Push',\n\t\t\t\t\t\tvalue: 'push',\n\t\t\t\t\t\tdescription: 'Push data to a redis list',\n\t\t\t\t\t\taction: 'Push data to a redis list',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Set',\n\t\t\t\t\t\tvalue: 'set',\n\t\t\t\t\t\tdescription: 'Set the value of a key in redis',\n\t\t\t\t\t\taction: 'Set the value of a key in redis',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'info',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         delete\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['delete'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to delete from Redis',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         get\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Name',\n\t\t\t\tname: 'propertyName',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 'propertyName',\n\t\t\t\trequired: true,\n\t\t\t\tdescription:\n\t\t\t\t\t'Name of the property to write received data to. Supports dot-notation. Example: \"data.person[0].name\".',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to get from Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Type',\n\t\t\t\tname: 'keyType',\n\t\t\t\ttype: 'options',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Automatic',\n\t\t\t\t\t\tvalue: 'automatic',\n\t\t\t\t\t\tdescription: 'Requests the type before requesting the data (slower)',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Hash',\n\t\t\t\t\t\tvalue: 'hash',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'hash'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'List',\n\t\t\t\t\t\tvalue: 'list',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'lists'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Sets',\n\t\t\t\t\t\tvalue: 'sets',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'sets'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'String',\n\t\t\t\t\t\tvalue: 'string',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'string'\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'automatic',\n\t\t\t\tdescription: 'The type of the key to get',\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'Options',\n\t\t\t\tname: 'options',\n\t\t\t\ttype: 'collection',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['get'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tplaceholder: 'Add option',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Dot Notation',\n\t\t\t\t\t\tname: 'dotNotation',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-boolean-without-whether\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'<p>By default, dot-notation is used in property names. This means that \"a.b\" will set the property \"b\" underneath \"a\" so { \"a\": { \"b\": value} }.<p></p>If that is not intended this can be deactivated, it will then set { \"a.b\": value } instead.</p>.',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         incr\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to increment',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Expire',\n\t\t\t\tname: 'expire',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to set a timeout on key',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'TTL',\n\t\t\t\tname: 'ttl',\n\t\t\t\ttype: 'number',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 1,\n\t\t\t\t},\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['incr'],\n\t\t\t\t\t\texpire: [true],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 60,\n\t\t\t\tdescription: 'Number of seconds before key expiration',\n\t\t\t},\n\n\t\t\t// ----------------------------------\n\t\t\t//         keys\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Pattern',\n\t\t\t\tname: 'keyPattern',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['keys'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'The key pattern for the keys to return',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Get Values',\n\t\t\t\tname: 'getValues',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['keys'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: true,\n\t\t\t\tdescription: 'Whether to get the value of matching keys',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         set\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Key',\n\t\t\t\tname: 'key',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the key to set in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Value',\n\t\t\t\tname: 'value',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'The value to write in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Key Type',\n\t\t\t\tname: 'keyType',\n\t\t\t\ttype: 'options',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Automatic',\n\t\t\t\t\t\tvalue: 'automatic',\n\t\t\t\t\t\tdescription: 'Tries to figure out the type automatically depending on the data',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Hash',\n\t\t\t\t\t\tvalue: 'hash',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'hash'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'List',\n\t\t\t\t\t\tvalue: 'list',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'lists'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Sets',\n\t\t\t\t\t\tvalue: 'sets',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'sets'\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'String',\n\t\t\t\t\t\tvalue: 'string',\n\t\t\t\t\t\tdescription: \"Data in key is of type 'string'\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'automatic',\n\t\t\t\tdescription: 'The type of the key to set',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Value Is JSON',\n\t\t\t\tname: 'valueIsJSON',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\tkeyType: ['hash'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: true,\n\t\t\t\tdescription: 'Whether the value is JSON or key value pairs',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Expire',\n\t\t\t\tname: 'expire',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to set a timeout on key',\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'TTL',\n\t\t\t\tname: 'ttl',\n\t\t\t\ttype: 'number',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 1,\n\t\t\t\t},\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['set'],\n\t\t\t\t\t\texpire: [true],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 60,\n\t\t\t\tdescription: 'Number of seconds before key expiration',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         publish\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'Channel',\n\t\t\t\tname: 'channel',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['publish'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Channel name',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Data',\n\t\t\t\tname: 'messageData',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['publish'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Data to publish',\n\t\t\t},\n\t\t\t// ----------------------------------\n\t\t\t//         push/pop\n\t\t\t// ----------------------------------\n\t\t\t{\n\t\t\t\tdisplayName: 'List',\n\t\t\t\tname: 'list',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['push', 'pop'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Name of the list in Redis',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Data',\n\t\t\t\tname: 'messageData',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['push'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tdescription: 'Data to push',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Tail',\n\t\t\t\tname: 'tail',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['push', 'pop'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to push or pop data from the end of the list',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Name',\n\t\t\t\tname: 'propertyName',\n\t\t\t\ttype: 'string',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['pop'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdefault: 'propertyName',\n\t\t\t\tdescription:\n\t\t\t\t\t'Optional name of the property to write received data to. Supports dot-notation. Example: \"data.person[0].name\".',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Options',\n\t\t\t\tname: 'options',\n\t\t\t\ttype: 'collection',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\toperation: ['pop'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tplaceholder: 'Add option',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Dot Notation',\n\t\t\t\t\t\tname: 'dotNotation',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-boolean-without-whether\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'<p>By default, dot-notation is used in property names. This means that \"a.b\" will set the property \"b\" underneath \"a\" so { \"a\": { \"b\": value} }.<p></p>If that is not intended this can be deactivated, it will then set { \"a.b\": value } instead.</p>.',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t};\n\n\tmethods = {\n\t\tcredentialTest: { redisConnectionTest },\n\t};\n\n\tasync execute(this: IExecuteFunctions) {\n\t\t// TODO: For array and object fields it should not have a \"value\" field it should\n\t\t//       have a parameter field for a path. Because it is not possible to set\n\t\t//       array, object via parameter directly (should maybe be possible?!?!)\n\t\t//       Should maybe have a parameter which is JSON.\n\t\tconst credentials = await this.getCredentials<RedisCredential>('redis');\n\n\t\tconst client = setupRedisClient(credentials);\n\t\tawait client.connect();\n\t\tawait client.ping();\n\n\t\tconst operation = this.getNodeParameter('operation', 0);\n\t\tconst returnItems: INodeExecutionData[] = [];\n\n\t\tif (operation === 'info') {\n\t\t\ttry {\n\t\t\t\tconst result = await client.info();\n\t\t\t\treturnItems.push({ json: convertInfoToObject(result) });\n\t\t\t} catch (error) {\n\t\t\t\tif (this.continueOnFail()) {\n\t\t\t\t\treturnItems.push({\n\t\t\t\t\t\tjson: {\n\t\t\t\t\t\t\terror: error.message,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait client.quit();\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), error);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (\n\t\t\t['delete', 'get', 'keys', 'set', 'incr', 'publish', 'push', 'pop'].includes(operation)\n\t\t) {\n\t\t\tconst items = this.getInputData();\n\n\t\t\tlet item: INodeExecutionData;\n\t\t\tfor (let itemIndex = 0; itemIndex < items.length; itemIndex++) {\n\t\t\t\ttry {\n\t\t\t\t\titem = { json: {}, pairedItem: { item: itemIndex } };\n\n\t\t\t\t\tif (operation === 'delete') {\n\t\t\t\t\t\tconst keyDelete = this.getNodeParameter('key', itemIndex) as string;\n\n\t\t\t\t\t\tawait client.del(keyDelete);\n\t\t\t\t\t\treturnItems.push(items[itemIndex]);\n\t\t\t\t\t} else if (operation === 'get') {\n\t\t\t\t\t\tconst propertyName = this.getNodeParameter('propertyName', itemIndex) as string;\n\t\t\t\t\t\tconst keyGet = this.getNodeParameter('key', itemIndex) as string;\n\t\t\t\t\t\tconst keyType = this.getNodeParameter('keyType', itemIndex) as string;\n\n\t\t\t\t\t\tconst value = (await getValue(client, keyGet, keyType)) ?? null;\n\n\t\t\t\t\t\tconst options = this.getNodeParameter('options', itemIndex, {});\n\n\t\t\t\t\t\tif (options.dotNotation === false) {\n\t\t\t\t\t\t\titem.json[propertyName] = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tset(item.json, propertyName, value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturnItems.push(item);\n\t\t\t\t\t} else if (operation === 'keys') {\n\t\t\t\t\t\tconst keyPattern = this.getNodeParameter('keyPattern', itemIndex) as string;\n\t\t\t\t\t\tconst getValues = this.getNodeParameter('getValues', itemIndex, true) as boolean;\n\n\t\t\t\t\t\tconst keys = await client.keys(keyPattern);\n\n\t\t\t\t\t\tif (!getValues) {\n\t\t\t\t\t\t\treturnItems.push({ json: { keys } });\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const keyName of keys) {\n\t\t\t\t\t\t\titem.json[keyName] = await getValue(client, keyName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturnItems.push(item);\n\t\t\t\t\t} else if (operation === 'set') {\n\t\t\t\t\t\tconst keySet = this.getNodeParameter('key', itemIndex) as string;\n\t\t\t\t\t\tconst value = this.getNodeParameter('value', itemIndex) as string;\n\t\t\t\t\t\tconst keyType = this.getNodeParameter('keyType', itemIndex) as string;\n\t\t\t\t\t\tconst valueIsJSON = this.getNodeParameter('valueIsJSON', itemIndex, true) as boolean;\n\t\t\t\t\t\tconst expire = this.getNodeParameter('expire', itemIndex, false) as boolean;\n\t\t\t\t\t\tconst ttl = this.getNodeParameter('ttl', itemIndex, -1) as number;\n\n\t\t\t\t\t\tawait setValue.call(this, client, keySet, value, expire, ttl, keyType, valueIsJSON);\n\t\t\t\t\t\treturnItems.push(items[itemIndex]);\n\t\t\t\t\t} else if (operation === 'incr') {\n\t\t\t\t\t\tconst keyIncr = this.getNodeParameter('key', itemIndex) as string;\n\t\t\t\t\t\tconst expire = this.getNodeParameter('expire', itemIndex, false) as boolean;\n\t\t\t\t\t\tconst ttl = this.getNodeParameter('ttl', itemIndex, -1) as number;\n\t\t\t\t\t\tconst incrementVal = await client.incr(keyIncr);\n\t\t\t\t\t\tif (expire && ttl > 0) {\n\t\t\t\t\t\t\tawait client.expire(keyIncr, ttl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturnItems.push({ json: { [keyIncr]: incrementVal } });\n\t\t\t\t\t} else if (operation === 'publish') {\n\t\t\t\t\t\tconst channel = this.getNodeParameter('channel', itemIndex) as string;\n\t\t\t\t\t\tconst messageData = this.getNodeParameter('messageData', itemIndex) as string;\n\t\t\t\t\t\tawait client.publish(channel, messageData);\n\t\t\t\t\t\treturnItems.push(items[itemIndex]);\n\t\t\t\t\t} else if (operation === 'push') {\n\t\t\t\t\t\tconst redisList = this.getNodeParameter('list', itemIndex) as string;\n\t\t\t\t\t\tconst messageData = this.getNodeParameter('messageData', itemIndex) as string;\n\t\t\t\t\t\tconst tail = this.getNodeParameter('tail', itemIndex, false) as boolean;\n\t\t\t\t\t\tawait client[tail ? 'rPush' : 'lPush'](redisList, messageData);\n\t\t\t\t\t\treturnItems.push(items[itemIndex]);\n\t\t\t\t\t} else if (operation === 'pop') {\n\t\t\t\t\t\tconst redisList = this.getNodeParameter('list', itemIndex) as string;\n\t\t\t\t\t\tconst tail = this.getNodeParameter('tail', itemIndex, false) as boolean;\n\t\t\t\t\t\tconst propertyName = this.getNodeParameter(\n\t\t\t\t\t\t\t'propertyName',\n\t\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\t\t'propertyName',\n\t\t\t\t\t\t) as string;\n\n\t\t\t\t\t\tconst value = await client[tail ? 'rPop' : 'lPop'](redisList);\n\n\t\t\t\t\t\tlet outputValue;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\toutputValue = value && JSON.parse(value);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\toutputValue = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst options = this.getNodeParameter('options', itemIndex, {});\n\t\t\t\t\t\tif (options.dotNotation === false) {\n\t\t\t\t\t\t\titem.json[propertyName] = outputValue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tset(item.json, propertyName, outputValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturnItems.push(item);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (this.continueOnFail()) {\n\t\t\t\t\t\treturnItems.push({\n\t\t\t\t\t\t\tjson: {\n\t\t\t\t\t\t\t\terror: error.message,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpairedItem: {\n\t\t\t\t\t\t\t\titem: itemIndex,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tawait client.quit();\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), error, { itemIndex });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tawait client.quit();\n\t\treturn [returnItems];\n\t}\n}\n"
          },
          {
            "file": "types.ts",
            "content": "import type { createClient } from 'redis';\n\nexport type RedisClient = ReturnType<typeof createClient>;\n\nexport type RedisCredential = {\n\thost: string;\n\tport: number;\n\tssl?: boolean;\n\tdatabase: number;\n\tuser?: string;\n\tpassword?: string;\n};\n"
          },
          {
            "file": "utils.ts",
            "content": "import type {\n\tICredentialTestFunctions,\n\tICredentialsDecrypted,\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeCredentialTestResult,\n} from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\nimport { createClient } from 'redis';\n\nimport type { RedisCredential, RedisClient } from './types';\n\nexport function setupRedisClient(credentials: RedisCredential): RedisClient {\n\treturn createClient({\n\t\tsocket: {\n\t\t\thost: credentials.host,\n\t\t\tport: credentials.port,\n\t\t\ttls: credentials.ssl === true,\n\t\t},\n\t\tdatabase: credentials.database,\n\t\tusername: credentials.user || undefined,\n\t\tpassword: credentials.password || undefined,\n\t});\n}\n\nexport async function redisConnectionTest(\n\tthis: ICredentialTestFunctions,\n\tcredential: ICredentialsDecrypted,\n): Promise<INodeCredentialTestResult> {\n\tconst credentials = credential.data as RedisCredential;\n\n\ttry {\n\t\tconst client = setupRedisClient(credentials);\n\t\tawait client.connect();\n\t\tawait client.ping();\n\t\treturn {\n\t\t\tstatus: 'OK',\n\t\t\tmessage: 'Connection successful!',\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tstatus: 'Error',\n\t\t\tmessage: error.message,\n\t\t};\n\t}\n}\n\n/** Parses the given value in a number if it is one else returns a string */\nfunction getParsedValue(value: string): string | number {\n\tif (value.match(/^[\\d\\.]+$/) === null) {\n\t\t// Is a string\n\t\treturn value;\n\t} else {\n\t\t// Is a number\n\t\treturn parseFloat(value);\n\t}\n}\n\n/** Converts the Redis Info String into an object */\nexport function convertInfoToObject(stringData: string): IDataObject {\n\tconst returnData: IDataObject = {};\n\n\tlet key: string, value: string;\n\tfor (const line of stringData.split('\\n')) {\n\t\tif (['#', ''].includes(line.charAt(0))) {\n\t\t\tcontinue;\n\t\t}\n\t\t[key, value] = line.split(':');\n\t\tif (key === undefined || value === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tvalue = value.trim();\n\n\t\tif (value.includes('=')) {\n\t\t\treturnData[key] = {};\n\t\t\tlet key2: string, value2: string;\n\t\t\tfor (const keyValuePair of value.split(',')) {\n\t\t\t\t[key2, value2] = keyValuePair.split('=');\n\t\t\t\t(returnData[key] as IDataObject)[key2] = getParsedValue(value2);\n\t\t\t}\n\t\t} else {\n\t\t\treturnData[key] = getParsedValue(value);\n\t\t}\n\t}\n\n\treturn returnData;\n}\n\nexport async function getValue(client: RedisClient, keyName: string, type?: string) {\n\tif (type === undefined || type === 'automatic') {\n\t\t// Request the type first\n\t\ttype = await client.type(keyName);\n\t}\n\n\tif (type === 'string') {\n\t\treturn await client.get(keyName);\n\t} else if (type === 'hash') {\n\t\treturn await client.hGetAll(keyName);\n\t} else if (type === 'list') {\n\t\treturn await client.lRange(keyName, 0, -1);\n\t} else if (type === 'sets') {\n\t\treturn await client.sMembers(keyName);\n\t}\n}\n\nexport async function setValue(\n\tthis: IExecuteFunctions,\n\tclient: RedisClient,\n\tkeyName: string,\n\tvalue: string | number | object | string[] | number[],\n\texpire: boolean,\n\tttl: number,\n\ttype?: string,\n\tvalueIsJSON?: boolean,\n) {\n\tif (type === undefined || type === 'automatic') {\n\t\t// Request the type first\n\t\tif (typeof value === 'string') {\n\t\t\ttype = 'string';\n\t\t} else if (Array.isArray(value)) {\n\t\t\ttype = 'list';\n\t\t} else if (typeof value === 'object') {\n\t\t\ttype = 'hash';\n\t\t} else {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t'Could not identify the type to set. Please set it manually!',\n\t\t\t);\n\t\t}\n\t}\n\n\tif (type === 'string') {\n\t\tawait client.set(keyName, value.toString());\n\t} else if (type === 'hash') {\n\t\tif (valueIsJSON) {\n\t\t\tlet values: unknown;\n\t\t\tif (typeof value === 'string') {\n\t\t\t\ttry {\n\t\t\t\t\tvalues = JSON.parse(value);\n\t\t\t\t} catch {\n\t\t\t\t\t// This is how we originally worked and prevents a breaking change\n\t\t\t\t\tvalues = value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalues = value;\n\t\t\t}\n\t\t\tfor (const key of Object.keys(values as object)) {\n\t\t\t\tawait client.hSet(keyName, key, (values as IDataObject)[key]!.toString());\n\t\t\t}\n\t\t} else {\n\t\t\tconst values = value.toString().split(' ');\n\t\t\tawait client.hSet(keyName, values);\n\t\t}\n\t} else if (type === 'list') {\n\t\tfor (let index = 0; index < (value as string[]).length; index++) {\n\t\t\tawait client.lSet(keyName, index, (value as IDataObject)[index]!.toString());\n\t\t}\n\t} else if (type === 'sets') {\n\t\t//@ts-ignore\n\t\tawait client.sAdd(keyName, value);\n\t}\n\n\tif (expire) {\n\t\tawait client.expire(keyName, ttl);\n\t}\n\treturn;\n}\n"
          }
        ]
      },
      "metadata": {
        "fetch_time": "2026-02-02T05:33:47.593980+00:00",
        "source_type": "TYPE1",
        "source_path": "input_sources/redis",
        "file_count": 4,
        "content_hash": "972043f953c8f801"
      },
      "artifacts": {
        "raw_source": "/home/toni/agent-skills/artifacts/convert-redis-final-001/raw_source.txt",
        "parsed_source": "/home/toni/agent-skills/artifacts/convert-redis-final-001/parsed_source.json",
        "source_bundle": "/home/toni/agent-skills/artifacts/convert-redis-final-001/source_bundle"
      }
    },
    "infer-schema": {
      "inferred_schema": {
        "type": "redis",
        "version": 1,
        "description": {
          "displayName": "Redis",
          "name": "redis",
          "inputs": [
            {
              "name": "main",
              "type": "main"
            }
          ],
          "outputs": [
            {
              "name": "main",
              "type": "main"
            }
          ]
        },
        "properties": {
          "parameters": [
            {
              "name": "operation",
              "display_name": "Operation",
              "type": "OPTIONS",
              "options": [
                {
                  "name": "Delete",
                  "value": "delete",
                  "description": "Delete a key from Redis"
                },
                {
                  "name": "Get",
                  "value": "get",
                  "description": "Get the value of a key from Redis"
                },
                {
                  "name": "Increment",
                  "value": "incr",
                  "description": "Atomically increments a key by 1. Creates the key if it does not exist."
                },
                {
                  "name": "Info",
                  "value": "info",
                  "description": "Returns generic information about the Redis instance"
                },
                {
                  "name": "Keys",
                  "value": "keys",
                  "description": "Returns all the keys matching a pattern"
                },
                {
                  "name": "Pop",
                  "value": "pop",
                  "description": "Pop data from a redis list"
                },
                {
                  "name": "Publish",
                  "value": "publish",
                  "description": "Publish message to redis channel"
                },
                {
                  "name": "Push",
                  "value": "push",
                  "description": "Push data to a redis list"
                },
                {
                  "name": "Set",
                  "value": "set",
                  "description": "Set the value of a key in redis"
                }
              ],
              "default": "delete",
              "description": "Operation to perform"
            },
            {
              "name": "key",
              "display_name": "Key",
              "type": "STRING",
              "default": "",
              "required": true,
              "description": "Name of the key to delete from Redis",
              "display_options": {
                "show": {
                  "operation": [
                    "delete"
                  ]
                }
              }
            },
            {
              "name": "propertyName",
              "display_name": "Name",
              "type": "STRING",
              "default": "propertyName",
              "required": true,
              "description": "Name of the property to write received data to. Supports dot-notation. Example: ",
              "display_options": {
                "show": {
                  "operation": [
                    "get"
                  ]
                }
              }
            },
            {
              "name": "keyType",
              "display_name": "Key Type",
              "type": "OPTIONS",
              "default": "automatic",
              "description": "Requests the type before requesting the data (slower)",
              "display_options": {
                "show": {
                  "operation": [
                    "get"
                  ]
                }
              },
              "options": [
                {
                  "name": "Automatic",
                  "value": "automatic"
                },
                {
                  "name": "Hash",
                  "value": "hash"
                },
                {
                  "name": "List",
                  "value": "list"
                },
                {
                  "name": "Sets",
                  "value": "sets"
                },
                {
                  "name": "String",
                  "value": "string"
                }
              ]
            },
            {
              "name": "options",
              "display_name": "Options",
              "type": "COLLECTION",
              "default": "",
              "description": "<p>By default, dot-notation is used in property names. This means that ",
              "display_options": {
                "show": {
                  "operation": [
                    "get"
                  ]
                }
              }
            },
            {
              "name": "expire",
              "display_name": "Expire",
              "type": "BOOLEAN",
              "default": false,
              "description": "Whether to set a timeout on key",
              "display_options": {
                "show": {
                  "operation": [
                    "incr"
                  ]
                }
              }
            },
            {
              "name": "ttl",
              "display_name": "TTL",
              "type": "NUMBER",
              "default": 60,
              "description": "Number of seconds before key expiration",
              "display_options": {
                "show": {
                  "operation": [
                    "incr"
                  ]
                }
              }
            },
            {
              "name": "keyPattern",
              "display_name": "Key Pattern",
              "type": "STRING",
              "default": "",
              "required": true,
              "description": "The key pattern for the keys to return",
              "display_options": {
                "show": {
                  "operation": [
                    "keys"
                  ]
                }
              }
            },
            {
              "name": "getValues",
              "display_name": "Get Values",
              "type": "BOOLEAN",
              "default": true,
              "description": "Whether to get the value of matching keys",
              "display_options": {
                "show": {
                  "operation": [
                    "keys"
                  ]
                }
              }
            },
            {
              "name": "value",
              "display_name": "Value",
              "type": "STRING",
              "default": "",
              "description": "The value to write in Redis",
              "display_options": {
                "show": {
                  "operation": [
                    "set"
                  ]
                }
              }
            },
            {
              "name": "valueIsJSON",
              "display_name": "Value Is JSON",
              "type": "BOOLEAN",
              "default": true,
              "description": "Whether the value is JSON or key value pairs"
            },
            {
              "name": "channel",
              "display_name": "Channel",
              "type": "STRING",
              "default": "",
              "required": true,
              "description": "Channel name",
              "display_options": {
                "show": {
                  "operation": [
                    "publish"
                  ]
                }
              }
            },
            {
              "name": "messageData",
              "display_name": "Data",
              "type": "STRING",
              "default": "",
              "required": true,
              "description": "Data to publish",
              "display_options": {
                "show": {
                  "operation": [
                    "publish"
                  ]
                }
              }
            },
            {
              "name": "list",
              "display_name": "List",
              "type": "STRING",
              "default": "",
              "required": true,
              "description": "Name of the list in Redis",
              "display_options": {
                "show": {
                  "operation": [
                    "push",
                    "pop"
                  ]
                }
              }
            },
            {
              "name": "tail",
              "display_name": "Tail",
              "type": "BOOLEAN",
              "default": false,
              "description": "Whether to push or pop data from the end of the list",
              "display_options": {
                "show": {
                  "operation": [
                    "push",
                    "pop"
                  ]
                }
              }
            }
          ],
          "credentials": [
            {
              "name": "redis",
              "required": true
            }
          ]
        },
        "operations": [
          {
            "name": "delete",
            "display_name": "Delete",
            "description": "Delete a key from Redis"
          },
          {
            "name": "get",
            "display_name": "Get",
            "description": "Get the value of a key from Redis"
          },
          {
            "name": "incr",
            "display_name": "Increment",
            "description": "Atomically increments a key by 1. Creates the key if it does not exist."
          },
          {
            "name": "info",
            "display_name": "Info",
            "description": "Returns generic information about the Redis instance"
          },
          {
            "name": "keys",
            "display_name": "Keys",
            "description": "Returns all the keys matching a pattern"
          },
          {
            "name": "pop",
            "display_name": "Pop",
            "description": "Pop data from a redis list"
          },
          {
            "name": "publish",
            "display_name": "Publish",
            "description": "Publish message to redis channel"
          },
          {
            "name": "push",
            "display_name": "Push",
            "description": "Push data to a redis list"
          },
          {
            "name": "set",
            "display_name": "Set",
            "description": "Set the value of a key in redis"
          }
        ],
        "resources": [],
        "credentials": [
          {
            "name": "redis",
            "required": true
          }
        ],
        "execution_contract": {
          "semantic_class": "tcp_client",
          "io_cardinality": {
            "input_count": 1,
            "input_required": [
              0
            ],
            "output_count": 1,
            "output_names": [
              "main"
            ],
            "item_mapping": "1:1"
          },
          "connection": {
            "type": "tcp",
            "factory_method": "_get_redis_client",
            "library": "redis",
            "pooling": false,
            "cleanup": "context_manager"
          },
          "state": {
            "cross_execution": "none",
            "within_execution": "none",
            "persistence_key": null
          },
          "credentials": {
            "type": "redisApi",
            "resolution": "direct",
            "selector_param": null,
            "connection_params": []
          },
          "http_config": null,
          "sdk_config": null,
          "transform_config": null
        }
      },
      "trace_map": {
        "correlation_id": "convert-redis-final-001",
        "node_type": "redis",
        "trace_entries": [
          {
            "field_path": "operations[0].name",
            "source": "SOURCE_CODE",
            "evidence": "n8n operation 'delete' (display: 'Delete') in Redis.node.ts",
            "confidence": "high",
            "source_file": "Redis.node.ts",
            "line_range": "L42",
            "excerpt_hash": "762cadbe0268"
          },
          {
            "field_path": "operations[1].name",
            "source": "SOURCE_CODE",
            "evidence": "n8n operation 'get' (display: 'Get') in Redis.node.ts",
            "confidence": "high",
            "source_file": "Redis.node.ts",
            "line_range": "L42",
            "excerpt_hash": "c9d917f6e0c5"
          },
          {
            "field_path": "operations[2].name",
            "source": "SOURCE_CODE",
            "evidence": "n8n operation 'incr' (display: 'Increment') in Redis.node.ts",
            "confidence": "high",
            "source_file": "Redis.node.ts",
            "line_range": "L42",
            "excerpt_hash": "fd79c76ae160"
          },
          {
            "field_path": "operations[3].name",
            "source": "SOURCE_CODE",
            "evidence": "n8n operation 'info' (display: 'Info') in Redis.node.ts",
            "confidence": "high",
            "source_file": "Redis.node.ts",
            "line_range": "L42",
            "excerpt_hash": "b65c974301fb"
          },
          {
            "field_path": "operations[4].name",
            "source": "SOURCE_CODE",
            "evidence": "n8n operation 'keys' (display: 'Keys') in Redis.node.ts",
            "confidence": "high",
            "source_file": "Redis.node.ts",
            "line_range": "L42",
            "excerpt_hash": "e095cc304207"
          },
          {
            "field_path": "operations[5].name",
            "source": "SOURCE_CODE",
            "evidence": "n8n operation 'pop' (display: 'Pop') in Redis.node.ts",
            "confidence": "high",
            "source_file": "Redis.node.ts",
            "line_range": "L42",
            "excerpt_hash": "7b6e2846d044"
          },
          {
            "field_path": "operations[6].name",
            "source": "SOURCE_CODE",
            "evidence": "n8n operation 'publish' (display: 'Publish') in Redis.node.ts",
            "confidence": "high",
            "source_file": "Redis.node.ts",
            "line_range": "L42",
            "excerpt_hash": "89c2f708a4fa"
          },
          {
            "field_path": "operations[7].name",
            "source": "SOURCE_CODE",
            "evidence": "n8n operation 'push' (display: 'Push') in Redis.node.ts",
            "confidence": "high",
            "source_file": "Redis.node.ts",
            "line_range": "L42",
            "excerpt_hash": "c15d260785b8"
          },
          {
            "field_path": "operations[8].name",
            "source": "SOURCE_CODE",
            "evidence": "n8n operation 'set' (display: 'Set') in Redis.node.ts",
            "confidence": "high",
            "source_file": "Redis.node.ts",
            "line_range": "L42",
            "excerpt_hash": "ed0d55c489a4"
          },
          {
            "field_path": "description.displayName",
            "source": "SOURCE_CODE",
            "evidence": "displayName: 'Redis' in Redis.node.ts",
            "confidence": "high",
            "source_file": "Redis.node.ts"
          },
          {
            "field_path": "parameters.operation",
            "source": "SOURCE_CODE",
            "evidence": "Operation parameter with 9 options in Redis.node.ts",
            "confidence": "high",
            "source_file": "Redis.node.ts"
          },
          {
            "field_path": "credentials[0]",
            "source": "SOURCE_CODE",
            "evidence": "Credential 'redis' (required=True) in Redis.node.ts",
            "confidence": "high",
            "source_file": "Redis.node.ts"
          },
          {
            "field_path": "execution_contract.semantic_class",
            "source": "SOURCE_CODE",
            "evidence": "Detected semantic class 'tcp_client' from code patterns and node type",
            "confidence": "high",
            "source_file": "multiple"
          }
        ],
        "generated_at": "2026-02-02T05:33:47.737323",
        "skill_version": "1.0.0",
        "_hybrid_metadata": {
          "source_type": "TYPE1",
          "extraction_confidence": 0.935,
          "advisor_used": false,
          "assumption_ratio": 0.0,
          "deterministic_operations": 13,
          "assumption_operations": 0
        }
      },
      "schema": {
        "type": "redis",
        "version": 1,
        "description": {
          "displayName": "Redis",
          "name": "redis",
          "inputs": [
            {
              "name": "main",
              "type": "main"
            }
          ],
          "outputs": [
            {
              "name": "main",
              "type": "main"
            }
          ]
        },
        "properties": {
          "parameters": [
            {
              "name": "operation",
              "display_name": "Operation",
              "type": "OPTIONS",
              "options": [
                {
                  "name": "Delete",
                  "value": "delete",
                  "description": "Delete a key from Redis"
                },
                {
                  "name": "Get",
                  "value": "get",
                  "description": "Get the value of a key from Redis"
                },
                {
                  "name": "Increment",
                  "value": "incr",
                  "description": "Atomically increments a key by 1. Creates the key if it does not exist."
                },
                {
                  "name": "Info",
                  "value": "info",
                  "description": "Returns generic information about the Redis instance"
                },
                {
                  "name": "Keys",
                  "value": "keys",
                  "description": "Returns all the keys matching a pattern"
                },
                {
                  "name": "Pop",
                  "value": "pop",
                  "description": "Pop data from a redis list"
                },
                {
                  "name": "Publish",
                  "value": "publish",
                  "description": "Publish message to redis channel"
                },
                {
                  "name": "Push",
                  "value": "push",
                  "description": "Push data to a redis list"
                },
                {
                  "name": "Set",
                  "value": "set",
                  "description": "Set the value of a key in redis"
                }
              ],
              "default": "delete",
              "description": "Operation to perform"
            },
            {
              "name": "key",
              "display_name": "Key",
              "type": "STRING",
              "default": "",
              "required": true,
              "description": "Name of the key to delete from Redis",
              "display_options": {
                "show": {
                  "operation": [
                    "delete"
                  ]
                }
              }
            },
            {
              "name": "propertyName",
              "display_name": "Name",
              "type": "STRING",
              "default": "propertyName",
              "required": true,
              "description": "Name of the property to write received data to. Supports dot-notation. Example: ",
              "display_options": {
                "show": {
                  "operation": [
                    "get"
                  ]
                }
              }
            },
            {
              "name": "keyType",
              "display_name": "Key Type",
              "type": "OPTIONS",
              "default": "automatic",
              "description": "Requests the type before requesting the data (slower)",
              "display_options": {
                "show": {
                  "operation": [
                    "get"
                  ]
                }
              },
              "options": [
                {
                  "name": "Automatic",
                  "value": "automatic"
                },
                {
                  "name": "Hash",
                  "value": "hash"
                },
                {
                  "name": "List",
                  "value": "list"
                },
                {
                  "name": "Sets",
                  "value": "sets"
                },
                {
                  "name": "String",
                  "value": "string"
                }
              ]
            },
            {
              "name": "options",
              "display_name": "Options",
              "type": "COLLECTION",
              "default": "",
              "description": "<p>By default, dot-notation is used in property names. This means that ",
              "display_options": {
                "show": {
                  "operation": [
                    "get"
                  ]
                }
              }
            },
            {
              "name": "expire",
              "display_name": "Expire",
              "type": "BOOLEAN",
              "default": false,
              "description": "Whether to set a timeout on key",
              "display_options": {
                "show": {
                  "operation": [
                    "incr"
                  ]
                }
              }
            },
            {
              "name": "ttl",
              "display_name": "TTL",
              "type": "NUMBER",
              "default": 60,
              "description": "Number of seconds before key expiration",
              "display_options": {
                "show": {
                  "operation": [
                    "incr"
                  ]
                }
              }
            },
            {
              "name": "keyPattern",
              "display_name": "Key Pattern",
              "type": "STRING",
              "default": "",
              "required": true,
              "description": "The key pattern for the keys to return",
              "display_options": {
                "show": {
                  "operation": [
                    "keys"
                  ]
                }
              }
            },
            {
              "name": "getValues",
              "display_name": "Get Values",
              "type": "BOOLEAN",
              "default": true,
              "description": "Whether to get the value of matching keys",
              "display_options": {
                "show": {
                  "operation": [
                    "keys"
                  ]
                }
              }
            },
            {
              "name": "value",
              "display_name": "Value",
              "type": "STRING",
              "default": "",
              "description": "The value to write in Redis",
              "display_options": {
                "show": {
                  "operation": [
                    "set"
                  ]
                }
              }
            },
            {
              "name": "valueIsJSON",
              "display_name": "Value Is JSON",
              "type": "BOOLEAN",
              "default": true,
              "description": "Whether the value is JSON or key value pairs"
            },
            {
              "name": "channel",
              "display_name": "Channel",
              "type": "STRING",
              "default": "",
              "required": true,
              "description": "Channel name",
              "display_options": {
                "show": {
                  "operation": [
                    "publish"
                  ]
                }
              }
            },
            {
              "name": "messageData",
              "display_name": "Data",
              "type": "STRING",
              "default": "",
              "required": true,
              "description": "Data to publish",
              "display_options": {
                "show": {
                  "operation": [
                    "publish"
                  ]
                }
              }
            },
            {
              "name": "list",
              "display_name": "List",
              "type": "STRING",
              "default": "",
              "required": true,
              "description": "Name of the list in Redis",
              "display_options": {
                "show": {
                  "operation": [
                    "push",
                    "pop"
                  ]
                }
              }
            },
            {
              "name": "tail",
              "display_name": "Tail",
              "type": "BOOLEAN",
              "default": false,
              "description": "Whether to push or pop data from the end of the list",
              "display_options": {
                "show": {
                  "operation": [
                    "push",
                    "pop"
                  ]
                }
              }
            }
          ],
          "credentials": [
            {
              "name": "redis",
              "required": true
            }
          ]
        },
        "operations": [
          {
            "name": "delete",
            "display_name": "Delete",
            "description": "Delete a key from Redis"
          },
          {
            "name": "get",
            "display_name": "Get",
            "description": "Get the value of a key from Redis"
          },
          {
            "name": "incr",
            "display_name": "Increment",
            "description": "Atomically increments a key by 1. Creates the key if it does not exist."
          },
          {
            "name": "info",
            "display_name": "Info",
            "description": "Returns generic information about the Redis instance"
          },
          {
            "name": "keys",
            "display_name": "Keys",
            "description": "Returns all the keys matching a pattern"
          },
          {
            "name": "pop",
            "display_name": "Pop",
            "description": "Pop data from a redis list"
          },
          {
            "name": "publish",
            "display_name": "Publish",
            "description": "Publish message to redis channel"
          },
          {
            "name": "push",
            "display_name": "Push",
            "description": "Push data to a redis list"
          },
          {
            "name": "set",
            "display_name": "Set",
            "description": "Set the value of a key in redis"
          }
        ],
        "resources": [],
        "credentials": [
          {
            "name": "redis",
            "required": true
          }
        ],
        "execution_contract": {
          "semantic_class": "tcp_client",
          "io_cardinality": {
            "input_count": 1,
            "input_required": [
              0
            ],
            "output_count": 1,
            "output_names": [
              "main"
            ],
            "item_mapping": "1:1"
          },
          "connection": {
            "type": "tcp",
            "factory_method": "_get_redis_client",
            "library": "redis",
            "pooling": false,
            "cleanup": "context_manager"
          },
          "state": {
            "cross_execution": "none",
            "within_execution": "none",
            "persistence_key": null
          },
          "credentials": {
            "type": "redisApi",
            "resolution": "direct",
            "selector_param": null,
            "connection_params": []
          },
          "http_config": null,
          "sdk_config": null,
          "transform_config": null
        }
      },
      "assumptions": [],
      "artifacts_written": [
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/schema/inferred_schema.json",
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/schema/trace_map.json"
      ],
      "extraction_confidence": 0.935,
      "advisor_used": false
    },
    "scaffold": {
      "files_created": [
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/generated_node/redis.py",
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/generated_node/__init__.py"
      ],
      "allowlist": {
        "node_name": "redis",
        "patterns": [
          "nodes/redis*",
          "nodes/redis*",
          "tests/*redis*",
          "tests/*redis*",
          "credentials/*redis*",
          "credentials/*redis*"
        ]
      }
    },
    "ground": {
      "repo_facts_path": "/home/toni/agent-skills/artifacts/convert-redis-final-001/repo_facts.json",
      "repo_facts": {
        "basenode_contract_path": "contracts/BASENODE_CONTRACT.md",
        "node_loader_paths": [
          "runtime/kb/loader.py"
        ],
        "golden_node_paths": [
          "nodepacks/core/nodes.py",
          "src/node_sdk/basenode.py"
        ],
        "test_command": "pytest tests/"
      },
      "target_repo_layout_path": "/home/toni/agent-skills/artifacts/convert-redis-final-001/target_repo_layout.json",
      "target_repo_layout": {
        "target_repo_root": "/home/toni/agent-skills",
        "node_output_base_dir": "nodes",
        "registry_file": "nodes/__init__.py",
        "registry_strategy": "dict_import",
        "registry_dict_name": "node_definitions",
        "base_class_file": "nodes/base.py",
        "base_class_name": "BaseNode",
        "tests_dir": "tests",
        "python_version": null,
        "venv_path": ".venv",
        "extra_allowlist_patterns": []
      }
    },
    "convert": {
      "files_modified": [
        "nodes/redis.py"
      ],
      "all_target_files": [
        "nodes/redis.py",
        "nodes/__init__.py"
      ],
      "artifact_paths": [
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/converted/redis.py",
        "/home/toni/agent-skills/artifacts/convert-redis-final-001/converted/__init__.py"
      ],
      "conversion_notes": [
        "Selected Redis.node.ts as main node (name match)",
        "Found main node class for Redis",
        "Found 9 operation handlers",
        "Converted /info",
        "Converted /delete",
        "Converted /get",
        "Converted /keys",
        "Converted /set",
        "Converted /incr",
        "Converted /publish",
        "Converted /push",
        "Converted /pop",
        "Using 15 parameters from inferred schema",
        "Using 9 handlers from tcp_client backend",
        "Using tcp_client backend for conversion",
        "Using tcp_client backend for Redis",
        "Library: redis",
        "Credential type: redisApi",
        "Connection params: ['host', 'port', 'database', 'password', 'user', 'ssl']",
        "Added resource-based display_options to operation parameter",
        " Schema validation warnings: [\"Schema validation failed: 15 validation errors for BaseNodeSchema\\nproperties.parameters.0.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='OPTIONS', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.1.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.2.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.3.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='OPTIONS', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.4.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='COLLECTION', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.5.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='BOOLEAN', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.6.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='NUMBER', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.7.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.8.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='BOOLEAN', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.9.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.10.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='BOOLEAN', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.11.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.12.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.13.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='STRING', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\\nproperties.parameters.14.type\\n  Input should be 'string', 'number', 'boolean', 'options', 'multiOptions', 'color', 'json', 'collection', 'dateTime', 'node', 'resourceLocator', 'notice', 'array' or 'code' [type=literal_error, input_value='BOOLEAN', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.12/v/literal_error\"]",
        " No stubs or placeholders detected"
      ],
      "generated_code": {
        "redis.py": "#!/usr/bin/env python3\n\"\"\"\nRedis Node\n\nConverted from TypeScript by agent-skills/code-convert\nCorrelation ID: convert-redis-final-001\nGenerated: 2026-02-02T05:33:48.091539\n\nSYNC-CELERY SAFE: All methods are synchronous with timeouts.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List\nfrom urllib.parse import quote\n\nimport requests\n\nfrom .base import BaseNode, NodeParameterType, NodeExecutionData\n\nlogger = logging.getLogger(__name__)\n\n\nclass RedisNode(BaseNode):\n    \"\"\"\n    Redis node.\n    \n    \n    \"\"\"\n\n    type = \"redis\"\n    version = 1\n    \n    description = {\n        \"displayName\": \"Redis\",\n        \"name\": \"redis\",\n        \"icon\": \"file:redis.svg\",\n        \"group\": ['output'],\n        \"description\": \"\",\n        \"inputs\": [{\"name\": \"main\", \"type\": \"main\", \"required\": True}],\n        \"outputs\": [{\"name\": \"main\", \"type\": \"main\", \"required\": True}],\n    }\n    \n    properties = {\n        \"parameters\": [\n            {\"name\": \"operation\", \"type\": NodeParameterType.OPTIONS, \"display_name\": \"Operation\", \"options\": [\n                {\"name\": \"Delete\", \"value\": \"delete\", \"description\": \"Delete a key from Redis\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Get\", \"value\": \"get\", \"description\": \"Get the value of a key from Redis\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Increment\", \"value\": \"incr\", \"description\": \"Atomically increments a key by 1. Creates the key if it does not exist.\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Info\", \"value\": \"info\", \"description\": \"Returns generic information about the Redis instance\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Keys\", \"value\": \"keys\", \"description\": \"Returns all the keys matching a pattern\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Pop\", \"value\": \"pop\", \"description\": \"Pop data from a redis list\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Publish\", \"value\": \"publish\", \"description\": \"Publish message to redis channel\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Push\", \"value\": \"push\", \"description\": \"Push data to a redis list\", \"display_options\": {'show': {'resource': ['']}}},\n                {\"name\": \"Set\", \"value\": \"set\", \"description\": \"Set the value of a key in redis\", \"display_options\": {'show': {'resource': ['']}}}\n            ], \"default\": \"delete\", \"description\": \"Operation to perform\"},\n            {\"name\": \"key\", \"type\": NodeParameterType.STRING, \"display_name\": \"Key\", \"default\": \"\", \"required\": True, \"description\": \"Name of the key to delete from Redis\", \"display_options\": {'show': {'operation': ['delete']}}},\n            {\"name\": \"propertyName\", \"type\": NodeParameterType.STRING, \"display_name\": \"Name\", \"default\": \"propertyName\", \"required\": True, \"description\": \"Name of the property to write received data to. Supports dot-notation. Example: \", \"display_options\": {'show': {'operation': ['get']}}},\n            {\"name\": \"keyType\", \"type\": NodeParameterType.OPTIONS, \"display_name\": \"Key Type\", \"options\": [\n                {\"name\": \"Automatic\", \"value\": \"automatic\"},\n                {\"name\": \"Hash\", \"value\": \"hash\"},\n                {\"name\": \"List\", \"value\": \"list\"},\n                {\"name\": \"Sets\", \"value\": \"sets\"},\n                {\"name\": \"String\", \"value\": \"string\"}\n            ], \"default\": \"automatic\", \"description\": \"Requests the type before requesting the data (slower)\", \"display_options\": {'show': {'operation': ['get']}}},\n            {\"name\": \"options\", \"type\": NodeParameterType.COLLECTION, \"display_name\": \"Options\", \"default\": \"\", \"description\": \"<p>By default, dot-notation is used in property names. This means that \", \"display_options\": {'show': {'operation': ['get']}}},\n            {\"name\": \"expire\", \"type\": NodeParameterType.BOOLEAN, \"display_name\": \"Expire\", \"default\": False, \"description\": \"Whether to set a timeout on key\", \"display_options\": {'show': {'operation': ['incr']}}},\n            {\"name\": \"ttl\", \"type\": NodeParameterType.NUMBER, \"display_name\": \"TTL\", \"default\": 60, \"description\": \"Number of seconds before key expiration\", \"display_options\": {'show': {'operation': ['incr']}}},\n            {\"name\": \"keyPattern\", \"type\": NodeParameterType.STRING, \"display_name\": \"Key Pattern\", \"default\": \"\", \"required\": True, \"description\": \"The key pattern for the keys to return\", \"display_options\": {'show': {'operation': ['keys']}}},\n            {\"name\": \"getValues\", \"type\": NodeParameterType.BOOLEAN, \"display_name\": \"Get Values\", \"default\": True, \"description\": \"Whether to get the value of matching keys\", \"display_options\": {'show': {'operation': ['keys']}}},\n            {\"name\": \"value\", \"type\": NodeParameterType.STRING, \"display_name\": \"Value\", \"default\": \"\", \"description\": \"The value to write in Redis\", \"display_options\": {'show': {'operation': ['set']}}},\n            {\"name\": \"valueIsJSON\", \"type\": NodeParameterType.BOOLEAN, \"display_name\": \"Value Is JSON\", \"default\": True, \"description\": \"Whether the value is JSON or key value pairs\"},\n            {\"name\": \"channel\", \"type\": NodeParameterType.STRING, \"display_name\": \"Channel\", \"default\": \"\", \"required\": True, \"description\": \"Channel name\", \"display_options\": {'show': {'operation': ['publish']}}},\n            {\"name\": \"messageData\", \"type\": NodeParameterType.STRING, \"display_name\": \"Data\", \"default\": \"\", \"required\": True, \"description\": \"Data to publish\", \"display_options\": {'show': {'operation': ['publish']}}},\n            {\"name\": \"list\", \"type\": NodeParameterType.STRING, \"display_name\": \"List\", \"default\": \"\", \"required\": True, \"description\": \"Name of the list in Redis\", \"display_options\": {'show': {'operation': ['push', 'pop']}}},\n            {\"name\": \"tail\", \"type\": NodeParameterType.BOOLEAN, \"display_name\": \"Tail\", \"default\": False, \"description\": \"Whether to push or pop data from the end of the list\", \"display_options\": {'show': {'operation': ['push', 'pop']}}}\n        ],\n        \"credentials\": [\n            {\"name\": \"redis\", \"required\": True}\n        ]\n    }\n    \n    icon = \"redis.svg\"\n\n    def execute(self) -> List[List[NodeExecutionData]]:\n        \"\"\"\n        Execute the node operations.\n        \n        SYNC-CELERY SAFE: All HTTP calls use timeout parameter.\n        \n        Returns:\n            List[List[NodeExecutionData]]: Nested list where outer list is output branches,\n            inner list is items in that branch.\n        \"\"\"\n        # Get input data from previous node\n        input_data = self.get_input_data()\n        \n        # FIX #40: Handle empty input - create default item so nodes work from Start\n        if not input_data:\n            input_data = [NodeExecutionData(json_data={})]\n        \n        return_items: List[NodeExecutionData] = []\n\n        for i, item in enumerate(input_data):\n            try:\n                operation = self.get_node_parameter(\"operation\", i)\n                item_data = item.json_data if hasattr(item, 'json_data') else item.get('json', {})\n                \n                if operation == \"delete\":\n                    result = self._delete(i, item_data)\n                elif operation == \"get\":\n                    result = self._get(i, item_data)\n                elif operation == \"incr\":\n                    result = self._incr(i, item_data)\n                elif operation == \"info\":\n                    result = self._info(i, item_data)\n                elif operation == \"keys\":\n                    result = self._keys(i, item_data)\n                elif operation == \"pop\":\n                    result = self._pop(i, item_data)\n                elif operation == \"publish\":\n                    result = self._publish(i, item_data)\n                elif operation == \"push\":\n                    result = self._push(i, item_data)\n                elif operation == \"set\":\n                    result = self._set(i, item_data)\n                else:\n                    raise ValueError(f\"Unknown operation: {operation}\")\n                \n                # Handle array results\n                if isinstance(result, list):\n                    for r in result:\n                        return_items.append(NodeExecutionData(json_data=r))\n                else:\n                    return_items.append(NodeExecutionData(json_data=result))\n                    \n            except Exception as e:\n                logger.error(f\"Error in operation {operation}: {e}\")\n                # Platform doesn't support continue_on_fail - always raise\n                raise\n        \n        return [return_items]\n\n    def _get_redis_client(self) -> \"redis.Redis\":\n        \"\"\"\n        Create and return a Redis client using configured credentials.\n        \n        SYNC-CELERY SAFE: Synchronous connection with timeout.\n        \n        Returns:\n            redis.Redis: Configured Redis client instance\n        \"\"\"\n        credentials = self.get_credentials(\"redisApi\")\n        \n        if not credentials:\n            raise Exception(\"Redis credentials not configured\")\n        \n        host = credentials.get(\"host\", \"localhost\")\n        port = int(credentials.get(\"port\", 6379))\n        database = int(credentials.get(\"database\", 0))\n        user = credentials.get(\"user\", \"\") or None\n        password = credentials.get(\"password\", \"\") or None\n        ssl = credentials.get(\"ssl\", False)\n        connection_timeout = int(credentials.get(\"connectionTimeout\", 10))\n        socket_timeout = int(credentials.get(\"socketTimeout\", 30))\n        \n        client = redis.Redis(\n            host=host,\n            port=port,\n            db=database,\n            username=user if user else None,\n            password=password if password else None,\n            ssl=ssl,\n            socket_timeout=socket_timeout,\n            socket_connect_timeout=connection_timeout,\n            decode_responses=True,\n        )\n        \n        return client\n    \n    def _execute_redis_operation(\n        self,\n        operation: str,\n        **kwargs,\n    ) -> Any:\n        \"\"\"\n        Execute a Redis operation with proper connection handling.\n        \n        SYNC-CELERY SAFE: All operations are synchronous.\n        \"\"\"\n        client = self._get_redis_client()\n        \n        try:\n            # Get the operation method\n            op_method = getattr(client, operation, None)\n            if not op_method:\n                raise ValueError(f\"Unknown Redis operation: {operation}\")\n            \n            return op_method(**kwargs)\n        finally:\n            # Redis client doesn't need explicit close for single operations\n            pass\n\n\n    def _delete(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        delete operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Delete operation\n        key = self.get_node_parameter(\"key\", item_index, \"\")\n        if not key:\n            raise ValueError(\"Key is required for delete operation\")\n        \n        client = self._get_redis_client()\n        result = client.delete(key)\n        \n        return {\n            \"json\": {\"key\": key, \"deleted\": result > 0, \"count\": result},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _get(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        get operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Get operation\n        key = self.get_node_parameter(\"key\", item_index, \"\")\n        key_type = self.get_node_parameter(\"keyType\", item_index, \"automatic\")\n        property_name = self.get_node_parameter(\"propertyName\", item_index, \"propertyName\")\n        \n        if not key:\n            raise ValueError(\"Key is required for get operation\")\n        \n        client = self._get_redis_client()\n        \n        # Detect key type if automatic\n        if key_type == \"automatic\":\n            key_type = client.type(key)\n        \n        # Get value based on type\n        if key_type == \"string\":\n            value = client.get(key)\n        elif key_type == \"hash\":\n            value = client.hgetall(key)\n        elif key_type == \"list\":\n            value = client.lrange(key, 0, -1)\n        elif key_type == \"set\":\n            value = list(client.smembers(key))\n        elif key_type == \"zset\":\n            value = client.zrange(key, 0, -1, withscores=True)\n        else:\n            value = client.get(key)\n        \n        return {\n            \"json\": {property_name: value},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _incr(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        incr operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Increment operation\n        key = self.get_node_parameter(\"key\", item_index, \"\")\n        value = self.get_node_parameter(\"value\", item_index, 1)\n        \n        if not key:\n            raise ValueError(\"Key is required for incr operation\")\n        \n        client = self._get_redis_client()\n        \n        if value == 1:\n            result = client.incr(key)\n        else:\n            result = client.incrby(key, int(value))\n        \n        return {\n            \"json\": {\"key\": key, \"value\": result},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _info(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        info operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Info operation\n        client = self._get_redis_client()\n        info = client.info()\n        \n        return {\n            \"json\": info,\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _keys(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        keys operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Keys operation\n        pattern = self.get_node_parameter(\"keyPattern\", item_index, \"*\")\n        \n        client = self._get_redis_client()\n        keys = client.keys(pattern)\n        \n        return {\n            \"json\": {\"keys\": keys, \"count\": len(keys)},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _pop(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        pop operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Pop operation\n        list_name = self.get_node_parameter(\"list\", item_index, \"\")\n        tail = self.get_node_parameter(\"tail\", item_index, False)\n        property_name = self.get_node_parameter(\"propertyName\", item_index, \"propertyName\")\n        \n        if not list_name:\n            raise ValueError(\"List name is required for pop operation\")\n        \n        client = self._get_redis_client()\n        \n        if tail:\n            value = client.rpop(list_name)\n        else:\n            value = client.lpop(list_name)\n        \n        return {\n            \"json\": {property_name: value},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _publish(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        publish operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Publish operation\n        channel = self.get_node_parameter(\"channel\", item_index, \"\")\n        message = self.get_node_parameter(\"messageData\", item_index, \"\")\n        \n        if not channel:\n            raise ValueError(\"Channel is required for publish operation\")\n        \n        client = self._get_redis_client()\n        result = client.publish(channel, message)\n        \n        return {\n            \"json\": {\"channel\": channel, \"subscribers\": result},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _push(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        push operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Push operation\n        list_name = self.get_node_parameter(\"list\", item_index, \"\")\n        values = self.get_node_parameter(\"messageData\", item_index, \"\")\n        tail = self.get_node_parameter(\"tail\", item_index, False)\n        \n        if not list_name:\n            raise ValueError(\"List name is required for push operation\")\n        \n        client = self._get_redis_client()\n        \n        if tail:\n            result = client.rpush(list_name, values)\n        else:\n            result = client.lpush(list_name, values)\n        \n        return {\n            \"json\": {\"list\": list_name, \"length\": result},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n    def _set(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        set operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n        \"\"\"\n\n        # Set operation\n        key = self.get_node_parameter(\"key\", item_index, \"\")\n        value = self.get_node_parameter(\"value\", item_index, \"\")\n        key_type = self.get_node_parameter(\"keyType\", item_index, \"string\")\n        expire = self.get_node_parameter(\"expire\", item_index, False)\n        ttl = self.get_node_parameter(\"ttl\", item_index, None)\n        \n        if not key:\n            raise ValueError(\"Key is required for set operation\")\n        \n        client = self._get_redis_client()\n        \n        if key_type == \"string\":\n            if expire and ttl:\n                client.setex(key, int(ttl), value)\n            else:\n                client.set(key, value)\n        elif key_type == \"hash\":\n            if isinstance(value, dict):\n                client.hset(key, mapping=value)\n            else:\n                # Try to parse as JSON\n                import json\n                try:\n                    value = json.loads(value)\n                    client.hset(key, mapping=value)\n                except json.JSONDecodeError:\n                    client.set(key, value)\n        elif key_type == \"list\":\n            if isinstance(value, list):\n                client.rpush(key, *value)\n            else:\n                client.rpush(key, value)\n        elif key_type == \"set\":\n            if isinstance(value, (list, set)):\n                client.sadd(key, *value)\n            else:\n                client.sadd(key, value)\n        else:\n            client.set(key, value)\n        \n        return {\n            \"json\": {\"key\": key, \"success\": True},\n            \"pairedItem\": {\"item\": item_index},\n        }\n\n\n",
        "__init__.py": "\"\"\"\nRedis Node Package\nConverted from TypeScript by agent-skills/code-convert\n\"\"\"\n\nfrom .redis import RedisNode\n\n__all__ = [\"RedisNode\"]\n"
      }
    },
    "generate-tests": {
      "stub": true,
      "message": "Skill test-generate has no implementation registered"
    },
    "validate": {}
  },
  "artifacts_dir": "/home/toni/agent-skills/artifacts/convert-redis-final-001",
  "errors": []
}