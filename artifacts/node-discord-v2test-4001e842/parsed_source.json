{
  "version": "1.0",
  "created_at": "2026-01-06T04:51:05.565298+00:00",
  "correlation_id": "node-discord-v2test-4001e842",
  "sections": {
    "class_name": "DiscordV1",
    "node_type": "discord",
    "version": 1.0,
    "description": null,
    "properties": [],
    "methods": [
      "function",
      "execute"
    ],
    "credentials": [
      "discordBotApi",
      "discordOAuth2Api",
      "discordWebhookApi"
    ],
    "resources": [
      "channel",
      "member",
      "message"
    ],
    "has_router": true,
    "files": [
      "Discord.node.ts",
      "test/v2/node/channel/create.test.ts",
      "test/v2/node/channel/deleteChannel.test.ts",
      "test/v2/node/channel/get.test.ts",
      "test/v2/node/channel/getAll.test.ts",
      "test/v2/node/channel/update.test.ts",
      "test/v2/node/member/getAll.test.ts",
      "test/v2/node/member/roleAdd.test.ts",
      "test/v2/node/member/roleRemove.test.ts",
      "test/v2/node/message/deleteMessage.test.ts",
      "test/v2/node/message/get.test.ts",
      "test/v2/node/message/getAll.test.ts",
      "test/v2/node/message/react.test.ts",
      "test/v2/node/message/send.test.ts",
      "test/v2/node/message/sendAndWait.test.ts",
      "test/v2/node/webhook/sendLegacy.test.ts",
      "test/v2/utils.test.ts",
      "v1/DiscordV1.node.ts",
      "v1/Interfaces.ts",
      "v2/DiscordV2.node.ts",
      "v2/actions/channel/create.operation.ts",
      "v2/actions/channel/deleteChannel.operation.ts",
      "v2/actions/channel/get.operation.ts",
      "v2/actions/channel/getAll.operation.ts",
      "v2/actions/channel/index.ts",
      "v2/actions/channel/update.operation.ts",
      "v2/actions/common.description.ts",
      "v2/actions/member/getAll.operation.ts",
      "v2/actions/member/index.ts",
      "v2/actions/member/roleAdd.operation.ts",
      "v2/actions/member/roleRemove.operation.ts",
      "v2/actions/message/deleteMessage.operation.ts",
      "v2/actions/message/get.operation.ts",
      "v2/actions/message/getAll.operation.ts",
      "v2/actions/message/index.ts",
      "v2/actions/message/react.operation.ts",
      "v2/actions/message/send.operation.ts",
      "v2/actions/message/sendAndWait.operation.ts",
      "v2/actions/node.type.ts",
      "v2/actions/router.ts",
      "v2/actions/versionDescription.ts",
      "v2/actions/webhook/index.ts",
      "v2/actions/webhook/sendLegacy.operation.ts",
      "v2/helpers/utils.ts",
      "v2/methods/index.ts",
      "v2/methods/listSearch.ts",
      "v2/methods/loadOptions.ts",
      "v2/transport/discord.api.ts",
      "v2/transport/helpers.ts",
      "v2/transport/index.ts"
    ],
    "code": [
      {
        "file": "Discord.node.ts",
        "content": "import type { INodeTypeBaseDescription, IVersionedNodeType } from 'n8n-workflow';\nimport { VersionedNodeType } from 'n8n-workflow';\n\nimport { DiscordV1 } from './v1/DiscordV1.node';\nimport { DiscordV2 } from './v2/DiscordV2.node';\n\nexport class Discord extends VersionedNodeType {\n\tconstructor() {\n\t\tconst baseDescription: INodeTypeBaseDescription = {\n\t\t\tdisplayName: 'Discord',\n\t\t\tname: 'discord',\n\t\t\ticon: 'file:discord.svg',\n\t\t\tgroup: ['output'],\n\t\t\tdefaultVersion: 2,\n\t\t\tdescription: 'Sends data to Discord',\n\t\t};\n\n\t\tconst nodeVersions: IVersionedNodeType['nodeVersions'] = {\n\t\t\t1: new DiscordV1(baseDescription),\n\t\t\t2: new DiscordV2(baseDescription),\n\t\t};\n\n\t\tsuper(nodeVersions, baseDescription);\n\t}\n}\n"
      },
      {
        "file": "test/v2/node/channel/create.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => create', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.post('/guilds/1168516062791340136/channels', { name: 'third', type: '0' })\n\t\t.reply(200, {\n\t\t\tid: '1168528323006181417',\n\t\t\ttype: 0,\n\t\t\tlast_message_id: null,\n\t\t\tflags: 0,\n\t\t\tguild_id: '1168516062791340136',\n\t\t\tname: 'third',\n\t\t\tparent_id: null,\n\t\t\trate_limit_per_user: 0,\n\t\t\ttopic: null,\n\t\t\tposition: 3,\n\t\t\tpermission_overwrites: [],\n\t\t\tnsfw: false,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['create.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/channel/deleteChannel.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => deleteChannel', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.delete('/channels/1168528323006181417')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['deleteChannel.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/channel/get.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => get', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.persist()\n\t\t.get('/users/@me/guilds')\n\t\t.reply(200, [{ id: '1168516062791340136' }])\n\t\t.get('/channels/1168516240332034067')\n\t\t.reply(200, {\n\t\t\tid: '1168516240332034067',\n\t\t\ttype: 0,\n\t\t\tlast_message_id: null,\n\t\t\tflags: 0,\n\t\t\tguild_id: '1168516062791340136',\n\t\t\tname: 'first',\n\t\t\tparent_id: '1168516063340789831',\n\t\t\trate_limit_per_user: 0,\n\t\t\ttopic: null,\n\t\t\tposition: 1,\n\t\t\tpermission_overwrites: [],\n\t\t\tnsfw: false,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['get.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/channel/getAll.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/guilds/1168516062791340136/channels')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tid: '1168516063340789831',\n\t\t\t\ttype: 4,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'Text Channels',\n\t\t\t\tparent_id: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789832',\n\t\t\t\ttype: 4,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'Voice Channels',\n\t\t\t\tparent_id: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789833',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: '1168518371239792720',\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'general',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\ttopic: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t\ticon_emoji: {\n\t\t\t\t\tid: null,\n\t\t\t\t\tname: '\ud83d\udc4b',\n\t\t\t\t},\n\t\t\t\ttheme_color: null,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789834',\n\t\t\t\ttype: 2,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'General',\n\t\t\t\tparent_id: '1168516063340789832',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\tbitrate: 64000,\n\t\t\t\tuser_limit: 0,\n\t\t\t\trtc_region: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t\ticon_emoji: {\n\t\t\t\t\tid: null,\n\t\t\t\t\tname: '\ud83c\udf99\ufe0f',\n\t\t\t\t},\n\t\t\t\ttheme_color: null,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516240332034067',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'first-channel',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 30,\n\t\t\t\ttopic: 'This is channel topic',\n\t\t\t\tposition: 3,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516269079793766',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'second',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\ttopic: null,\n\t\t\t\tposition: 2,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/channel/update.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => update', () => {\n\tnock('https://discord.com/api/v10').patch('/channels/1168516240332034067').reply(200, {\n\t\tid: '1168516240332034067',\n\t\ttype: 0,\n\t\tlast_message_id: null,\n\t\tflags: 0,\n\t\tguild_id: '1168516062791340136',\n\t\tname: 'first-channel',\n\t\tparent_id: '1168516063340789831',\n\t\trate_limit_per_user: 30,\n\t\ttopic: 'This is channel topic',\n\t\tposition: 3,\n\t\tpermission_overwrites: [],\n\t\tnsfw: true,\n\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['update.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/member/getAll.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/guilds/1168516062791340136/members?limit=2')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tuser: {\n\t\t\t\t\tid: '470936827994570762',\n\t\t\t\t\tusername: 'michael',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '0',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: 'Michael',\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\troles: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: {\n\t\t\t\t\tid: '1070667629972430879',\n\t\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '1037',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbot: true,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: null,\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\troles: ['1168518368526077992'],\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/member/roleAdd.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => roleAdd', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.put('/guilds/1168516062791340136/members/470936827994570762/roles/1168772374540320890')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['roleAdd.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/member/roleRemove.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => roleRemove', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.persist()\n\t\t.delete(/\\/guilds\\/1168516062791340136\\/members\\/470936827994570762\\/roles\\/\\d+/)\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['roleRemove.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/message/deleteMessage.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => deleteMessage', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.delete('/channels/1168516240332034067/messages/1168776343194972210')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['deleteMessage.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/message/get.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => get', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/channels/1168516240332034067/messages/1168777380144369718')\n\t\t.reply(200, {\n\t\t\tid: '1168777380144369718',\n\t\t\tchannel_id: '1168516240332034067',\n\t\t\tauthor: {\n\t\t\t\tid: '1070667629972430879',\n\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\tavatar: null,\n\t\t\t\tdiscriminator: '1037',\n\t\t\t\tpublic_flags: 0,\n\t\t\t\tpremium_type: 0,\n\t\t\t\tflags: 0,\n\t\t\t\tbot: true,\n\t\t\t\tbanner: null,\n\t\t\t\taccent_color: null,\n\t\t\t\tglobal_name: null,\n\t\t\t\tavatar_decoration_data: null,\n\t\t\t\tbanner_color: null,\n\t\t\t},\n\t\t\tcontent: 'msg 3',\n\t\t\ttimestamp: '2023-10-31T05:04:02.260000+00:00',\n\t\t\ttype: 0,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['get.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/message/getAll.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/channels/1168516240332034067/messages?limit=1')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tid: '1168784010269433998',\n\t\t\t\ttype: 0,\n\t\t\t\tcontent: 'msg 4',\n\t\t\t\tchannel_id: '1168516240332034067',\n\t\t\t\tauthor: {\n\t\t\t\t\tid: '1070667629972430879',\n\t\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '1037',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbot: true,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: null,\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\tattachments: [],\n\t\t\t\tembeds: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'rich',\n\t\t\t\t\t\ttitle: 'Some Title',\n\t\t\t\t\t\tdescription: 'description',\n\t\t\t\t\t\tcolor: 2112935,\n\t\t\t\t\t\ttimestamp: '2023-10-30T22:00:00+00:00',\n\t\t\t\t\t\tauthor: {\n\t\t\t\t\t\t\tname: 'Me',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tmentions: [],\n\t\t\t\tmention_roles: [],\n\t\t\t\tpinned: false,\n\t\t\t\tmention_everyone: false,\n\t\t\t\ttts: false,\n\t\t\t\ttimestamp: '2023-10-31T05:30:23.005000+00:00',\n\t\t\t\tedited_timestamp: null,\n\t\t\t\tflags: 0,\n\t\t\t\tcomponents: [],\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/message/react.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => react', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.put('/channels/1168516240332034067/messages/1168777380144369718/reactions/%F0%9F%98%80/@me')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['react.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/message/send.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => send', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.post('/channels/1168516240332034067/messages', {\n\t\t\tcontent: 'msg 4',\n\t\t\tembeds: [\n\t\t\t\t{\n\t\t\t\t\tauthor: { name: 'Me' },\n\t\t\t\t\tcolor: 2112935,\n\t\t\t\t\tdescription: 'description',\n\t\t\t\t\ttimestamp: '2023-10-30T22:00:00.000Z',\n\t\t\t\t\ttitle: 'Some Title',\n\t\t\t\t},\n\t\t\t],\n\t\t})\n\t\t.reply(200, {\n\t\t\tid: '1168784010269433998',\n\t\t\ttype: 0,\n\t\t\tcontent: 'msg 4',\n\t\t\tchannel_id: '1168516240332034067',\n\t\t\tauthor: {\n\t\t\t\tid: '1070667629972430879',\n\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\tavatar: null,\n\t\t\t\tdiscriminator: '1037',\n\t\t\t\tpublic_flags: 0,\n\t\t\t\tpremium_type: 0,\n\t\t\t\tflags: 0,\n\t\t\t\tbot: true,\n\t\t\t\tbanner: null,\n\t\t\t\taccent_color: null,\n\t\t\t\tglobal_name: null,\n\t\t\t\tavatar_decoration_data: null,\n\t\t\t\tbanner_color: null,\n\t\t\t},\n\t\t\tattachments: [],\n\t\t\tembeds: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'rich',\n\t\t\t\t\ttitle: 'Some Title',\n\t\t\t\t\tdescription: 'description',\n\t\t\t\t\tcolor: 2112935,\n\t\t\t\t\ttimestamp: '2023-10-30T22:00:00+00:00',\n\t\t\t\t\tauthor: {\n\t\t\t\t\t\tname: 'Me',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tmentions: [],\n\t\t\tmention_roles: [],\n\t\t\tpinned: false,\n\t\t\tmention_everyone: false,\n\t\t\ttts: false,\n\t\t\ttimestamp: '2023-10-31T05:30:23.005000+00:00',\n\t\t\tedited_timestamp: null,\n\t\t\tflags: 0,\n\t\t\tcomponents: [],\n\t\t\treferenced_message: null,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['send.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/message/sendAndWait.test.ts",
        "content": "import type { MockProxy } from 'jest-mock-extended';\nimport { mock } from 'jest-mock-extended';\nimport { SEND_AND_WAIT_OPERATION, type IExecuteFunctions } from 'n8n-workflow';\n\nimport { versionDescription } from '../../../../v2/actions/versionDescription';\nimport { DiscordV2 } from '../../../../v2/DiscordV2.node';\nimport * as transport from '../../../../v2/transport/discord.api';\n\njest.mock('../../../../v2/transport/discord.api', () => {\n\tconst originalModule = jest.requireActual('../../../../v2/transport/discord.api');\n\treturn {\n\t\t...originalModule,\n\t\tdiscordApiRequest: jest.fn(async function (method: string) {\n\t\t\tif (method === 'POST') {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}),\n\t};\n});\n\ndescribe('Test DiscordV2, message => sendAndWait', () => {\n\tlet discord: DiscordV2;\n\tlet mockExecuteFunctions: MockProxy<IExecuteFunctions>;\n\n\tbeforeEach(() => {\n\t\tdiscord = new DiscordV2(versionDescription);\n\t\tmockExecuteFunctions = mock<IExecuteFunctions>();\n\t\tmockExecuteFunctions.helpers = {\n\t\t\tconstructExecutionMetaData: jest.fn(() => []),\n\t\t\treturnJsonArray: jest.fn(() => []),\n\t\t} as any;\n\t});\n\n\tafterEach(() => {\n\t\tjest.clearAllMocks();\n\t});\n\n\tit('should send message and put execution to wait', async () => {\n\t\tconst items = [{ json: { data: 'test' } }];\n\t\tmockExecuteFunctions.getNodeParameter.mockImplementation((key: string) => {\n\t\t\tif (key === 'operation') return SEND_AND_WAIT_OPERATION;\n\t\t\tif (key === 'resource') return 'message';\n\t\t\tif (key === 'authentication') return 'botToken';\n\t\t\tif (key === 'message') return 'my message';\n\t\t\tif (key === 'subject') return '';\n\t\t\tif (key === 'approvalOptions.values') return {};\n\t\t\tif (key === 'responseType') return 'approval';\n\t\t\tif (key === 'sendTo') return 'channel';\n\t\t\tif (key === 'channelId') return 'channelID';\n\t\t\tif (key === 'options.limitWaitTime.values') return {};\n\t\t});\n\n\t\tmockExecuteFunctions.putExecutionToWait.mockImplementation();\n\t\tmockExecuteFunctions.getInputData.mockReturnValue(items);\n\t\tmockExecuteFunctions.getInstanceId.mockReturnValue('instanceId');\n\n\t\tmockExecuteFunctions.evaluateExpression.mockReturnValueOnce('http://localhost/waiting-webhook');\n\t\tmockExecuteFunctions.evaluateExpression.mockReturnValueOnce('nodeID');\n\n\t\tmockExecuteFunctions.getSignedResumeUrl.mockReturnValue(\n\t\t\t'http://localhost/waiting-webhook/nodeID?approved=true&token=abc',\n\t\t);\n\n\t\tconst result = await discord.execute.call(mockExecuteFunctions);\n\n\t\texpect(result).toEqual([items]);\n\t\texpect(transport.discordApiRequest).toHaveBeenCalledTimes(1);\n\t\texpect(mockExecuteFunctions.putExecutionToWait).toHaveBeenCalledTimes(1);\n\n\t\texpect(transport.discordApiRequest).toHaveBeenCalledWith(\n\t\t\t'POST',\n\t\t\t'/channels/channelID/messages',\n\t\t\t{\n\t\t\t\tcomponents: [\n\t\t\t\t\t{\n\t\t\t\t\t\tcomponents: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlabel: 'Approve',\n\t\t\t\t\t\t\t\tstyle: 5,\n\t\t\t\t\t\t\t\ttype: 2,\n\t\t\t\t\t\t\t\turl: 'http://localhost/waiting-webhook/nodeID?approved=true&token=abc',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\ttype: 1,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tembeds: [\n\t\t\t\t\t{\n\t\t\t\t\t\tcolor: 5814783,\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'my message\\n\\n_This message was sent automatically with _[n8n](https://n8n.io/?utm_source=n8n-internal&utm_medium=powered_by&utm_campaign=n8n-nodes-base.discord_instanceId)',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t);\n\t});\n});\n"
      },
      {
        "file": "test/v2/node/webhook/sendLegacy.test.ts",
        "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, webhook => sendLegacy', () => {\n\tconst credentials = {\n\t\tdiscordWebhookApi: {\n\t\t\twebhookUri: 'https://discord.com/webhook',\n\t\t},\n\t};\n\n\tnock(credentials.discordWebhookApi.webhookUri)\n\t\t.post('?wait=true')\n\t\t.reply(200, {\n\t\t\tid: '1168768986385747999',\n\t\t\ttype: 0,\n\t\t\tcontent: 'TEST Message',\n\t\t\tchannel_id: '1074646335082479626',\n\t\t\tauthor: {\n\t\t\t\tid: '1153265494955135077',\n\t\t\t\tusername: 'TEST_USER',\n\t\t\t\tavatar: null,\n\t\t\t\tdiscriminator: '0000',\n\t\t\t\tpublic_flags: 0,\n\t\t\t\tflags: 0,\n\t\t\t\tbot: true,\n\t\t\t\tglobal_name: null,\n\t\t\t},\n\t\t\tattachments: [],\n\t\t\tembeds: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'rich',\n\t\t\t\t\tdescription: 'some description',\n\t\t\t\t\tcolor: 10930459,\n\t\t\t\t\ttimestamp: '2023-10-17T21:00:00+00:00',\n\t\t\t\t\tauthor: {\n\t\t\t\t\t\tname: 'Michael',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tmentions: [],\n\t\t\tmention_roles: [],\n\t\t\tpinned: false,\n\t\t\tmention_everyone: false,\n\t\t\ttts: true,\n\t\t\ttimestamp: '2023-10-31T04:30:41.032000+00:00',\n\t\t\tedited_timestamp: null,\n\t\t\tflags: 4096,\n\t\t\tcomponents: [],\n\t\t\twebhook_id: '1153265494955135077',\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tcredentials,\n\t\tworkflowFiles: ['sendLegacy.workflow.json'],\n\t});\n});\n"
      },
      {
        "file": "test/v2/utils.test.ts",
        "content": "import type { IExecuteFunctions, INode } from 'n8n-workflow';\n\nimport * as transport from '../../v2//transport/discord.api';\nimport {\n\tcreateSimplifyFunction,\n\tprepareOptions,\n\tprepareEmbeds,\n\tcheckAccessToGuild,\n\tsetupChannelGetter,\n} from '../../v2/helpers/utils';\n\nconst node: INode = {\n\tid: '1',\n\tname: 'Discord node',\n\ttypeVersion: 2,\n\ttype: 'n8n-nodes-base.discord',\n\tposition: [60, 760],\n\tparameters: {\n\t\tresource: 'channel',\n\t\toperation: 'get',\n\t},\n};\n\ndescribe('Test Discord > createSimplifyFunction', () => {\n\tit('should create function', () => {\n\t\tconst result = createSimplifyFunction(['message_reference']);\n\t\texpect(result).toBeDefined();\n\t\texpect(typeof result).toBe('function');\n\t});\n\n\tit('should return object containing only specified fields', () => {\n\t\tconst simplify = createSimplifyFunction(['id', 'name']);\n\t\tconst data = {\n\t\t\tid: '123',\n\t\t\tname: 'test',\n\t\t\ttype: 'test',\n\t\t\trandomField: 'test',\n\t\t};\n\t\tconst result = simplify(data);\n\t\texpect(result).toEqual({\n\t\t\tid: '123',\n\t\t\tname: 'test',\n\t\t});\n\t});\n});\n\ndescribe('Test Discord > prepareOptions', () => {\n\tit('should return correct flag value', () => {\n\t\tconst result = prepareOptions({\n\t\t\tflags: ['SUPPRESS_EMBEDS', 'SUPPRESS_NOTIFICATIONS'],\n\t\t});\n\t\texpect(result.flags).toBe((1 << 2) + (1 << 12));\n\t});\n\n\tit('should convert message_reference', () => {\n\t\tconst result = prepareOptions(\n\t\t\t{\n\t\t\t\tmessage_reference: '123456',\n\t\t\t},\n\t\t\t'789000',\n\t\t);\n\t\texpect(result.message_reference).toEqual({\n\t\t\tmessage_id: '123456',\n\t\t\tguild_id: '789000',\n\t\t});\n\t});\n});\n\ndescribe('Test Discord > prepareEmbeds', () => {\n\tit('should return return empty object removing empty strings', () => {\n\t\tconst embeds = [\n\t\t\t{\n\t\t\t\ttest1: 'test',\n\t\t\t\ttest2: 'test',\n\t\t\t\tdescription: 'test',\n\t\t\t},\n\t\t];\n\n\t\tconst executeFunction = {};\n\n\t\tconst result = prepareEmbeds.call(executeFunction as unknown as IExecuteFunctions, embeds);\n\n\t\texpect(result).toEqual(embeds);\n\t});\n});\n\ndescribe('Test Discord > checkAccessToGuild', () => {\n\tit('should throw error', () => {\n\t\tconst guildId = '123456';\n\t\tconst guilds = [\n\t\t\t{\n\t\t\t\tid: '789000',\n\t\t\t},\n\t\t];\n\n\t\texpect(() => {\n\t\t\tcheckAccessToGuild(node, guildId, guilds);\n\t\t}).toThrow('You do not have access to the guild with the id 123456');\n\t});\n\n\tit('should pass', () => {\n\t\tconst guildId = '123456';\n\t\tconst guilds = [\n\t\t\t{\n\t\t\t\tid: '123456',\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '789000',\n\t\t\t},\n\t\t];\n\n\t\texpect(() => {\n\t\t\tcheckAccessToGuild(node, guildId, guilds);\n\t\t}).not.toThrow();\n\t});\n});\n\ndescribe('Test Discord > setupChannelGetter & checkAccessToChannel', () => {\n\tconst discordApiRequestSpy = jest.spyOn(transport, 'discordApiRequest');\n\tdiscordApiRequestSpy.mockImplementation(async (method: string) => {\n\t\tif (method === 'GET') {\n\t\t\treturn {\n\t\t\t\tguild_id: '123456',\n\t\t\t};\n\t\t}\n\t});\n\n\tit('should setup channel getter and get channel id', async () => {\n\t\tconst fakeExecuteFunction = (auth: string) => {\n\t\t\treturn {\n\t\t\t\tgetNodeParameter: (parameter: string) => {\n\t\t\t\t\tif (parameter === 'authentication') return auth;\n\t\t\t\t\tif (parameter === 'channelId') return '42';\n\t\t\t\t},\n\t\t\t\tgetNode: () => node,\n\t\t\t} as unknown as IExecuteFunctions;\n\t\t};\n\n\t\tconst userGuilds = [\n\t\t\t{\n\t\t\t\tid: '789000',\n\t\t\t},\n\t\t];\n\n\t\ttry {\n\t\t\tconst getChannel = await setupChannelGetter.call(fakeExecuteFunction('oAuth2'), userGuilds);\n\t\t\tawait getChannel(0);\n\t\t} catch (error) {\n\t\t\texpect(error.message).toBe('You do not have access to the guild with the id 123456');\n\t\t}\n\n\t\tconst getChannel = await setupChannelGetter.call(fakeExecuteFunction('botToken'), userGuilds);\n\t\tconst channelId = await getChannel(0);\n\t\texpect(channelId).toBe('42');\n\t});\n});\n"
      },
      {
        "file": "v1/DiscordV1.node.ts",
        "content": "import type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n\tIRequestOptions,\n} from 'n8n-workflow';\nimport {\n\tjsonParse,\n\tNodeApiError,\n\tNodeConnectionTypes,\n\tNodeOperationError,\n\tsleep,\n} from 'n8n-workflow';\n\nimport type { DiscordAttachment, DiscordWebhook } from './Interfaces';\nimport { oldVersionNotice } from '../../../utils/descriptions';\n\nconst versionDescription: INodeTypeDescription = {\n\tdisplayName: 'Discord',\n\tname: 'discord',\n\ticon: 'file:discord.svg',\n\tgroup: ['output'],\n\tversion: 1,\n\tdescription: 'Sends data to Discord',\n\tdefaults: {\n\t\tname: 'Discord',\n\t},\n\tinputs: [NodeConnectionTypes.Main],\n\toutputs: [NodeConnectionTypes.Main],\n\tproperties: [\n\t\toldVersionNotice,\n\t\t{\n\t\t\tdisplayName: 'Webhook URL',\n\t\t\tname: 'webhookUri',\n\t\t\ttype: 'string',\n\t\t\trequired: true,\n\t\t\tdefault: '',\n\t\t\tplaceholder: 'https://discord.com/api/webhooks/ID/TOKEN',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Content',\n\t\t\tname: 'text',\n\t\t\ttype: 'string',\n\t\t\ttypeOptions: {\n\t\t\t\tmaxValue: 2000,\n\t\t\t},\n\t\t\tdefault: '',\n\t\t\tplaceholder: 'Hello World!',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Additional Fields',\n\t\t\tname: 'options',\n\t\t\ttype: 'collection',\n\t\t\tplaceholder: 'Add option',\n\t\t\tdefault: {},\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Allowed Mentions',\n\t\t\t\t\tname: 'allowedMentions',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Attachments',\n\t\t\t\t\tname: 'attachments',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Avatar URL',\n\t\t\t\t\tname: 'avatarUrl',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Components',\n\t\t\t\t\tname: 'components',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Embeds',\n\t\t\t\t\tname: 'embeds',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Flags',\n\t\t\t\t\tname: 'flags',\n\t\t\t\t\ttype: 'number',\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'JSON Payload',\n\t\t\t\t\tname: 'payloadJson',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Username',\n\t\t\t\t\tname: 'username',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\tplaceholder: 'User',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'TTS',\n\t\t\t\t\tname: 'tts',\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tdefault: false,\n\t\t\t\t\tdescription: 'Whether this message be sent as a Text To Speech message',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport class DiscordV1 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t};\n\t}\n\n\tasync execute(this: IExecuteFunctions) {\n\t\tconst returnData: INodeExecutionData[] = [];\n\n\t\tconst webhookUri = this.getNodeParameter('webhookUri', 0, '') as string;\n\n\t\tif (!webhookUri) throw new NodeOperationError(this.getNode(), 'Webhook uri is required.');\n\n\t\tconst items = this.getInputData();\n\t\tconst length = items.length;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst body: DiscordWebhook = {};\n\n\t\t\tconst iterationWebhookUri = this.getNodeParameter('webhookUri', i) as string;\n\t\t\tbody.content = this.getNodeParameter('text', i) as string;\n\t\t\tconst options = this.getNodeParameter('options', i);\n\n\t\t\tif (!body.content && !options.embeds) {\n\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Either content or embeds must be set.', {\n\t\t\t\t\titemIndex: i,\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (options.embeds) {\n\t\t\t\ttry {\n\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\tbody.embeds = JSON.parse(options.embeds);\n\t\t\t\t\tif (!Array.isArray(body.embeds)) {\n\t\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Embeds must be an array of embeds.', {\n\t\t\t\t\t\t\titemIndex: i,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Embeds must be valid JSON.', {\n\t\t\t\t\t\titemIndex: i,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.username) {\n\t\t\t\tbody.username = options.username as string;\n\t\t\t}\n\n\t\t\tif (options.components) {\n\t\t\t\ttry {\n\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\tbody.components = JSON.parse(options.components);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Components must be valid JSON.', {\n\t\t\t\t\t\titemIndex: i,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (options.allowed_mentions) {\n\t\t\t\t//@ts-expect-error\n\t\t\t\tbody.allowed_mentions = jsonParse(options.allowed_mentions);\n\t\t\t}\n\n\t\t\tif (options.avatarUrl) {\n\t\t\t\tbody.avatar_url = options.avatarUrl as string;\n\t\t\t}\n\n\t\t\tif (options.flags) {\n\t\t\t\tbody.flags = options.flags as number;\n\t\t\t}\n\n\t\t\tif (options.tts) {\n\t\t\t\tbody.tts = options.tts as boolean;\n\t\t\t}\n\n\t\t\tif (options.payloadJson) {\n\t\t\t\t//@ts-expect-error\n\t\t\t\tbody.payload_json = jsonParse(options.payloadJson);\n\t\t\t}\n\n\t\t\tif (options.attachments) {\n\t\t\t\t//@ts-expect-error\n\t\t\t\tbody.attachments = jsonParse(options.attachments as DiscordAttachment[]);\n\t\t\t}\n\n\t\t\t//* Not used props, delete them from the payload as Discord won't need them :^\n\t\t\tif (!body.content) delete body.content;\n\t\t\tif (!body.username) delete body.username;\n\t\t\tif (!body.avatar_url) delete body.avatar_url;\n\t\t\tif (!body.embeds) delete body.embeds;\n\t\t\tif (!body.allowed_mentions) delete body.allowed_mentions;\n\t\t\tif (!body.flags) delete body.flags;\n\t\t\tif (!body.components) delete body.components;\n\t\t\tif (!body.payload_json) delete body.payload_json;\n\t\t\tif (!body.attachments) delete body.attachments;\n\n\t\t\tlet requestOptions: IRequestOptions;\n\n\t\t\tif (!body.payload_json) {\n\t\t\t\trequestOptions = {\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\tbody,\n\t\t\t\t\turi: iterationWebhookUri,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json; charset=utf-8',\n\t\t\t\t\t},\n\t\t\t\t\tjson: true,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\trequestOptions = {\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\tbody,\n\t\t\t\t\turi: iterationWebhookUri,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'multipart/form-data; charset=utf-8',\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t\tlet maxTries = 5;\n\t\t\tlet response;\n\n\t\t\tdo {\n\t\t\t\ttry {\n\t\t\t\t\tresponse = await this.helpers.request(requestOptions);\n\t\t\t\t\tconst resetAfter = response.headers['x-ratelimit-reset-after'] * 1000;\n\t\t\t\t\tconst remainingRatelimit = response.headers['x-ratelimit-remaining'];\n\n\t\t\t\t\t// remaining requests 0\n\t\t\t\t\t// https://discord.com/developers/docs/topics/rate-limits\n\t\t\t\t\tif (!+remainingRatelimit) {\n\t\t\t\t\t\tawait sleep(resetAfter ?? 1000);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// HTTP/1.1 429 TOO MANY REQUESTS\n\t\t\t\t\t// Await when the current rate limit will reset\n\t\t\t\t\t// https://discord.com/developers/docs/topics/rate-limits\n\t\t\t\t\tif (error.statusCode === 429) {\n\t\t\t\t\t\tconst retryAfter = error.response?.headers['retry-after'] || 1000;\n\n\t\t\t\t\t\tawait sleep(+retryAfter);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t} while (--maxTries);\n\n\t\t\tif (maxTries <= 0) {\n\t\t\t\tthrow new NodeApiError(this.getNode(), {\n\t\t\t\t\terror: 'Could not send Webhook message. Max amount of rate-limit retries reached.',\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\t\t\treturnData.push(...executionData);\n\t\t}\n\n\t\treturn [returnData];\n\t}\n}\n"
      },
      {
        "file": "v1/Interfaces.ts",
        "content": "export interface DiscordWebhook {\n\tcontent?: string;\n\tusername?: string;\n\tavatar_url?: string;\n\ttts?: boolean;\n\tfile?: Buffer;\n\tembeds?: any[];\n\tallowed_mentions?: {\n\t\tparse: Array<'roles' | 'users' | 'everyone'>;\n\t\troles: string[];\n\t\tusers: string[];\n\t\treplied_user: boolean;\n\t};\n\tflags?: number;\n\tattachments?: DiscordAttachment[];\n\tcomponents?: any[];\n\tpayload_json?: any;\n}\n\nexport interface DiscordAttachment {\n\tid?: string;\n\tfilename?: string;\n\tsize?: number;\n\tdescription?: string;\n\tcontent_type?: string;\n\turl?: string;\n\tproxy_url?: string;\n\theight?: number;\n\twidth?: number;\n\tephemeral?: boolean;\n}\n"
      },
      {
        "file": "v2/DiscordV2.node.ts",
        "content": "import type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\n\nimport { router } from './actions/router';\nimport { versionDescription } from './actions/versionDescription';\nimport { listSearch, loadOptions } from './methods';\nimport { sendAndWaitWebhook } from '../../../utils/sendAndWait/utils';\n\nexport class DiscordV2 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t\tusableAsTool: true,\n\t\t};\n\t}\n\n\tmethods = {\n\t\tlistSearch,\n\t\tloadOptions,\n\t};\n\n\twebhook = sendAndWaitWebhook;\n\n\tasync execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {\n\t\treturn await router.call(this);\n\t}\n}\n"
      },
      {
        "file": "v2/actions/channel/create.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { categoryRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Name',\n\t\tname: 'name',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\trequired: true,\n\t\tdescription: 'The name of the channel',\n\t\tplaceholder: 'e.g. new-channel',\n\t},\n\t{\n\t\tdisplayName: 'Type',\n\t\tname: 'type',\n\t\ttype: 'options',\n\t\tdefault: '0',\n\t\trequired: true,\n\t\tdescription: 'The type of channel to create',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Guild Text',\n\t\t\t\tvalue: '0',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Guild Voice',\n\t\t\t\tvalue: '2',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Guild Category',\n\t\t\t\tvalue: '4',\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Age-Restricted (NSFW)',\n\t\t\t\tname: 'nsfw',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether the content of the channel might be nsfw (not safe for work)',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\thide: {\n\t\t\t\t\t\t'/type': ['4'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Bitrate',\n\t\t\t\tname: 'bitrate',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 8000,\n\t\t\t\tplaceholder: 'e.g. 8000',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 8000,\n\t\t\t\t\tmaxValue: 96000,\n\t\t\t\t},\n\t\t\t\tdescription: 'The bitrate (in bits) of the voice channel',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\t'/type': ['2'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\t...categoryRLC,\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\thide: {\n\t\t\t\t\t\t'/type': ['4'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Position',\n\t\t\t\tname: 'position',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Rate Limit Per User',\n\t\t\t\tname: 'rate_limit_per_user',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 0,\n\t\t\t\tdescription: 'Amount of seconds a user has to wait before sending another message',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\thide: {\n\t\t\t\t\t\t'/type': ['4'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Topic',\n\t\t\t\tname: 'topic',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\trows: 2,\n\t\t\t\t},\n\t\t\t\tdescription: 'The channel topic description (0-1024 characters)',\n\t\t\t\tplaceholder: 'e.g. This channel is about\u2026',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\thide: {\n\t\t\t\t\t\t'/type': ['4'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'User Limit',\n\t\t\t\tname: 'user_limit',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 0,\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 0,\n\t\t\t\t\tmaxValue: 99,\n\t\t\t\t},\n\t\t\t\tplaceholder: 'e.g. 20',\n\t\t\t\tdescription:\n\t\t\t\t\t'The limit for the number of members that can be in the channel (0 refers to no limit)',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\t'/type': ['2'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['create'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst name = this.getNodeParameter('name', i) as string;\n\t\t\tconst type = this.getNodeParameter('type', i) as string;\n\t\t\tconst options = this.getNodeParameter('options', i);\n\n\t\t\tif (options.categoryId) {\n\t\t\t\toptions.parent_id = (options.categoryId as IDataObject).value;\n\t\t\t\tdelete options.categoryId;\n\t\t\t}\n\n\t\t\tconst body: IDataObject = {\n\t\t\t\tname,\n\t\t\t\ttype,\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst response = await discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'POST',\n\t\t\t\t`/guilds/${guildId}/channels`,\n\t\t\t\tbody,\n\t\t\t);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/channel/deleteChannel.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [channelRLC];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['deleteChannel'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst response = await discordApiRequest.call(this, 'DELETE', `/channels/${channelId}`);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/channel/get.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [channelRLC];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['get'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst response = await discordApiRequest.call(this, 'GET', `/channels/${channelId}`);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/channel/getAll.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { returnAllOrLimit } from '../../../../../utils/descriptions';\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\n\nconst properties: INodeProperties[] = [\n\t...returnAllOrLimit,\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Filter by Type',\n\t\t\t\tname: 'filter',\n\t\t\t\ttype: 'multiOptions',\n\t\t\t\tdefault: [],\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Guild Text',\n\t\t\t\t\t\tvalue: 0,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Guild Voice',\n\t\t\t\t\t\tvalue: 2,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Guild Category',\n\t\t\t\t\t\tvalue: 4,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['getAll'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\n\ttry {\n\t\tconst returnAll = this.getNodeParameter('returnAll', 0, false);\n\t\tlet response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/channels`);\n\n\t\tif (!returnAll) {\n\t\t\tconst limit = this.getNodeParameter('limit', 0);\n\t\t\tresponse = (response as IDataObject[]).slice(0, limit);\n\t\t}\n\n\t\tconst options = this.getNodeParameter('options', 0, {});\n\n\t\tif (options.filter) {\n\t\t\tconst filter = options.filter as number[];\n\t\t\tresponse = (response as IDataObject[]).filter((item) => filter.includes(item.type as number));\n\t\t}\n\n\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t{ itemData: { item: 0 } },\n\t\t);\n\n\t\treturnData.push(...executionData);\n\t} catch (error) {\n\t\tconst err = parseDiscordError.call(this, error);\n\n\t\tif (this.continueOnFail()) {\n\t\t\treturnData.push(...prepareErrorData.call(this, err, 0));\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/channel/index.ts",
        "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport * as create from './create.operation';\nimport * as deleteChannel from './deleteChannel.operation';\nimport * as get from './get.operation';\nimport * as getAll from './getAll.operation';\nimport * as update from './update.operation';\nimport { guildRLC } from '../common.description';\n\nexport { create, get, getAll, update, deleteChannel };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['channel'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Create',\n\t\t\t\tvalue: 'create',\n\t\t\t\tdescription: 'Create a new channel',\n\t\t\t\taction: 'Create a channel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Delete',\n\t\t\t\tvalue: 'deleteChannel',\n\t\t\t\tdescription: 'Delete a channel',\n\t\t\t\taction: 'Delete a channel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Get',\n\t\t\t\tvalue: 'get',\n\t\t\t\tdescription: 'Get a channel',\n\t\t\t\taction: 'Get a channel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Get Many',\n\t\t\t\tvalue: 'getAll',\n\t\t\t\tdescription: 'Retrieve the channels of a server',\n\t\t\t\taction: 'Get many channels',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Update',\n\t\t\t\tvalue: 'update',\n\t\t\t\tdescription: 'Update a channel',\n\t\t\t\taction: 'Update a channel',\n\t\t\t},\n\t\t],\n\t\tdefault: 'create',\n\t},\n\t{\n\t\t...guildRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['channel'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t},\n\t...create.description,\n\t...deleteChannel.description,\n\t...get.description,\n\t...getAll.description,\n\t...update.description,\n];\n"
      },
      {
        "file": "v2/actions/channel/update.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { categoryRLC, channelRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\tchannelRLC,\n\t{\n\t\tdisplayName: 'Name',\n\t\tname: 'name',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription:\n\t\t\t\"The new name of the channel. Fill this field only if you want to change the channel's name.\",\n\t\tplaceholder: 'e.g. new-channel-name',\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Age-Restricted (NSFW)',\n\t\t\t\tname: 'nsfw',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether the content of the channel might be nsfw (not safe for work)',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Bitrate',\n\t\t\t\tname: 'bitrate',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 8000,\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 8000,\n\t\t\t\t\tmaxValue: 96000,\n\t\t\t\t},\n\t\t\t\tdescription: 'The bitrate (in bits) of the voice channel',\n\t\t\t\thint: 'Only applicable to voice channels',\n\t\t\t},\n\t\t\tcategoryRLC,\n\t\t\t{\n\t\t\t\tdisplayName: 'Position',\n\t\t\t\tname: 'position',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 1,\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'Rate Limit Per User',\n\t\t\t\tname: 'rate_limit_per_user',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 0,\n\t\t\t\tdescription: 'Amount of seconds a user has to wait before sending another message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Topic',\n\t\t\t\tname: 'topic',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\trows: 2,\n\t\t\t\t},\n\t\t\t\tdescription: 'The channel topic description (0-1024 characters)',\n\t\t\t\tplaceholder: 'e.g. This channel is about\u2026',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'User Limit',\n\t\t\t\tname: 'user_limit',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 0,\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 0,\n\t\t\t\t\tmaxValue: 99,\n\t\t\t\t},\n\t\t\t\tplaceholder: 'e.g. 20',\n\t\t\t\thint: 'Only applicable to voice channels',\n\t\t\t\tdescription:\n\t\t\t\t\t'The limit for the number of members that can be in the channel (0 refers to no limit)',\n\t\t\t},\n\t\t],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['update'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst name = this.getNodeParameter('name', i) as string;\n\t\t\tconst options = this.getNodeParameter('options', i);\n\n\t\t\tif (options.categoryId) {\n\t\t\t\toptions.parent_id = (options.categoryId as IDataObject).value;\n\t\t\t\tdelete options.categoryId;\n\t\t\t}\n\n\t\t\tconst body: IDataObject = {\n\t\t\t\tname,\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst response = await discordApiRequest.call(this, 'PATCH', `/channels/${channelId}`, body);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/common.description.ts",
        "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../utils/utilities';\n\nexport const guildRLC: INodeProperties = {\n\tdisplayName: 'Server',\n\tname: 'guildId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'Select the server (guild) that your bot is connected to',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. my-server',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'guildSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By URL',\n\t\t\tname: 'url',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. https://discord.com/channels/[guild-id]',\n\t\t\textractValue: {\n\t\t\t\ttype: 'regex',\n\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/([0-9]+)',\n\t\t\t},\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/([0-9]+)',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Server URL',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 896347036838936576',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Server ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const channelRLC: INodeProperties = {\n\tdisplayName: 'Channel',\n\tname: 'channelId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'Select the channel by name, URL, or ID',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. my-channel',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'channelSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By URL',\n\t\t\tname: 'url',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. https://discord.com/channels/[guild-id]/[channel-id]',\n\t\t\textractValue: {\n\t\t\t\ttype: 'regex',\n\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t},\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Channel URL',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 896347036838936576',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Channel ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const textChannelRLC: INodeProperties = {\n\tdisplayName: 'Channel',\n\tname: 'channelId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'Select the channel by name, URL, or ID',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. my-channel',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'textChannelSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By URL',\n\t\t\tname: 'url',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. https://discord.com/channels/[guild-id]/[channel-id]',\n\t\t\textractValue: {\n\t\t\t\ttype: 'regex',\n\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t},\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Channel URL',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 896347036838936576',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Channel ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const categoryRLC: INodeProperties = {\n\tdisplayName: 'Parent Category',\n\tname: 'categoryId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\tdescription: 'The parent category where you want the channel to appear',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. my-channel',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'categorySearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By URL',\n\t\t\tname: 'url',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. https://discord.com/channels/[guild-id]/[channel-id]',\n\t\t\textractValue: {\n\t\t\t\ttype: 'regex',\n\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t},\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Category URL',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 896347036838936576',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Category ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const userRLC: INodeProperties = {\n\tdisplayName: 'User',\n\tname: 'userId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\tdescription: 'Select the user you want to assign a role to',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. DiscordUser',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'userSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 786953432728469534',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid User ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const roleMultiOptions: INodeProperties = {\n\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-multi-options\n\tdisplayName: 'Role',\n\tname: 'role',\n\ttype: 'multiOptions',\n\ttypeOptions: {\n\t\tloadOptionsMethod: 'getRoles',\n\t\tloadOptionsDependsOn: ['userId.value', 'guildId.value', 'operation'],\n\t},\n\trequired: true,\n\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-multi-options\n\tdescription: 'Select the roles you want to add to the user',\n\tdefault: [],\n};\n\nexport const maxResultsNumber: INodeProperties = {\n\tdisplayName: 'Max Results',\n\tname: 'maxResults',\n\ttype: 'number',\n\ttypeOptions: {\n\t\tminValue: 1,\n\t},\n\tdefault: 50,\n\tdescription: 'Maximum number of results. Too many results may slow down the query.',\n};\n\nexport const messageIdString: INodeProperties = {\n\tdisplayName: 'Message ID',\n\tname: 'messageId',\n\ttype: 'string',\n\tdefault: '',\n\trequired: true,\n\tdescription: 'The ID of the message',\n\tplaceholder: 'e.g. 1057576506244726804',\n};\n\nexport const simplifyBoolean: INodeProperties = {\n\tdisplayName: 'Simplify',\n\tname: 'simplify',\n\ttype: 'boolean',\n\tdefault: true,\n\tdescription: 'Whether to return a simplified version of the response instead of the raw data',\n};\n\n// embeds -----------------------------------------------------------------------------------------\nconst embedFields: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Description',\n\t\tname: 'description',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The description of embed',\n\t\tplaceholder: 'e.g. My description',\n\t\ttypeOptions: {\n\t\t\trows: 2,\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Author',\n\t\tname: 'author',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The name of the author',\n\t\tplaceholder: 'e.g. John Doe',\n\t},\n\t{\n\t\tdisplayName: 'Color',\n\t\tname: 'color',\n\n\t\ttype: 'color',\n\t\tdefault: '',\n\t\tdescription: 'Color code of the embed',\n\t\tplaceholder: 'e.g. 12123432',\n\t},\n\t{\n\t\tdisplayName: 'Timestamp',\n\t\tname: 'timestamp',\n\t\ttype: 'dateTime',\n\t\tdefault: '',\n\t\tdescription: 'The time displayed at the bottom of the embed. Provide in ISO8601 format.',\n\t\tplaceholder: 'e.g. 2023-02-08 09:30:26',\n\t},\n\t{\n\t\tdisplayName: 'Title',\n\t\tname: 'title',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The title of embed',\n\t\tplaceholder: \"e.g. Embed's title\",\n\t},\n\t{\n\t\tdisplayName: 'URL',\n\t\tname: 'url',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The URL where you want to link the embed to',\n\t\tplaceholder: 'e.g. https://discord.com/',\n\t},\n\t{\n\t\tdisplayName: 'URL Image',\n\t\tname: 'image',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'Source URL of image (only supports http(s) and attachments)',\n\t\tplaceholder: 'e.g. https://example.com/image.png',\n\t},\n\t{\n\t\tdisplayName: 'URL Thumbnail',\n\t\tname: 'thumbnail',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'Source URL of thumbnail (only supports http(s) and attachments)',\n\t\tplaceholder: 'e.g. https://example.com/image.png',\n\t},\n\t{\n\t\tdisplayName: 'URL Video',\n\t\tname: 'video',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'Source URL of video',\n\t\tplaceholder: 'e.g. https://example.com/video.mp4',\n\t},\n];\n\nconst embedFieldsDescription = updateDisplayOptions(\n\t{\n\t\tshow: {\n\t\t\tinputMethod: ['fields'],\n\t\t},\n\t},\n\tembedFields,\n);\n\nexport const embedsFixedCollection: INodeProperties = {\n\tdisplayName: 'Embeds',\n\tname: 'embeds',\n\ttype: 'fixedCollection',\n\tplaceholder: 'Add Embeds',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tdefault: [],\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Input Method',\n\t\t\t\t\tname: 'inputMethod',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Enter Fields',\n\t\t\t\t\t\t\tvalue: 'fields',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Raw JSON',\n\t\t\t\t\t\t\tvalue: 'json',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'fields',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\tname: 'json',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\tdefault: '={}',\n\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\trows: 2,\n\t\t\t\t\t},\n\t\t\t\t\tdisplayOptions: {\n\t\t\t\t\t\tshow: {\n\t\t\t\t\t\t\tinputMethod: ['json'],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t...embedFieldsDescription,\n\t\t\t],\n\t\t},\n\t],\n};\n\n// -------------------------------------------------------------------------------------------\n\nexport const filesFixedCollection: INodeProperties = {\n\tdisplayName: 'Files',\n\tname: 'files',\n\ttype: 'fixedCollection',\n\tplaceholder: 'Add Files',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tdefault: [],\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Input Data Field Name',\n\t\t\t\t\tname: 'inputFieldName',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: 'data',\n\t\t\t\t\tdescription: 'The contents of the file being sent with the message',\n\t\t\t\t\tplaceholder: 'e.g. data',\n\t\t\t\t\thint: 'The name of the input field containing the binary file data to be sent',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const sendToProperties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Send To',\n\t\tname: 'sendTo',\n\t\ttype: 'options',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'User',\n\t\t\t\tvalue: 'user',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Channel',\n\t\t\t\tvalue: 'channel',\n\t\t\t},\n\t\t],\n\t\tdefault: 'channel',\n\t\tdescription: 'Send message to a channel or DM to a user',\n\t},\n\n\t{\n\t\t...userRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tsendTo: ['user'],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t...textChannelRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tsendTo: ['channel'],\n\t\t\t},\n\t\t},\n\t},\n];\n"
      },
      {
        "file": "v2/actions/member/getAll.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { returnAllOrLimit } from '../../../../../utils/descriptions';\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { createSimplifyFunction, parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { simplifyBoolean } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\t...returnAllOrLimit,\n\t{\n\t\tdisplayName: 'After',\n\t\tname: 'after',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tplaceholder: 'e.g. 786953432728469534',\n\t\tdescription: 'The ID of the user after which to return the members',\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [simplifyBoolean],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['member'],\n\t\toperation: ['getAll'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\n\tconst returnAll = this.getNodeParameter('returnAll', 0, false);\n\tconst after = this.getNodeParameter('after', 0);\n\n\tconst qs: IDataObject = {};\n\n\tif (!returnAll) {\n\t\tconst limit = this.getNodeParameter('limit', 0);\n\t\tqs.limit = limit;\n\t}\n\n\tif (after) {\n\t\tqs.after = after;\n\t}\n\n\tlet response: IDataObject[] = [];\n\n\ttry {\n\t\tif (!returnAll) {\n\t\t\tconst limit = this.getNodeParameter('limit', 0);\n\t\t\tqs.limit = limit;\n\t\t\tresponse = await discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'GET',\n\t\t\t\t`/guilds/${guildId}/members`,\n\t\t\t\tundefined,\n\t\t\t\tqs,\n\t\t\t);\n\t\t} else {\n\t\t\tlet responseData;\n\t\t\tqs.limit = 100;\n\n\t\t\tdo {\n\t\t\t\tresponseData = await discordApiRequest.call(\n\t\t\t\t\tthis,\n\t\t\t\t\t'GET',\n\t\t\t\t\t`/guilds/${guildId}/members`,\n\t\t\t\t\tundefined,\n\t\t\t\t\tqs,\n\t\t\t\t);\n\t\t\t\tif (!responseData?.length) break;\n\t\t\t\tqs.after = responseData[responseData.length - 1].user.id;\n\t\t\t\tresponse.push(...responseData);\n\t\t\t} while (responseData.length);\n\t\t}\n\n\t\tconst simplify = this.getNodeParameter('options.simplify', 0, false) as boolean;\n\n\t\tif (simplify) {\n\t\t\tconst simplifyResponse = createSimplifyFunction(['user', 'roles', 'permissions']);\n\n\t\t\tresponse = response.map(simplifyResponse);\n\t\t}\n\n\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t{ itemData: { item: 0 } },\n\t\t);\n\n\t\treturnData.push(...executionData);\n\t} catch (error) {\n\t\tconst err = parseDiscordError.call(this, error);\n\n\t\tif (this.continueOnFail()) {\n\t\t\treturnData.push(...prepareErrorData.call(this, err, 0));\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/member/index.ts",
        "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport * as getAll from './getAll.operation';\nimport * as roleAdd from './roleAdd.operation';\nimport * as roleRemove from './roleRemove.operation';\nimport { guildRLC } from '../common.description';\n\nexport { getAll, roleAdd, roleRemove };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['member'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Get Many',\n\t\t\t\tvalue: 'getAll',\n\t\t\t\tdescription: 'Retrieve the members of a server',\n\t\t\t\taction: 'Get many members',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Role Add',\n\t\t\t\tvalue: 'roleAdd',\n\t\t\t\tdescription: 'Add a role to a member',\n\t\t\t\taction: 'Add a role to a member',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Role Remove',\n\t\t\t\tvalue: 'roleRemove',\n\t\t\t\tdescription: 'Remove a role from a member',\n\t\t\t\taction: 'Remove a role from a member',\n\t\t\t},\n\t\t],\n\t\tdefault: 'getAll',\n\t},\n\t{\n\t\t...guildRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['member'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t},\n\t...getAll.description,\n\t...roleAdd.description,\n\t...roleRemove.description,\n];\n"
      },
      {
        "file": "v2/actions/member/roleAdd.operation.ts",
        "content": "import type { IExecuteFunctions, INodeExecutionData, INodeProperties } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { roleMultiOptions, userRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [userRLC, roleMultiOptions];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['member'],\n\t\toperation: ['roleAdd'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst userId = this.getNodeParameter('userId', i, undefined, {\n\t\t\t\textractValue: true,\n\t\t\t}) as string;\n\n\t\t\tconst roles = this.getNodeParameter('role', i, []) as string[];\n\n\t\t\tfor (const roleId of roles) {\n\t\t\t\tawait discordApiRequest.call(\n\t\t\t\t\tthis,\n\t\t\t\t\t'PUT',\n\t\t\t\t\t`/guilds/${guildId}/members/${userId}/roles/${roleId}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/member/roleRemove.operation.ts",
        "content": "import type { IExecuteFunctions, INodeExecutionData, INodeProperties } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { roleMultiOptions, userRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [userRLC, roleMultiOptions];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['member'],\n\t\toperation: ['roleRemove'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst userId = this.getNodeParameter('userId', i, undefined, {\n\t\t\t\textractValue: true,\n\t\t\t}) as string;\n\n\t\t\tconst roles = this.getNodeParameter('role', i, []) as string[];\n\n\t\t\tfor (const roleId of roles) {\n\t\t\t\tawait discordApiRequest.call(\n\t\t\t\t\tthis,\n\t\t\t\t\t'DELETE',\n\t\t\t\t\t`/guilds/${guildId}/members/${userId}/roles/${roleId}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/message/deleteMessage.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC, messageIdString } from '../common.description';\n\nconst properties: INodeProperties[] = [channelRLC, messageIdString];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['deleteMessage'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst messageId = this.getNodeParameter('messageId', i) as string;\n\n\t\t\tawait discordApiRequest.call(this, 'DELETE', `/channels/${channelId}/messages/${messageId}`);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/message/get.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport {\n\tcreateSimplifyFunction,\n\tparseDiscordError,\n\tprepareErrorData,\n\tsetupChannelGetter,\n} from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC, messageIdString, simplifyBoolean } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\tchannelRLC,\n\tmessageIdString,\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [simplifyBoolean],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['get'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\tconst simplifyResponse = createSimplifyFunction([\n\t\t'id',\n\t\t'channel_id',\n\t\t'author',\n\t\t'content',\n\t\t'timestamp',\n\t\t'type',\n\t]);\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst messageId = this.getNodeParameter('messageId', i) as string;\n\n\t\t\tlet response = await discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'GET',\n\t\t\t\t`/channels/${channelId}/messages/${messageId}`,\n\t\t\t);\n\n\t\t\tconst simplify = this.getNodeParameter('options.simplify', i, false) as boolean;\n\n\t\t\tif (simplify) {\n\t\t\t\tresponse = simplifyResponse(response);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/message/getAll.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { returnAllOrLimit } from '../../../../../utils/descriptions';\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport {\n\tcreateSimplifyFunction,\n\tparseDiscordError,\n\tprepareErrorData,\n\tsetupChannelGetter,\n} from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC, simplifyBoolean } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\tchannelRLC,\n\t...returnAllOrLimit,\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [simplifyBoolean],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['getAll'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\tconst simplifyResponse = createSimplifyFunction([\n\t\t'id',\n\t\t'channel_id',\n\t\t'author',\n\t\t'content',\n\t\t'timestamp',\n\t\t'type',\n\t]);\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst returnAll = this.getNodeParameter('returnAll', i, false);\n\n\t\t\tconst qs: IDataObject = {};\n\n\t\t\tlet response: IDataObject[] = [];\n\n\t\t\tif (!returnAll) {\n\t\t\t\tconst limit = this.getNodeParameter('limit', 0);\n\t\t\t\tqs.limit = limit;\n\t\t\t\tresponse = await discordApiRequest.call(\n\t\t\t\t\tthis,\n\t\t\t\t\t'GET',\n\t\t\t\t\t`/channels/${channelId}/messages`,\n\t\t\t\t\tundefined,\n\t\t\t\t\tqs,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tlet responseData;\n\t\t\t\tqs.limit = 100;\n\n\t\t\t\tdo {\n\t\t\t\t\tresponseData = await discordApiRequest.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\t'GET',\n\t\t\t\t\t\t`/channels/${channelId}/messages`,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tqs,\n\t\t\t\t\t);\n\t\t\t\t\tif (!responseData?.length) break;\n\t\t\t\t\tqs.before = responseData[responseData.length - 1].id;\n\t\t\t\t\tresponse.push(...responseData);\n\t\t\t\t} while (responseData.length);\n\t\t\t}\n\n\t\t\tconst simplify = this.getNodeParameter('options.simplify', i, false) as boolean;\n\n\t\t\tif (simplify) {\n\t\t\t\tresponse = response.map(simplifyResponse);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/message/index.ts",
        "content": "import { SEND_AND_WAIT_OPERATION, type INodeProperties } from 'n8n-workflow';\n\nimport * as deleteMessage from './deleteMessage.operation';\nimport * as get from './get.operation';\nimport * as getAll from './getAll.operation';\nimport * as react from './react.operation';\nimport * as send from './send.operation';\nimport * as sendAndWait from './sendAndWait.operation';\nimport { guildRLC } from '../common.description';\n\nexport { getAll, react, send, deleteMessage, get, sendAndWait };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['message'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Delete',\n\t\t\t\tvalue: 'deleteMessage',\n\t\t\t\tdescription: 'Delete a message in a channel',\n\t\t\t\taction: 'Delete a message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Get',\n\t\t\t\tvalue: 'get',\n\t\t\t\tdescription: 'Get a message in a channel',\n\t\t\t\taction: 'Get a message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Get Many',\n\t\t\t\tvalue: 'getAll',\n\t\t\t\tdescription: 'Retrieve the latest messages in a channel',\n\t\t\t\taction: 'Get many messages',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'React with Emoji',\n\t\t\t\tvalue: 'react',\n\t\t\t\tdescription: 'React to a message with an emoji',\n\t\t\t\taction: 'React with an emoji to a message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Send',\n\t\t\t\tvalue: 'send',\n\t\t\t\tdescription: 'Send a message to a channel, thread, or member',\n\t\t\t\taction: 'Send a message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Send and Wait for Response',\n\t\t\t\tvalue: SEND_AND_WAIT_OPERATION,\n\t\t\t\tdescription: 'Send a message and wait for response',\n\t\t\t\taction: 'Send message and wait for response',\n\t\t\t},\n\t\t],\n\t\tdefault: 'send',\n\t},\n\t{\n\t\t...guildRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['message'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t},\n\t...getAll.description,\n\t...react.description,\n\t...send.description,\n\t...deleteMessage.description,\n\t...get.description,\n\t...sendAndWait.description,\n];\n"
      },
      {
        "file": "v2/actions/message/react.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC, messageIdString } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\tchannelRLC,\n\tmessageIdString,\n\t{\n\t\tdisplayName: 'Emoji',\n\t\tname: 'emoji',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\trequired: true,\n\t\tdescription: 'The emoji you want to react with',\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['react'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst messageId = this.getNodeParameter('messageId', i) as string;\n\t\t\tconst emoji = this.getNodeParameter('emoji', i) as string;\n\n\t\t\tawait discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'PUT',\n\t\t\t\t`/channels/${channelId}/messages/${messageId}/reactions/${encodeURIComponent(emoji)}/@me`,\n\t\t\t);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/message/send.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport {\n\tparseDiscordError,\n\tprepareEmbeds,\n\tprepareErrorData,\n\tprepareOptions,\n\tsendDiscordMessage,\n} from '../../helpers/utils';\nimport {\n\tembedsFixedCollection,\n\tfilesFixedCollection,\n\tsendToProperties,\n} from '../common.description';\n\nconst properties: INodeProperties[] = [\n\t...sendToProperties,\n\t{\n\t\tdisplayName: 'Message',\n\t\tname: 'content',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The content of the message (up to 2000 characters)',\n\t\tplaceholder: 'e.g. My message',\n\t\ttypeOptions: {\n\t\t\trows: 2,\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Flags',\n\t\t\t\tname: 'flags',\n\t\t\t\ttype: 'multiOptions',\n\t\t\t\tdefault: [],\n\t\t\t\tdescription:\n\t\t\t\t\t'Message flags. <a href=\"https://discord.com/developers/docs/resources/channel#message-object-message-flags\" target=\"_blank\">More info</a>.\u201d.',\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Suppress Embeds',\n\t\t\t\t\t\tvalue: 'SUPPRESS_EMBEDS',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Suppress Notifications',\n\t\t\t\t\t\tvalue: 'SUPPRESS_NOTIFICATIONS',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-miscased\n\t\t\t\tdisplayName: 'Message to Reply to',\n\t\t\t\tname: 'message_reference',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'Fill this to make your message a reply. Add the message ID.',\n\t\t\t\tplaceholder: 'e.g. 1059467601836773386',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Text-to-Speech (TTS)',\n\t\t\t\tname: 'tts',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to have a bot reading the message directly in the channel',\n\t\t\t},\n\t\t],\n\t},\n\tembedsFixedCollection,\n\tfilesFixedCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['send'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst content = this.getNodeParameter('content', i) as string;\n\t\tconst options = prepareOptions(this.getNodeParameter('options', i, {}), guildId);\n\n\t\tconst embeds = (this.getNodeParameter('embeds', i, undefined) as IDataObject)\n\t\t\t?.values as IDataObject[];\n\t\tconst files = (this.getNodeParameter('files', i, undefined) as IDataObject)\n\t\t\t?.values as IDataObject[];\n\n\t\tconst body: IDataObject = {\n\t\t\tcontent,\n\t\t\t...options,\n\t\t};\n\n\t\tif (embeds) {\n\t\t\tbody.embeds = prepareEmbeds.call(this, embeds);\n\t\t}\n\n\t\ttry {\n\t\t\treturnData.push(\n\t\t\t\t...(await sendDiscordMessage.call(this, {\n\t\t\t\t\tguildId,\n\t\t\t\t\tuserGuilds,\n\t\t\t\t\tisOAuth2,\n\t\t\t\t\tbody,\n\t\t\t\t\titems,\n\t\t\t\t\tfiles,\n\t\t\t\t\titemIndex: i,\n\t\t\t\t})),\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/actions/message/sendAndWait.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { getSendAndWaitProperties } from '../../../../../utils/sendAndWait/utils';\nimport {\n\tcreateSendAndWaitMessageBody,\n\tparseDiscordError,\n\tprepareErrorData,\n\tsendDiscordMessage,\n} from '../../helpers/utils';\nimport { sendToProperties } from '../common.description';\n\nexport const description: INodeProperties[] = getSendAndWaitProperties(\n\tsendToProperties,\n\t'message',\n\tundefined,\n\t{\n\t\tnoButtonStyle: true,\n\t\tdefaultApproveLabel: '\u2713 Approve',\n\t\tdefaultDisapproveLabel: '\u2717 Decline',\n\t},\n).filter((p) => p.name !== 'subject');\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst items = this.getInputData();\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';\n\n\ttry {\n\t\tawait sendDiscordMessage.call(this, {\n\t\t\tguildId,\n\t\t\tuserGuilds,\n\t\t\tisOAuth2,\n\t\t\tbody: createSendAndWaitMessageBody(this),\n\t\t\titems,\n\t\t});\n\t} catch (error) {\n\t\tconst err = parseDiscordError.call(this, error, 0);\n\n\t\tif (this.continueOnFail()) {\n\t\t\treturn prepareErrorData.call(this, err, 0);\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\treturn items;\n}\n"
      },
      {
        "file": "v2/actions/node.type.ts",
        "content": "import type { AllEntities } from 'n8n-workflow';\n\ntype NodeMap = {\n\tchannel: 'get' | 'getAll' | 'create' | 'update' | 'deleteChannel';\n\tmessage: 'deleteMessage' | 'getAll' | 'get' | 'react' | 'send' | 'sendAndWait';\n\tmember: 'getAll' | 'roleAdd' | 'roleRemove';\n\twebhook: 'sendLegacy';\n};\n\nexport type Discord = AllEntities<NodeMap>;\n"
      },
      {
        "file": "v2/actions/router.ts",
        "content": "import type { IDataObject, IExecuteFunctions, INodeExecutionData } from 'n8n-workflow';\nimport { NodeOperationError, SEND_AND_WAIT_OPERATION } from 'n8n-workflow';\n\nimport * as channel from './channel';\nimport * as member from './member';\nimport * as message from './message';\nimport type { Discord } from './node.type';\nimport * as webhook from './webhook';\nimport { configureWaitTillDate } from '../../../../utils/sendAndWait/configureWaitTillDate.util';\nimport { checkAccessToGuild } from '../helpers/utils';\nimport { discordApiRequest } from '../transport';\n\nexport async function router(this: IExecuteFunctions) {\n\tlet returnData: INodeExecutionData[] = [];\n\n\tlet resource = 'webhook';\n\t//resource parameter is hidden when authentication is set to webhook\n\t//prevent error when getting resource parameter\n\ttry {\n\t\tresource = this.getNodeParameter<Discord>('resource', 0);\n\t} catch (error) {}\n\tconst operation = this.getNodeParameter('operation', 0);\n\n\tlet guildId = '';\n\tlet userGuilds: IDataObject[] = [];\n\n\tif (resource !== 'webhook') {\n\t\tguildId = this.getNodeParameter('guildId', 0, '', {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst isOAuth2 = this.getNodeParameter('authentication', 0, '') === 'oAuth2';\n\n\t\tif (isOAuth2) {\n\t\t\tuserGuilds = (await discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'GET',\n\t\t\t\t'/users/@me/guilds',\n\t\t\t)) as IDataObject[];\n\n\t\t\tcheckAccessToGuild(this.getNode(), guildId, userGuilds);\n\t\t}\n\t}\n\n\tconst discord = {\n\t\tresource,\n\t\toperation,\n\t} as Discord;\n\n\tif (discord.resource === 'message' && discord.operation === SEND_AND_WAIT_OPERATION) {\n\t\treturnData = await message[discord.operation].execute.call(this, guildId, userGuilds);\n\n\t\tconst waitTill = configureWaitTillDate(this);\n\n\t\tawait this.putExecutionToWait(waitTill);\n\t\treturn [returnData];\n\t}\n\n\tswitch (discord.resource) {\n\t\tcase 'channel':\n\t\t\treturnData = await channel[discord.operation].execute.call(this, guildId, userGuilds);\n\t\t\tbreak;\n\t\tcase 'message':\n\t\t\treturnData = await message[discord.operation].execute.call(this, guildId, userGuilds);\n\t\t\tbreak;\n\t\tcase 'member':\n\t\t\treturnData = await member[discord.operation].execute.call(this, guildId);\n\t\t\tbreak;\n\t\tcase 'webhook':\n\t\t\treturnData = await webhook[discord.operation].execute.call(this);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new NodeOperationError(this.getNode(), `The resource \"${resource}\" is not known`);\n\t}\n\n\treturn [returnData];\n}\n"
      },
      {
        "file": "v2/actions/versionDescription.ts",
        "content": "/* eslint-disable n8n-nodes-base/node-filename-against-convention */\nimport { NodeConnectionTypes, type INodeTypeDescription } from 'n8n-workflow';\n\nimport * as channel from './channel';\nimport * as member from './member';\nimport * as message from './message';\nimport * as webhook from './webhook';\nimport { sendAndWaitWebhooksDescription } from '../../../../utils/sendAndWait/descriptions';\n\nexport const versionDescription: INodeTypeDescription = {\n\tdisplayName: 'Discord',\n\tname: 'discord',\n\ticon: 'file:discord.svg',\n\tgroup: ['output'],\n\tversion: 2,\n\tsubtitle: '={{ $parameter[\"operation\"] + \": \" + $parameter[\"resource\"] }}',\n\tdescription: 'Sends data to Discord',\n\tdefaults: {\n\t\tname: 'Discord',\n\t},\n\tinputs: [NodeConnectionTypes.Main],\n\toutputs: [NodeConnectionTypes.Main],\n\twebhooks: sendAndWaitWebhooksDescription,\n\tcredentials: [\n\t\t{\n\t\t\tname: 'discordBotApi',\n\t\t\trequired: true,\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tauthentication: ['botToken'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'discordOAuth2Api',\n\t\t\trequired: true,\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tauthentication: ['oAuth2'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'discordWebhookApi',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tauthentication: ['webhook'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t],\n\tproperties: [\n\t\t{\n\t\t\tdisplayName: 'Connection Type',\n\t\t\tname: 'authentication',\n\t\t\ttype: 'options',\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Bot Token',\n\t\t\t\t\tvalue: 'botToken',\n\t\t\t\t\tdescription: 'Manage messages, channels, and members on a server',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'OAuth2',\n\t\t\t\t\tvalue: 'oAuth2',\n\t\t\t\t\tdescription: \"Same features as 'Bot Token' with easier Bot installation\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Webhook',\n\t\t\t\t\tvalue: 'webhook',\n\t\t\t\t\tdescription: 'Send messages to a specific channel',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'botToken',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Resource',\n\t\t\tname: 'resource',\n\t\t\ttype: 'options',\n\t\t\tnoDataExpression: true,\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Channel',\n\t\t\t\t\tvalue: 'channel',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Message',\n\t\t\t\t\tvalue: 'message',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Member',\n\t\t\t\t\tvalue: 'member',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'channel',\n\t\t\tdisplayOptions: {\n\t\t\t\thide: {\n\t\t\t\t\tauthentication: ['webhook'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\t...message.description,\n\t\t...channel.description,\n\t\t...member.description,\n\t\t...webhook.description,\n\t],\n};\n"
      },
      {
        "file": "v2/actions/webhook/index.ts",
        "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport * as sendLegacy from './sendLegacy.operation';\n\nexport { sendLegacy };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tauthentication: ['webhook'],\n\t\t\t},\n\t\t},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Send a Message',\n\t\t\t\tvalue: 'sendLegacy',\n\t\t\t\tdescription: 'Send a message to a channel using the webhook',\n\t\t\t\taction: 'Send a message',\n\t\t\t},\n\t\t],\n\t\tdefault: 'sendLegacy',\n\t},\n\t...sendLegacy.description,\n];\n"
      },
      {
        "file": "v2/actions/webhook/sendLegacy.operation.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport {\n\tparseDiscordError,\n\tprepareEmbeds,\n\tprepareErrorData,\n\tprepareMultiPartForm,\n\tprepareOptions,\n} from '../../helpers/utils';\nimport { discordApiMultiPartRequest, discordApiRequest } from '../../transport';\nimport { embedsFixedCollection, filesFixedCollection } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Message',\n\t\tname: 'content',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The content of the message (up to 2000 characters)',\n\t\tplaceholder: 'e.g. My message',\n\t\ttypeOptions: {\n\t\t\trows: 2,\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Avatar URL',\n\t\t\t\tname: 'avatar_url',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'Override the default avatar of the webhook',\n\t\t\t\tplaceholder: 'e.g. https://example.com/image.png',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Flags',\n\t\t\t\tname: 'flags',\n\t\t\t\ttype: 'multiOptions',\n\t\t\t\tdefault: [],\n\t\t\t\tdescription:\n\t\t\t\t\t'Message flags. <a href=\"https://discord.com/developers/docs/resources/channel#message-object-message-flags\" target=\"_blank\">More info</a>.\u201d.',\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Suppress Embeds',\n\t\t\t\t\t\tvalue: 'SUPPRESS_EMBEDS',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Suppress Notifications',\n\t\t\t\t\t\tvalue: 'SUPPRESS_NOTIFICATIONS',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Text-to-Speech (TTS)',\n\t\t\t\tname: 'tts',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to have a bot reading the message directly in the channel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Username',\n\t\t\t\tname: 'username',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'Override the default username of the webhook',\n\t\t\t\tplaceholder: 'e.g. My Username',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Wait',\n\t\t\t\tname: 'wait',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether wait for the message to be created before returning its response',\n\t\t\t},\n\t\t],\n\t},\n\tembedsFixedCollection,\n\tfilesFixedCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\toperation: ['sendLegacy'],\n\t},\n\thide: {\n\t\tauthentication: ['botToken', 'oAuth2'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(this: IExecuteFunctions): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst content = this.getNodeParameter('content', i) as string;\n\t\tconst options = prepareOptions(this.getNodeParameter('options', i, {}));\n\n\t\tconst embeds = (this.getNodeParameter('embeds', i, undefined) as IDataObject)\n\t\t\t?.values as IDataObject[];\n\t\tconst files = (this.getNodeParameter('files', i, undefined) as IDataObject)\n\t\t\t?.values as IDataObject[];\n\n\t\tlet qs: IDataObject | undefined = undefined;\n\n\t\tif (options.wait) {\n\t\t\tqs = {\n\t\t\t\twait: options.wait,\n\t\t\t};\n\n\t\t\tdelete options.wait;\n\t\t}\n\n\t\tconst body: IDataObject = {\n\t\t\tcontent,\n\t\t\t...options,\n\t\t};\n\n\t\tif (embeds) {\n\t\t\tbody.embeds = prepareEmbeds.call(this, embeds);\n\t\t}\n\n\t\ttry {\n\t\t\tlet response: IDataObject[] = [];\n\n\t\t\tif (files?.length) {\n\t\t\t\tconst multiPartBody = await prepareMultiPartForm.call(this, items, files, body, i);\n\n\t\t\t\tresponse = await discordApiMultiPartRequest.call(this, 'POST', '', multiPartBody);\n\t\t\t} else {\n\t\t\t\tresponse = await discordApiRequest.call(this, 'POST', '', body, qs);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
      },
      {
        "file": "v2/helpers/utils.ts",
        "content": "import FormData from 'form-data';\nimport isEmpty from 'lodash/isEmpty';\nimport { extension } from 'mime-types';\nimport type {\n\tIBinaryKeyData,\n\tIDataObject,\n\tIExecuteFunctions,\n\tINode,\n\tINodeExecutionData,\n} from 'n8n-workflow';\nimport { jsonParse, NodeApiError, NodeOperationError } from 'n8n-workflow';\n\nimport { getSendAndWaitConfig } from '../../../../utils/sendAndWait/utils';\nimport { capitalize, createUtmCampaignLink } from '../../../../utils/utilities';\nimport { discordApiMultiPartRequest, discordApiRequest } from '../transport';\n\nexport const createSimplifyFunction =\n\t(includedFields: string[]) =>\n\t(item: IDataObject): IDataObject => {\n\t\tconst result: IDataObject = {};\n\n\t\tfor (const field of includedFields) {\n\t\t\tif (item[field] === undefined) continue;\n\n\t\t\tresult[field] = item[field];\n\t\t}\n\n\t\treturn result;\n\t};\n\nexport function parseDiscordError(this: IExecuteFunctions, error: any, itemIndex = 0) {\n\tlet errorData = error.cause.error;\n\tconst errorOptions: IDataObject = { itemIndex };\n\n\tif (!errorData && error.description) {\n\t\ttry {\n\t\t\tconst errorString = (error.description as string).split(' - ')[1];\n\t\t\tif (errorString) {\n\t\t\t\terrorData = jsonParse(errorString);\n\t\t\t}\n\t\t} catch (err) {}\n\t}\n\n\tif (errorData?.message) {\n\t\terrorOptions.message = errorData.message;\n\t}\n\n\tif ((error?.message as string)?.toLowerCase()?.includes('bad request') && errorData) {\n\t\tif (errorData?.message) {\n\t\t\terrorOptions.message = errorData.message;\n\t\t}\n\n\t\tif (errorData?.errors?.embeds) {\n\t\t\tconst embedErrors = errorData.errors.embeds?.[0];\n\t\t\tconst embedErrorsKeys = Object.keys(embedErrors).map((key) => capitalize(key));\n\n\t\t\tif (embedErrorsKeys.length) {\n\t\t\t\tconst message =\n\t\t\t\t\tembedErrorsKeys.length === 1\n\t\t\t\t\t\t? `The parameter ${embedErrorsKeys[0]} is not properly formatted`\n\t\t\t\t\t\t: `The parameters ${embedErrorsKeys.join(', ')} are not properly formatted`;\n\t\t\t\terrorOptions.message = message;\n\t\t\t\terrorOptions.description = 'Review the formatting or clear it';\n\t\t\t}\n\n\t\t\treturn new NodeOperationError(this.getNode(), errorData.errors, errorOptions);\n\t\t}\n\n\t\tif (errorData?.errors?.message_reference) {\n\t\t\terrorOptions.message = \"The message to reply to ID can't be found\";\n\t\t\terrorOptions.description =\n\t\t\t\t'Check the \"Message to Reply to\" parameter and remove it if you don\\'t want to reply to an existing message';\n\n\t\t\treturn new NodeOperationError(this.getNode(), errorData.errors, errorOptions);\n\t\t}\n\n\t\tif (errorOptions.message === 'Cannot send an empty message') {\n\t\t\terrorOptions.description =\n\t\t\t\t'Something has to be send to the channel whether it is a message, an embed or a file';\n\t\t}\n\t}\n\treturn new NodeOperationError(this.getNode(), errorData || error, errorOptions);\n}\n\nexport function prepareErrorData(this: IExecuteFunctions, error: any, i: number) {\n\tlet description = error.description;\n\n\ttry {\n\t\tdescription = JSON.parse(error.description as string);\n\t} catch (err) {}\n\n\treturn this.helpers.constructExecutionMetaData(\n\t\tthis.helpers.returnJsonArray({ error: error.message, description }),\n\t\t{ itemData: { item: i } },\n\t);\n}\n\nexport function prepareOptions(options: IDataObject, guildId?: string) {\n\tif (options.flags) {\n\t\tif ((options.flags as string[]).length === 2) {\n\t\t\toptions.flags = (1 << 2) + (1 << 12);\n\t\t} else if ((options.flags as string[]).includes('SUPPRESS_EMBEDS')) {\n\t\t\toptions.flags = 1 << 2;\n\t\t} else if ((options.flags as string[]).includes('SUPPRESS_NOTIFICATIONS')) {\n\t\t\toptions.flags = 1 << 12;\n\t\t}\n\t}\n\n\tif (options.message_reference) {\n\t\toptions.message_reference = {\n\t\t\tmessage_id: options.message_reference,\n\t\t\tguild_id: guildId,\n\t\t};\n\t}\n\n\treturn options;\n}\n\nexport function prepareEmbeds(this: IExecuteFunctions, embeds: IDataObject[]) {\n\treturn embeds\n\t\t.map((embed) => {\n\t\t\tlet embedReturnData: IDataObject = {};\n\n\t\t\tif (embed.inputMethod === 'json') {\n\t\t\t\tif (typeof embed.json === 'object') {\n\t\t\t\t\tembedReturnData = embed.json as IDataObject;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tembedReturnData = jsonParse(embed.json as string);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Not a valid JSON', error);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdelete embed.inputMethod;\n\n\t\t\t\tfor (const key of Object.keys(embed)) {\n\t\t\t\t\tif (embed[key] !== '') {\n\t\t\t\t\t\tembedReturnData[key] = embed[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (embedReturnData.author) {\n\t\t\t\tembedReturnData.author = {\n\t\t\t\t\tname: embedReturnData.author,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (embedReturnData.color && typeof embedReturnData.color === 'string') {\n\t\t\t\tembedReturnData.color = parseInt(embedReturnData.color.replace('#', ''), 16);\n\t\t\t}\n\t\t\tif (embedReturnData.video) {\n\t\t\t\tembedReturnData.video = {\n\t\t\t\t\turl: embedReturnData.video,\n\t\t\t\t\twidth: 1270,\n\t\t\t\t\theight: 720,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (embedReturnData.thumbnail) {\n\t\t\t\tembedReturnData.thumbnail = {\n\t\t\t\t\turl: embedReturnData.thumbnail,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (embedReturnData.image) {\n\t\t\t\tembedReturnData.image = {\n\t\t\t\t\turl: embedReturnData.image,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn embedReturnData;\n\t\t})\n\t\t.filter((embed) => !isEmpty(embed));\n}\n\nexport async function prepareMultiPartForm(\n\tthis: IExecuteFunctions,\n\titems: INodeExecutionData[],\n\tfiles: IDataObject[],\n\tjsonPayload: IDataObject,\n\ti: number,\n) {\n\tconst multiPartBody = new FormData();\n\tconst attachments: IDataObject[] = [];\n\tconst filesData: IDataObject[] = [];\n\n\tfor (const [index, file] of files.entries()) {\n\t\tconst binaryData = (items[i].binary as IBinaryKeyData)?.[file.inputFieldName as string];\n\n\t\tif (!binaryData) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t`Input item [${i}] does not contain binary data on property ${file.inputFieldName}`,\n\t\t\t);\n\t\t}\n\n\t\tlet filename = binaryData.fileName as string;\n\n\t\tif (!filename.includes('.')) {\n\t\t\tif (binaryData.fileExtension) {\n\t\t\t\tfilename += `.${binaryData.fileExtension}`;\n\t\t\t}\n\t\t\tif (binaryData.mimeType) {\n\t\t\t\tfilename += `.${extension(binaryData.mimeType)}`;\n\t\t\t}\n\t\t}\n\n\t\tattachments.push({\n\t\t\tid: index,\n\t\t\tfilename,\n\t\t});\n\n\t\tfilesData.push({\n\t\t\tdata: await this.helpers.getBinaryDataBuffer(i, file.inputFieldName as string),\n\t\t\tname: filename,\n\t\t\tmime: binaryData.mimeType,\n\t\t});\n\t}\n\n\tmultiPartBody.append('payload_json', JSON.stringify({ ...jsonPayload, attachments }), {\n\t\tcontentType: 'application/json',\n\t});\n\n\tfor (const [index, binaryData] of filesData.entries()) {\n\t\tmultiPartBody.append(`files[${index}]`, binaryData.data, {\n\t\t\tcontentType: binaryData.name as string,\n\t\t\tfilename: binaryData.mime as string,\n\t\t});\n\t}\n\n\treturn multiPartBody;\n}\n\nexport function checkAccessToGuild(\n\tnode: INode,\n\tguildId: string,\n\tuserGuilds: IDataObject[],\n\titemIndex = 0,\n) {\n\tif (!userGuilds.some((guild) => guild.id === guildId)) {\n\t\tthrow new NodeOperationError(\n\t\t\tnode,\n\t\t\t`You do not have access to the guild with the id ${guildId}`,\n\t\t\t{\n\t\t\t\titemIndex,\n\t\t\t\tlevel: 'warning',\n\t\t\t},\n\t\t);\n\t}\n}\n\nexport async function checkAccessToChannel(\n\tthis: IExecuteFunctions,\n\tchannelId: string,\n\tuserGuilds: IDataObject[],\n\titemIndex = 0,\n) {\n\tlet guildId = '';\n\n\ttry {\n\t\tconst channel = await discordApiRequest.call(this, 'GET', `/channels/${channelId}`);\n\t\tguildId = channel.guild_id;\n\t} catch (error) {}\n\n\tif (!guildId) {\n\t\tthrow new NodeOperationError(\n\t\t\tthis.getNode(),\n\t\t\t`Could not find server for channel with the id ${channelId}`,\n\t\t\t{\n\t\t\t\titemIndex,\n\t\t\t},\n\t\t);\n\t}\n\n\tcheckAccessToGuild(this.getNode(), guildId, userGuilds, itemIndex);\n}\n\nexport async function setupChannelGetter(this: IExecuteFunctions, userGuilds: IDataObject[]) {\n\tconst isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';\n\n\treturn async (i: number) => {\n\t\tconst channelId = this.getNodeParameter('channelId', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tif (isOAuth2) await checkAccessToChannel.call(this, channelId, userGuilds, i);\n\n\t\treturn channelId;\n\t};\n}\n\nexport async function sendDiscordMessage(\n\tthis: IExecuteFunctions,\n\t{\n\t\tguildId,\n\t\tuserGuilds,\n\t\tisOAuth2,\n\t\tbody,\n\t\titems,\n\t\tfiles = [],\n\t\titemIndex = 0,\n\t}: {\n\t\tguildId: string;\n\t\tuserGuilds: IDataObject[];\n\t\tisOAuth2: boolean;\n\t\tbody: IDataObject;\n\t\titems: INodeExecutionData[];\n\t\tfiles?: IDataObject[];\n\t\titemIndex?: number;\n\t},\n) {\n\tconst sendTo = this.getNodeParameter('sendTo', itemIndex) as string;\n\n\tlet channelId = '';\n\n\tif (sendTo === 'user') {\n\t\tconst userId = this.getNodeParameter('userId', itemIndex, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tif (isOAuth2) {\n\t\t\ttry {\n\t\t\t\tawait discordApiRequest.call(this, 'GET', `/guilds/${guildId}/members/${userId}`);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof NodeApiError && error.httpCode === '404') {\n\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t\t`User with the id ${userId} is not a member of the selected guild`,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthrow new NodeOperationError(this.getNode(), error, {\n\t\t\t\t\titemIndex,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tchannelId = (\n\t\t\t(await discordApiRequest.call(this, 'POST', '/users/@me/channels', {\n\t\t\t\trecipient_id: userId,\n\t\t\t})) as IDataObject\n\t\t).id as string;\n\n\t\tif (!channelId) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t'Could not create a channel to send direct message to',\n\t\t\t\t{ itemIndex },\n\t\t\t);\n\t\t}\n\t}\n\n\tif (sendTo === 'channel') {\n\t\tchannelId = this.getNodeParameter('channelId', itemIndex, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\t}\n\n\tif (isOAuth2 && sendTo !== 'user') {\n\t\tawait checkAccessToChannel.call(this, channelId, userGuilds, itemIndex);\n\t}\n\n\tif (!channelId) {\n\t\tthrow new NodeOperationError(this.getNode(), 'Channel ID is required', {\n\t\t\titemIndex,\n\t\t});\n\t}\n\n\tlet response: IDataObject[] = [];\n\n\tif (files?.length) {\n\t\tconst multiPartBody = await prepareMultiPartForm.call(this, items, files, body, itemIndex);\n\n\t\tresponse = await discordApiMultiPartRequest.call(\n\t\t\tthis,\n\t\t\t'POST',\n\t\t\t`/channels/${channelId}/messages`,\n\t\t\tmultiPartBody,\n\t\t);\n\t} else {\n\t\tresponse = await discordApiRequest.call(this, 'POST', `/channels/${channelId}/messages`, body);\n\t}\n\n\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\tthis.helpers.returnJsonArray(response),\n\t\t{ itemData: { item: itemIndex } },\n\t);\n\n\treturn executionData;\n}\n\nexport function createSendAndWaitMessageBody(context: IExecuteFunctions) {\n\tconst config = getSendAndWaitConfig(context);\n\tlet description = config.message;\n\tif (config.appendAttribution !== false) {\n\t\tconst instanceId = context.getInstanceId();\n\t\tconst attributionText = 'This message was sent automatically with ';\n\t\tconst link = createUtmCampaignLink('n8n-nodes-base.discord', instanceId);\n\t\tdescription = `${config.message}\\n\\n_${attributionText}_[n8n](${link})`;\n\t}\n\n\tconst body = {\n\t\tembeds: [\n\t\t\t{\n\t\t\t\tdescription,\n\t\t\t\tcolor: 5814783,\n\t\t\t},\n\t\t],\n\t\tcomponents: [\n\t\t\t{\n\t\t\t\ttype: 1,\n\t\t\t\tcomponents: config.options.map((option) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 2,\n\t\t\t\t\t\tstyle: 5,\n\t\t\t\t\t\tlabel: option.label,\n\t\t\t\t\t\turl: option.url,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t},\n\t\t],\n\t};\n\n\treturn body;\n}\n"
      },
      {
        "file": "v2/methods/index.ts",
        "content": "export * as listSearch from './listSearch';\nexport * as loadOptions from './loadOptions';\n"
      },
      {
        "file": "v2/methods/listSearch.ts",
        "content": "import {\n\ttype IDataObject,\n\ttype ILoadOptionsFunctions,\n\ttype INodeListSearchResult,\n} from 'n8n-workflow';\n\nimport { checkAccessToGuild } from '../helpers/utils';\nimport { discordApiRequest } from '../transport';\n\nasync function getGuildId(this: ILoadOptionsFunctions) {\n\tconst guildId = this.getNodeParameter('guildId', undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', '') === 'oAuth2';\n\n\tif (isOAuth2) {\n\t\tconst userGuilds = (await discordApiRequest.call(\n\t\t\tthis,\n\t\t\t'GET',\n\t\t\t'/users/@me/guilds',\n\t\t)) as IDataObject[];\n\n\t\tcheckAccessToGuild(this.getNode(), guildId, userGuilds);\n\t}\n\n\treturn guildId;\n}\n\nasync function checkBotAccessToGuild(this: ILoadOptionsFunctions, guildId: string, botId: string) {\n\ttry {\n\t\tconst members: Array<{ user: { id: string } }> = await discordApiRequest.call(\n\t\t\tthis,\n\t\t\t'GET',\n\t\t\t`/guilds/${guildId}/members`,\n\t\t\tundefined,\n\t\t\t{ limit: 1000 },\n\t\t);\n\n\t\treturn members.some((member) => member.user.id === botId);\n\t} catch (error) {}\n\n\treturn false;\n}\n\nexport async function guildSearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst response = (await discordApiRequest.call(\n\t\tthis,\n\t\t'GET',\n\t\t'/users/@me/guilds',\n\t)) as IDataObject[];\n\n\tlet guilds: IDataObject[] = [];\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';\n\n\tif (isOAuth2) {\n\t\tconst botId = (await discordApiRequest.call(this, 'GET', '/users/@me')).id as string;\n\n\t\tfor (const guild of response) {\n\t\t\tif (!(await checkBotAccessToGuild.call(this, guild.id as string, botId))) continue;\n\t\t\tguilds.push(guild);\n\t\t}\n\t} else {\n\t\tguilds = response;\n\t}\n\n\treturn {\n\t\tresults: guilds.map((guild) => ({\n\t\t\tname: guild.name as string,\n\t\t\tvalue: guild.id as string,\n\t\t\turl: `https://discord.com/channels/${guild.id}`,\n\t\t})),\n\t};\n}\n\nexport async function channelSearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst guildId = await getGuildId.call(this);\n\tconst response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/channels`);\n\n\treturn {\n\t\tresults: (response as IDataObject[])\n\t\t\t.filter((cannel) => cannel.type !== 4) // Filter out categories\n\t\t\t.map((channel) => ({\n\t\t\t\tname: channel.name as string,\n\t\t\t\tvalue: channel.id as string,\n\t\t\t\turl: `https://discord.com/channels/${guildId}/${channel.id}`,\n\t\t\t})),\n\t};\n}\n\nexport async function textChannelSearch(\n\tthis: ILoadOptionsFunctions,\n): Promise<INodeListSearchResult> {\n\tconst guildId = await getGuildId.call(this);\n\n\tconst response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/channels`);\n\n\treturn {\n\t\tresults: (response as IDataObject[])\n\t\t\t.filter((cannel) => ![2, 4].includes(cannel.type as number)) // Only text channels\n\t\t\t.map((channel) => ({\n\t\t\t\tname: channel.name as string,\n\t\t\t\tvalue: channel.id as string,\n\t\t\t\turl: `https://discord.com/channels/${guildId}/${channel.id}`,\n\t\t\t})),\n\t};\n}\n\nexport async function categorySearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst guildId = await getGuildId.call(this);\n\n\tconst response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/channels`);\n\n\treturn {\n\t\tresults: (response as IDataObject[])\n\t\t\t.filter((cannel) => cannel.type === 4) // Return only categories\n\t\t\t.map((channel) => ({\n\t\t\t\tname: channel.name as string,\n\t\t\t\tvalue: channel.id as string,\n\t\t\t\turl: `https://discord.com/channels/${guildId}/${channel.id}`,\n\t\t\t})),\n\t};\n}\n\nexport async function userSearch(\n\tthis: ILoadOptionsFunctions,\n\t_filter?: string,\n\tpaginationToken?: string,\n): Promise<INodeListSearchResult> {\n\tconst guildId = await getGuildId.call(this);\n\n\tconst limit = 100;\n\tconst qs = { limit, after: paginationToken };\n\n\tconst response = await discordApiRequest.call(\n\t\tthis,\n\t\t'GET',\n\t\t`/guilds/${guildId}/members`,\n\t\tundefined,\n\t\tqs,\n\t);\n\n\tif (response.length === 0) {\n\t\treturn {\n\t\t\tresults: [],\n\t\t\tpaginationToken: undefined,\n\t\t};\n\t}\n\n\tlet lastUserId;\n\n\t//less then limit means that there are no more users to return, so leave lastUserId undefined\n\tif (!(response.length < limit)) {\n\t\tlastUserId = response[response.length - 1].user.id as string;\n\t}\n\n\treturn {\n\t\tresults: (response as Array<{ user: IDataObject }>).map(({ user }) => ({\n\t\t\tname: user.username as string,\n\t\t\tvalue: user.id as string,\n\t\t})),\n\t\tpaginationToken: lastUserId,\n\t};\n}\n"
      },
      {
        "file": "v2/methods/loadOptions.ts",
        "content": "import type { IDataObject, ILoadOptionsFunctions, INodePropertyOptions } from 'n8n-workflow';\n\nimport { checkAccessToGuild } from '../helpers/utils';\nimport { discordApiRequest } from '../transport';\n\nexport async function getRoles(this: ILoadOptionsFunctions): Promise<INodePropertyOptions[]> {\n\tconst guildId = this.getNodeParameter('guildId', undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', '') === 'oAuth2';\n\n\tif (isOAuth2) {\n\t\tconst userGuilds = (await discordApiRequest.call(\n\t\t\tthis,\n\t\t\t'GET',\n\t\t\t'/users/@me/guilds',\n\t\t)) as IDataObject[];\n\n\t\tcheckAccessToGuild(this.getNode(), guildId, userGuilds);\n\t}\n\n\tlet response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/roles`);\n\n\tconst operations = this.getNodeParameter('operation') as string;\n\n\tif (operations === 'roleRemove') {\n\t\tconst userId = this.getNodeParameter('userId', undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst userRoles = ((\n\t\t\tawait discordApiRequest.call(this, 'GET', `/guilds/${guildId}/members/${userId}`)\n\t\t).roles || []) as string[];\n\n\t\tresponse = response.filter((role: IDataObject) => {\n\t\t\treturn userRoles.includes(role.id as string);\n\t\t});\n\t}\n\n\treturn response\n\t\t.filter((role: IDataObject) => role.name !== '@everyone' && !role.managed)\n\t\t.map((role: IDataObject) => ({\n\t\t\tname: role.name as string,\n\t\t\tvalue: role.id as string,\n\t\t}));\n}\n"
      },
      {
        "file": "v2/transport/discord.api.ts",
        "content": "import type FormData from 'form-data';\nimport type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tIExecuteSingleFunctions,\n\tIHookFunctions,\n\tIHttpRequestMethods,\n\tILoadOptionsFunctions,\n\tIRequestOptions,\n} from 'n8n-workflow';\nimport { sleep, NodeApiError, jsonParse } from 'n8n-workflow';\n\nimport { getCredentialsType, requestApi } from './helpers';\n\nexport async function discordApiRequest(\n\tthis: IHookFunctions | IExecuteFunctions | IExecuteSingleFunctions | ILoadOptionsFunctions,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tbody?: IDataObject,\n\tqs?: IDataObject,\n) {\n\tconst authentication = this.getNodeParameter('authentication', 0, 'webhook') as string;\n\tconst headers: IDataObject = {};\n\n\tconst credentialType = getCredentialsType(authentication);\n\n\tconst options: IRequestOptions = {\n\t\theaders,\n\t\tmethod,\n\t\tqs,\n\t\tbody,\n\t\turl: `https://discord.com/api/v10${endpoint}`,\n\t\tjson: true,\n\t};\n\n\tif (credentialType === 'discordWebhookApi') {\n\t\tconst credentials = await this.getCredentials('discordWebhookApi');\n\t\toptions.url = credentials.webhookUri as string;\n\t}\n\n\ttry {\n\t\tconst response = await requestApi.call(this, options, credentialType, endpoint);\n\n\t\tconst resetAfter = Number(response.headers['x-ratelimit-reset-after']);\n\t\tconst remaining = Number(response.headers['x-ratelimit-remaining']);\n\n\t\tif (remaining === 0) {\n\t\t\tawait sleep(resetAfter);\n\t\t} else {\n\t\t\tawait sleep(20); //prevent exceeding global rate limit of 50 requests per second\n\t\t}\n\n\t\treturn response.body || { success: true };\n\t} catch (error) {\n\t\tthrow new NodeApiError(this.getNode(), error);\n\t}\n}\n\nexport async function discordApiMultiPartRequest(\n\tthis: IHookFunctions | IExecuteFunctions | IExecuteSingleFunctions | ILoadOptionsFunctions,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tformData: FormData,\n) {\n\tconst headers: IDataObject = {\n\t\t'content-type': 'multipart/form-data; charset=utf-8',\n\t};\n\tconst authentication = this.getNodeParameter('authentication', 0, 'webhook') as string;\n\n\tconst credentialType = getCredentialsType(authentication);\n\n\tconst options: IRequestOptions = {\n\t\theaders,\n\t\tmethod,\n\t\tformData,\n\t\turl: `https://discord.com/api/v10${endpoint}`,\n\t};\n\n\tif (credentialType === 'discordWebhookApi') {\n\t\tconst credentials = await this.getCredentials('discordWebhookApi');\n\t\toptions.url = credentials.webhookUri as string;\n\t}\n\n\ttry {\n\t\tconst response = await requestApi.call(this, options, credentialType, endpoint);\n\n\t\tconst resetAfter = Number(response.headers['x-ratelimit-reset-after']);\n\t\tconst remaining = Number(response.headers['x-ratelimit-remaining']);\n\n\t\tif (remaining === 0) {\n\t\t\tawait sleep(resetAfter);\n\t\t} else {\n\t\t\tawait sleep(20); //prevent exceeding global rate limit of 50 requests per second\n\t\t}\n\n\t\treturn jsonParse<IDataObject[]>(response.body);\n\t} catch (error) {\n\t\tthrow new NodeApiError(this.getNode(), error);\n\t}\n}\n"
      },
      {
        "file": "v2/transport/helpers.ts",
        "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tIExecuteSingleFunctions,\n\tIHookFunctions,\n\tILoadOptionsFunctions,\n\tIRequestOptions,\n} from 'n8n-workflow';\n\nexport const getCredentialsType = (authentication: string) => {\n\tlet credentialType = '';\n\tswitch (authentication) {\n\t\tcase 'botToken':\n\t\t\tcredentialType = 'discordBotApi';\n\t\t\tbreak;\n\t\tcase 'oAuth2':\n\t\t\tcredentialType = 'discordOAuth2Api';\n\t\t\tbreak;\n\t\tcase 'webhook':\n\t\t\tcredentialType = 'discordWebhookApi';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcredentialType = 'discordBotApi';\n\t}\n\treturn credentialType;\n};\n\nexport async function requestApi(\n\tthis: IHookFunctions | IExecuteFunctions | IExecuteSingleFunctions | ILoadOptionsFunctions,\n\toptions: IRequestOptions,\n\tcredentialType: string,\n\tendpoint: string,\n) {\n\tlet response;\n\tif (credentialType === 'discordOAuth2Api' && endpoint !== '/users/@me/guilds') {\n\t\tconst credentials = await this.getCredentials('discordOAuth2Api');\n\t\t(options.headers as IDataObject).Authorization = `Bot ${credentials.botToken}`;\n\t\tresponse = await this.helpers.request({ ...options, resolveWithFullResponse: true });\n\t} else {\n\t\tresponse = await this.helpers.requestWithAuthentication.call(this, credentialType, {\n\t\t\t...options,\n\t\t\tresolveWithFullResponse: true,\n\t\t});\n\t}\n\treturn response;\n}\n"
      },
      {
        "file": "v2/transport/index.ts",
        "content": "export * from './discord.api';\nexport * from './helpers';\n"
      }
    ]
  },
  "metadata": {
    "fetch_time": "2026-01-06T04:51:05.553905+00:00",
    "source_type": "TYPE1",
    "source_path": "input_sources/discord",
    "file_count": 50,
    "content_hash": "a31752750c0ad872"
  }
}