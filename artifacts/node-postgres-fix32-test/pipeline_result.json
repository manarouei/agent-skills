{
  "pipeline_name": "type1-convert",
  "correlation_id": "node-postgres-fix32-test",
  "status": "blocked",
  "started_at": "2026-01-07T08:26:09.396390",
  "completed_at": "2026-01-07T08:26:10.020118",
  "duration_ms": 623,
  "steps": [
    {
      "step_name": "ingest",
      "skill_name": "source-ingest",
      "status": "completed",
      "started_at": "2026-01-07T08:26:09.396699",
      "completed_at": "2026-01-07T08:26:09.408404",
      "duration_ms": 11,
      "outputs": {
        "raw_content": "// === File: PostgresV2.node.ts ===\nimport type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\n\nimport { router } from './actions/router';\nimport { versionDescription } from './actions/versionDescription';\nimport { credentialTest, listSearch, loadOptions, resourceMapping } from './methods';\n\nexport class PostgresV2 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t};\n\t}\n\n\tmethods = { credentialTest, listSearch, loadOptions, resourceMapping };\n\n\tasync execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {\n\t\treturn await router.call(this);\n\t}\n}\n\n\n// === File: actions/common.descriptions.ts ===\nimport type { INodeProperties } from 'n8n-workflow';\n\nexport const optionsCollection: INodeProperties = {\n\tdisplayName: 'Options',\n\tname: 'options',\n\ttype: 'collection',\n\tplaceholder: 'Add option',\n\tdefault: {},\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Cascade',\n\t\t\tname: 'cascade',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription:\n\t\t\t\t'Whether to drop all objects that depend on the table, such as views and sequences',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\t'/operation': ['deleteTable'],\n\t\t\t\t},\n\t\t\t\thide: {\n\t\t\t\t\t'/deleteCommand': ['delete'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Connection Timeout',\n\t\t\tname: 'connectionTimeout',\n\t\t\ttype: 'number',\n\t\t\tdefault: 30,\n\t\t\tdescription: 'Number of seconds reserved for connecting to the database',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Delay Closing Idle Connection',\n\t\t\tname: 'delayClosingIdleConnection',\n\t\t\ttype: 'number',\n\t\t\tdefault: 0,\n\t\t\tdescription: 'Number of seconds to wait before idle connection would be eligible for closing',\n\t\t\ttypeOptions: {\n\t\t\t\tminValue: 0,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Query Batching',\n\t\t\tname: 'queryBatching',\n\t\t\ttype: 'options',\n\t\t\tnoDataExpression: true,\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Single Query',\n\t\t\t\t\tvalue: 'single',\n\t\t\t\t\tdescription: 'A single query for all incoming items',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Independent',\n\t\t\t\t\tvalue: 'independently',\n\t\t\t\t\tdescription: 'Execute one query per incoming item of the run',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Transaction',\n\t\t\t\t\tvalue: 'transaction',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Execute all queries in a transaction, if a failure occurs, all changes are rolled back',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'single',\n\t\t\tdescription: 'The way queries should be sent to the database',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Query Parameters',\n\t\t\tname: 'queryReplacement',\n\t\t\ttype: 'string',\n\t\t\tdefault: '',\n\t\t\tdescription:\n\t\t\t\t'Comma-separated list of the values you want to use as query parameters. <a href=\"https://docs.n8n.io/integrations/builtin/app-nodes/n8n-nodes-base.postgres/#use-query-parameters\" target=\"_blank\">More info</a>.',\n\t\t\thint: 'Comma-separated list of values: reference them in your query as $1, $2, $3…',\n\t\t\tplaceholder: 'e.g. value1,value2,value3',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: { '/operation': ['executeQuery'] },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-miscased\n\t\t\tdisplayName: 'Treat query parameters in single quotes as text',\n\t\t\tname: 'treatQueryParametersInSingleQuotesAsText',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription: \"Whether to treat query parameters enclosed in single quotes as text e.g. '$1'\",\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: { queryReplacement: [{ _cnd: { exists: true } }] },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-multi-options\n\t\t\tdisplayName: 'Output Columns',\n\t\t\tname: 'outputColumns',\n\t\t\ttype: 'multiOptions',\n\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-multi-options\n\t\t\tdescription:\n\t\t\t\t'Choose from the list, or specify IDs using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\ttypeOptions: {\n\t\t\t\tloadOptionsMethod: 'getColumnsMultiOptions',\n\t\t\t\tloadOptionsDependsOn: ['table.value'],\n\t\t\t},\n\t\t\tdefault: [],\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: { '/operation': ['select', 'insert', 'update', 'upsert'] },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Output Large-Format Numbers As',\n\t\t\tname: 'largeNumbersOutput',\n\t\t\ttype: 'options',\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Numbers',\n\t\t\t\t\tvalue: 'numbers',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Text',\n\t\t\t\t\tvalue: 'text',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Use this if you expect numbers longer than 16 digits (otherwise numbers may be incorrect)',\n\t\t\t\t},\n\t\t\t],\n\t\t\thint: 'Applies to NUMERIC and BIGINT columns only',\n\t\t\tdefault: 'text',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Skip on Conflict',\n\t\t\tname: 'skipOnConflict',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription:\n\t\t\t\t'Whether to skip the row and do not throw error if a unique constraint or exclusion constraint is violated',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\t'/operation': ['insert'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Replace Empty Strings with NULL',\n\t\t\tname: 'replaceEmptyStrings',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription:\n\t\t\t\t'Whether to replace empty strings with NULL in input, could be useful when data come from spreadsheet',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\t'/operation': ['insert', 'update', 'upsert', 'executeQuery'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t],\n};\n\nexport const schemaRLC: INodeProperties = {\n\tdisplayName: 'Schema',\n\tname: 'schema',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: 'public' },\n\trequired: true,\n\tplaceholder: 'e.g. public',\n\tdescription: 'The schema that contains the table you want to work on',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'From List',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'schemaSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'name',\n\t\t\ttype: 'string',\n\t\t},\n\t],\n};\n\nexport const tableRLC: INodeProperties = {\n\tdisplayName: 'Table',\n\tname: 'table',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'The table you want to work on',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'From List',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'tableSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'name',\n\t\t\ttype: 'string',\n\t\t},\n\t],\n};\n\nexport const whereFixedCollection: INodeProperties = {\n\tdisplayName: 'Select Rows',\n\tname: 'where',\n\ttype: 'fixedCollection',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tplaceholder: 'Add Condition',\n\tdefault: {},\n\tdescription: 'If not set, all rows will be selected',\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\tname: 'column',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\tplaceholder: 'e.g. ID',\n\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Operator',\n\t\t\t\t\tname: 'condition',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"The operator to check the column against. When using 'LIKE' operator percent sign ( %) matches zero or more characters, underscore ( _ ) matches any single character.\",\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-options-type-unsorted-items\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Equal',\n\t\t\t\t\t\t\tvalue: 'equal',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Not Equal',\n\t\t\t\t\t\t\tvalue: '!=',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Like',\n\t\t\t\t\t\t\tvalue: 'LIKE',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Greater Than',\n\t\t\t\t\t\t\tvalue: '>',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Less Than',\n\t\t\t\t\t\t\tvalue: '<',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Greater Than Or Equal',\n\t\t\t\t\t\t\tvalue: '>=',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Less Than Or Equal',\n\t\t\t\t\t\t\tvalue: '<=',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Is Null',\n\t\t\t\t\t\t\tvalue: 'IS NULL',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Is Not Null',\n\t\t\t\t\t\t\tvalue: 'IS NOT NULL',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'equal',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\tname: 'value',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdisplayOptions: {\n\t\t\t\t\t\thide: {\n\t\t\t\t\t\t\tcondition: ['IS NULL', 'IS NOT NULL'],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const sortFixedCollection: INodeProperties = {\n\tdisplayName: 'Sort',\n\tname: 'sort',\n\ttype: 'fixedCollection',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tplaceholder: 'Add Sort Rule',\n\tdefault: {},\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\tname: 'column',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Direction',\n\t\t\t\t\tname: 'direction',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'ASC',\n\t\t\t\t\t\t\tvalue: 'ASC',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'DESC',\n\t\t\t\t\t\t\tvalue: 'DESC',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'ASC',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const combineConditionsCollection: INodeProperties = {\n\tdisplayName: 'Combine Conditions',\n\tname: 'combineConditions',\n\ttype: 'options',\n\tdescription:\n\t\t'How to combine the conditions defined in \"Select Rows\": AND requires all conditions to be true, OR requires at least one condition to be true',\n\toptions: [\n\t\t{\n\t\t\tname: 'AND',\n\t\t\tvalue: 'AND',\n\t\t\tdescription: 'Only rows that meet all the conditions are selected',\n\t\t},\n\t\t{\n\t\t\tname: 'OR',\n\t\t\tvalu",
        "parsed_sections": {
          "class_name": "PostgresV2",
          "node_type": "options",
          "version": null,
          "description": null,
          "properties": [],
          "methods": [
            "execute"
          ],
          "credentials": [
            "postgresConnectionTest"
          ],
          "resources": [
            "database",
            "event"
          ],
          "has_router": true,
          "files": [
            "PostgresV2.node.ts",
            "actions/common.descriptions.ts",
            "actions/database/Database.resource.ts",
            "actions/database/deleteTable.operation.ts",
            "actions/database/executeQuery.operation.ts",
            "actions/database/insert.operation.ts",
            "actions/database/select.operation.ts",
            "actions/database/update.operation.ts",
            "actions/database/upsert.operation.ts",
            "actions/node.type.ts",
            "actions/router.ts",
            "actions/versionDescription.ts",
            "helpers/interfaces.ts",
            "helpers/utils.ts",
            "methods/credentialTest.ts",
            "methods/index.ts",
            "methods/listSearch.ts",
            "methods/loadOptions.ts",
            "methods/resourceMapping.ts"
          ],
          "code": [
            {
              "file": "PostgresV2.node.ts",
              "content": "import type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\n\nimport { router } from './actions/router';\nimport { versionDescription } from './actions/versionDescription';\nimport { credentialTest, listSearch, loadOptions, resourceMapping } from './methods';\n\nexport class PostgresV2 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t};\n\t}\n\n\tmethods = { credentialTest, listSearch, loadOptions, resourceMapping };\n\n\tasync execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {\n\t\treturn await router.call(this);\n\t}\n}\n"
            },
            {
              "file": "actions/common.descriptions.ts",
              "content": "import type { INodeProperties } from 'n8n-workflow';\n\nexport const optionsCollection: INodeProperties = {\n\tdisplayName: 'Options',\n\tname: 'options',\n\ttype: 'collection',\n\tplaceholder: 'Add option',\n\tdefault: {},\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Cascade',\n\t\t\tname: 'cascade',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription:\n\t\t\t\t'Whether to drop all objects that depend on the table, such as views and sequences',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\t'/operation': ['deleteTable'],\n\t\t\t\t},\n\t\t\t\thide: {\n\t\t\t\t\t'/deleteCommand': ['delete'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Connection Timeout',\n\t\t\tname: 'connectionTimeout',\n\t\t\ttype: 'number',\n\t\t\tdefault: 30,\n\t\t\tdescription: 'Number of seconds reserved for connecting to the database',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Delay Closing Idle Connection',\n\t\t\tname: 'delayClosingIdleConnection',\n\t\t\ttype: 'number',\n\t\t\tdefault: 0,\n\t\t\tdescription: 'Number of seconds to wait before idle connection would be eligible for closing',\n\t\t\ttypeOptions: {\n\t\t\t\tminValue: 0,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Query Batching',\n\t\t\tname: 'queryBatching',\n\t\t\ttype: 'options',\n\t\t\tnoDataExpression: true,\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Single Query',\n\t\t\t\t\tvalue: 'single',\n\t\t\t\t\tdescription: 'A single query for all incoming items',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Independent',\n\t\t\t\t\tvalue: 'independently',\n\t\t\t\t\tdescription: 'Execute one query per incoming item of the run',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Transaction',\n\t\t\t\t\tvalue: 'transaction',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Execute all queries in a transaction, if a failure occurs, all changes are rolled back',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'single',\n\t\t\tdescription: 'The way queries should be sent to the database',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Query Parameters',\n\t\t\tname: 'queryReplacement',\n\t\t\ttype: 'string',\n\t\t\tdefault: '',\n\t\t\tdescription:\n\t\t\t\t'Comma-separated list of the values you want to use as query parameters. <a href=\"https://docs.n8n.io/integrations/builtin/app-nodes/n8n-nodes-base.postgres/#use-query-parameters\" target=\"_blank\">More info</a>.',\n\t\t\thint: 'Comma-separated list of values: reference them in your query as $1, $2, $3…',\n\t\t\tplaceholder: 'e.g. value1,value2,value3',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: { '/operation': ['executeQuery'] },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-miscased\n\t\t\tdisplayName: 'Treat query parameters in single quotes as text',\n\t\t\tname: 'treatQueryParametersInSingleQuotesAsText',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription: \"Whether to treat query parameters enclosed in single quotes as text e.g. '$1'\",\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: { queryReplacement: [{ _cnd: { exists: true } }] },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-multi-options\n\t\t\tdisplayName: 'Output Columns',\n\t\t\tname: 'outputColumns',\n\t\t\ttype: 'multiOptions',\n\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-multi-options\n\t\t\tdescription:\n\t\t\t\t'Choose from the list, or specify IDs using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\ttypeOptions: {\n\t\t\t\tloadOptionsMethod: 'getColumnsMultiOptions',\n\t\t\t\tloadOptionsDependsOn: ['table.value'],\n\t\t\t},\n\t\t\tdefault: [],\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: { '/operation': ['select', 'insert', 'update', 'upsert'] },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Output Large-Format Numbers As',\n\t\t\tname: 'largeNumbersOutput',\n\t\t\ttype: 'options',\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Numbers',\n\t\t\t\t\tvalue: 'numbers',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Text',\n\t\t\t\t\tvalue: 'text',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Use this if you expect numbers longer than 16 digits (otherwise numbers may be incorrect)',\n\t\t\t\t},\n\t\t\t],\n\t\t\thint: 'Applies to NUMERIC and BIGINT columns only',\n\t\t\tdefault: 'text',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Skip on Conflict',\n\t\t\tname: 'skipOnConflict',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription:\n\t\t\t\t'Whether to skip the row and do not throw error if a unique constraint or exclusion constraint is violated',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\t'/operation': ['insert'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Replace Empty Strings with NULL',\n\t\t\tname: 'replaceEmptyStrings',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription:\n\t\t\t\t'Whether to replace empty strings with NULL in input, could be useful when data come from spreadsheet',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\t'/operation': ['insert', 'update', 'upsert', 'executeQuery'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t],\n};\n\nexport const schemaRLC: INodeProperties = {\n\tdisplayName: 'Schema',\n\tname: 'schema',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: 'public' },\n\trequired: true,\n\tplaceholder: 'e.g. public',\n\tdescription: 'The schema that contains the table you want to work on',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'From List',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'schemaSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'name',\n\t\t\ttype: 'string',\n\t\t},\n\t],\n};\n\nexport const tableRLC: INodeProperties = {\n\tdisplayName: 'Table',\n\tname: 'table',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'The table you want to work on',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'From List',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'tableSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'name',\n\t\t\ttype: 'string',\n\t\t},\n\t],\n};\n\nexport const whereFixedCollection: INodeProperties = {\n\tdisplayName: 'Select Rows',\n\tname: 'where',\n\ttype: 'fixedCollection',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tplaceholder: 'Add Condition',\n\tdefault: {},\n\tdescription: 'If not set, all rows will be selected',\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\tname: 'column',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\tplaceholder: 'e.g. ID',\n\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Operator',\n\t\t\t\t\tname: 'condition',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"The operator to check the column against. When using 'LIKE' operator percent sign ( %) matches zero or more characters, underscore ( _ ) matches any single character.\",\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-options-type-unsorted-items\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Equal',\n\t\t\t\t\t\t\tvalue: 'equal',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Not Equal',\n\t\t\t\t\t\t\tvalue: '!=',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Like',\n\t\t\t\t\t\t\tvalue: 'LIKE',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Greater Than',\n\t\t\t\t\t\t\tvalue: '>',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Less Than',\n\t\t\t\t\t\t\tvalue: '<',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Greater Than Or Equal',\n\t\t\t\t\t\t\tvalue: '>=',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Less Than Or Equal',\n\t\t\t\t\t\t\tvalue: '<=',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Is Null',\n\t\t\t\t\t\t\tvalue: 'IS NULL',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Is Not Null',\n\t\t\t\t\t\t\tvalue: 'IS NOT NULL',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'equal',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\tname: 'value',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdisplayOptions: {\n\t\t\t\t\t\thide: {\n\t\t\t\t\t\t\tcondition: ['IS NULL', 'IS NOT NULL'],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const sortFixedCollection: INodeProperties = {\n\tdisplayName: 'Sort',\n\tname: 'sort',\n\ttype: 'fixedCollection',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tplaceholder: 'Add Sort Rule',\n\tdefault: {},\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\tname: 'column',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Direction',\n\t\t\t\t\tname: 'direction',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'ASC',\n\t\t\t\t\t\t\tvalue: 'ASC',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'DESC',\n\t\t\t\t\t\t\tvalue: 'DESC',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'ASC',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const combineConditionsCollection: INodeProperties = {\n\tdisplayName: 'Combine Conditions',\n\tname: 'combineConditions',\n\ttype: 'options',\n\tdescription:\n\t\t'How to combine the conditions defined in \"Select Rows\": AND requires all conditions to be true, OR requires at least one condition to be true',\n\toptions: [\n\t\t{\n\t\t\tname: 'AND',\n\t\t\tvalue: 'AND',\n\t\t\tdescription: 'Only rows that meet all the conditions are selected',\n\t\t},\n\t\t{\n\t\t\tname: 'OR',\n\t\t\tvalue: 'OR',\n\t\t\tdescription: 'Rows that meet at least one condition are selected',\n\t\t},\n\t],\n\tdefault: 'AND',\n};\n"
            },
            {
              "file": "actions/database/Database.resource.ts",
              "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport * as deleteTable from './deleteTable.operation';\nimport * as executeQuery from './executeQuery.operation';\nimport * as insert from './insert.operation';\nimport * as select from './select.operation';\nimport * as update from './update.operation';\nimport * as upsert from './upsert.operation';\nimport { schemaRLC, tableRLC } from '../common.descriptions';\n\nexport { deleteTable, executeQuery, insert, select, update, upsert };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Delete',\n\t\t\t\tvalue: 'deleteTable',\n\t\t\t\tdescription: 'Delete an entire table or rows in a table',\n\t\t\t\taction: 'Delete table or rows',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Execute Query',\n\t\t\t\tvalue: 'executeQuery',\n\t\t\t\tdescription: 'Execute an SQL query',\n\t\t\t\taction: 'Execute a SQL query',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Insert',\n\t\t\t\tvalue: 'insert',\n\t\t\t\tdescription: 'Insert rows in a table',\n\t\t\t\taction: 'Insert rows in a table',\n\t\t\t},\n\t\t\t{\n\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-option-name-wrong-for-upsert\n\t\t\t\tname: 'Insert or Update',\n\t\t\t\tvalue: 'upsert',\n\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-upsert\n\t\t\t\tdescription: 'Insert or update rows in a table',\n\t\t\t\taction: 'Insert or update rows in a table',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Select',\n\t\t\t\tvalue: 'select',\n\t\t\t\tdescription: 'Select rows from a table',\n\t\t\t\taction: 'Select rows from a table',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Update',\n\t\t\t\tvalue: 'update',\n\t\t\t\tdescription: 'Update rows in a table',\n\t\t\t\taction: 'Update rows in a table',\n\t\t\t},\n\t\t],\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['database'],\n\t\t\t},\n\t\t},\n\t\tdefault: 'insert',\n\t},\n\t{ ...schemaRLC, displayOptions: { hide: { operation: ['executeQuery'] } } },\n\t{ ...tableRLC, displayOptions: { hide: { operation: ['executeQuery'] } } },\n\t...deleteTable.description,\n\t...executeQuery.description,\n\t...insert.description,\n\t...select.description,\n\t...update.description,\n\t...upsert.description,\n];\n"
            },
            {
              "file": "actions/database/deleteTable.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '@utils/utilities';\n\nimport type {\n\tPgpDatabase,\n\tPostgresNodeOptions,\n\tQueriesRunner,\n\tQueryValues,\n\tQueryWithValues,\n\tWhereClause,\n} from '../../helpers/interfaces';\nimport { addWhereClauses } from '../../helpers/utils';\nimport {\n\tcombineConditionsCollection,\n\toptionsCollection,\n\twhereFixedCollection,\n} from '../common.descriptions';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Command',\n\t\tname: 'deleteCommand',\n\t\ttype: 'options',\n\t\tdefault: 'truncate',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Truncate',\n\t\t\t\tvalue: 'truncate',\n\t\t\t\tdescription: \"Only removes the table's data and preserves the table's structure\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Delete',\n\t\t\t\tvalue: 'delete',\n\t\t\t\tdescription:\n\t\t\t\t\t\"Delete the rows that match the 'Select Rows' conditions below. If no selection is made, all rows in the table are deleted.\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Drop',\n\t\t\t\tvalue: 'drop',\n\t\t\t\tdescription: \"Deletes the table's data and also the table's structure permanently\",\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tdisplayName: 'Restart Sequences',\n\t\tname: 'restartSequences',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tdescription: 'Whether to reset identity (auto-increment) columns to their initial values',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdeleteCommand: ['truncate'],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t...whereFixedCollection,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdeleteCommand: ['delete'],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t...combineConditionsCollection,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdeleteCommand: ['delete'],\n\t\t\t},\n\t\t},\n\t},\n\toptionsCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['database'],\n\t\toperation: ['deleteTable'],\n\t},\n\thide: {\n\t\ttable: [''],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\trunQueries: QueriesRunner,\n\titems: INodeExecutionData[],\n\tnodeOptions: PostgresNodeOptions,\n\t_db?: PgpDatabase,\n): Promise<INodeExecutionData[]> {\n\tconst queries: QueryWithValues[] = [];\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst options = this.getNodeParameter('options', i, {});\n\n\t\tconst schema = this.getNodeParameter('schema', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst table = this.getNodeParameter('table', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst deleteCommand = this.getNodeParameter('deleteCommand', i) as string;\n\n\t\tlet query = '';\n\t\tlet values: QueryValues = [schema, table];\n\n\t\tif (deleteCommand === 'drop') {\n\t\t\tconst cascade = options.cascade ? ' CASCADE' : '';\n\t\t\tquery = `DROP TABLE IF EXISTS $1:name.$2:name${cascade}`;\n\t\t}\n\n\t\tif (deleteCommand === 'truncate') {\n\t\t\tconst identity = this.getNodeParameter('restartSequences', i, false)\n\t\t\t\t? ' RESTART IDENTITY'\n\t\t\t\t: '';\n\t\t\tconst cascade = options.cascade ? ' CASCADE' : '';\n\t\t\tquery = `TRUNCATE TABLE $1:name.$2:name${identity}${cascade}`;\n\t\t}\n\n\t\tif (deleteCommand === 'delete') {\n\t\t\tconst whereClauses =\n\t\t\t\t((this.getNodeParameter('where', i, []) as IDataObject).values as WhereClause[]) || [];\n\n\t\t\tconst combineConditions = this.getNodeParameter('combineConditions', i, 'AND') as string;\n\n\t\t\t[query, values] = addWhereClauses(\n\t\t\t\tthis.getNode(),\n\t\t\t\ti,\n\t\t\t\t'DELETE FROM $1:name.$2:name',\n\t\t\t\twhereClauses,\n\t\t\t\tvalues,\n\t\t\t\tcombineConditions,\n\t\t\t);\n\t\t}\n\n\t\tif (query === '') {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t'Invalid delete command, only drop, delete and truncate are supported ',\n\t\t\t\t{ itemIndex: i },\n\t\t\t);\n\t\t}\n\n\t\tconst queryWithValues = { query, values };\n\n\t\tqueries.push(queryWithValues);\n\t}\n\n\treturn await runQueries(queries, items, nodeOptions);\n}\n"
            },
            {
              "file": "actions/database/executeQuery.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport { getResolvables, updateDisplayOptions } from '@utils/utilities';\n\nimport type {\n\tPgpDatabase,\n\tPostgresNodeOptions,\n\tQueriesRunner,\n\tQueryWithValues,\n} from '../../helpers/interfaces';\nimport {\n\tevaluateExpression,\n\tisJSON,\n\treplaceEmptyStringsByNulls,\n\tstringToArray,\n} from '../../helpers/utils';\nimport { optionsCollection } from '../common.descriptions';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Query',\n\t\tname: 'query',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tplaceholder: 'e.g. SELECT id, name FROM product WHERE quantity > $1 AND price <= $2',\n\t\tnoDataExpression: true,\n\t\trequired: true,\n\t\tdescription:\n\t\t\t\"The SQL query to execute. You can use n8n expressions and $1, $2, $3, etc to refer to the 'Query Parameters' set in options below.\",\n\t\ttypeOptions: {\n\t\t\teditor: 'sqlEditor',\n\t\t\tsqlDialect: 'PostgreSQL',\n\t\t},\n\t\thint: 'Consider using query parameters to prevent SQL injection attacks. Add them in the options below',\n\t},\n\toptionsCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['database'],\n\t\toperation: ['executeQuery'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\trunQueries: QueriesRunner,\n\titems: INodeExecutionData[],\n\tnodeOptions: PostgresNodeOptions,\n\t_db?: PgpDatabase,\n): Promise<INodeExecutionData[]> {\n\tconst queries: QueryWithValues[] = replaceEmptyStringsByNulls(\n\t\titems,\n\t\tnodeOptions.replaceEmptyStrings as boolean,\n\t).map((_, index) => {\n\t\tlet query = this.getNodeParameter('query', index) as string;\n\n\t\tfor (const resolvable of getResolvables(query)) {\n\t\t\tquery = query.replace(resolvable, this.evaluateExpression(resolvable, index) as string);\n\t\t}\n\n\t\tlet values: Array<IDataObject | string> = [];\n\n\t\tlet queryReplacement = this.getNodeParameter('options.queryReplacement', index, '');\n\n\t\tif (typeof queryReplacement === 'number') {\n\t\t\tqueryReplacement = String(queryReplacement);\n\t\t}\n\n\t\tif (typeof queryReplacement === 'string') {\n\t\t\tconst node = this.getNode();\n\n\t\t\tconst rawReplacements = (node.parameters.options as IDataObject)?.queryReplacement as string;\n\n\t\t\tif (rawReplacements) {\n\t\t\t\tconst nodeVersion = nodeOptions.nodeVersion as number;\n\n\t\t\t\tif (nodeVersion >= 2.5) {\n\t\t\t\t\tconst rawValues = rawReplacements.replace(/^=+/, '');\n\t\t\t\t\tconst resolvables = getResolvables(rawValues);\n\t\t\t\t\tif (resolvables.length) {\n\t\t\t\t\t\tfor (const resolvable of resolvables) {\n\t\t\t\t\t\t\tconst evaluatedExpression = evaluateExpression(\n\t\t\t\t\t\t\t\tthis.evaluateExpression(`${resolvable}`, index),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst evaluatedValues = isJSON(evaluatedExpression)\n\t\t\t\t\t\t\t\t? [evaluatedExpression]\n\t\t\t\t\t\t\t\t: stringToArray(evaluatedExpression);\n\n\t\t\t\t\t\t\tif (evaluatedValues.length) values.push(...evaluatedValues);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalues.push(...stringToArray(rawValues));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst rawValues = rawReplacements\n\t\t\t\t\t\t.replace(/^=+/, '')\n\t\t\t\t\t\t.split(',')\n\t\t\t\t\t\t.filter((entry) => entry)\n\t\t\t\t\t\t.map((entry) => entry.trim());\n\n\t\t\t\t\tfor (const rawValue of rawValues) {\n\t\t\t\t\t\tconst resolvables = getResolvables(rawValue);\n\n\t\t\t\t\t\tif (resolvables.length) {\n\t\t\t\t\t\t\tfor (const resolvable of resolvables) {\n\t\t\t\t\t\t\t\tvalues.push(this.evaluateExpression(`${resolvable}`, index) as IDataObject);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalues.push(rawValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (Array.isArray(queryReplacement)) {\n\t\t\t\tvalues = queryReplacement as IDataObject[];\n\t\t\t} else {\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t'Query Parameters must be a string of comma-separated values or an array of values',\n\t\t\t\t\t{ itemIndex: index },\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (!queryReplacement || nodeOptions.treatQueryParametersInSingleQuotesAsText) {\n\t\t\tlet nextValueIndex = values.length + 1;\n\t\t\tconst literals = query.match(/'\\$[0-9]+'/g) ?? [];\n\t\t\tfor (const literal of literals) {\n\t\t\t\tquery = query.replace(literal, `$${nextValueIndex}`);\n\t\t\t\tvalues.push(literal.replace(/'/g, ''));\n\t\t\t\tnextValueIndex++;\n\t\t\t}\n\t\t}\n\n\t\treturn { query, values, options: { partial: true } };\n\t});\n\n\treturn await runQueries(queries, items, nodeOptions);\n}\n"
            },
            {
              "file": "actions/database/insert.operation.ts",
              "content": "import {\n\ttype IDataObject,\n\ttype IExecuteFunctions,\n\ttype INodeExecutionData,\n\ttype INodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '@utils/utilities';\n\nimport type {\n\tPgpClient,\n\tPgpDatabase,\n\tPostgresNodeOptions,\n\tQueriesRunner,\n\tQueryValues,\n\tQueryWithValues,\n} from '../../helpers/interfaces';\nimport {\n\taddReturning,\n\tcheckItemAgainstSchema,\n\tconfigureTableSchemaUpdater,\n\tgetTableSchema,\n\tprepareItem,\n\tconvertArraysToPostgresFormat,\n\treplaceEmptyStringsByNulls,\n\thasJsonDataTypeInSchema,\n\tconvertValuesToJsonWithPgp,\n} from '../../helpers/utils';\nimport { optionsCollection } from '../common.descriptions';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Data Mode',\n\t\tname: 'dataMode',\n\t\ttype: 'options',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Auto-Map Input Data to Columns',\n\t\t\t\tvalue: 'autoMapInputData',\n\t\t\t\tdescription: 'Use when node input properties names exactly match the table column names',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Map Each Column Manually',\n\t\t\t\tvalue: 'defineBelow',\n\t\t\t\tdescription: 'Set the value for each destination column manually',\n\t\t\t},\n\t\t],\n\t\tdefault: 'autoMapInputData',\n\t\tdescription:\n\t\t\t'Whether to map node input properties and the table data automatically or manually',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: `\n\t\tIn this mode, make sure incoming data fields are named the same as the columns in your table. If needed, use an 'Edit Fields' node before this node to change the field names.\n\t\t`,\n\t\tname: 'notice',\n\t\ttype: 'notice',\n\t\tdefault: '',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['autoMapInputData'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Values to Send',\n\t\tname: 'valuesToSend',\n\t\tplaceholder: 'Add Value',\n\t\ttype: 'fixedCollection',\n\t\ttypeOptions: {\n\t\t\tmultipleValueButtonText: 'Add Value',\n\t\t\tmultipleValues: true,\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['defineBelow'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Values',\n\t\t\t\tname: 'values',\n\t\t\t\tvalues: [\n\t\t\t\t\t{\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\t\tname: 'column',\n\t\t\t\t\t\ttype: 'options',\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdefault: [],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\t\tname: 'value',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tdisplayName: 'Columns',\n\t\tname: 'columns',\n\t\ttype: 'resourceMapper',\n\t\tdefault: {\n\t\t\tmappingMode: 'defineBelow',\n\t\t\tvalue: null,\n\t\t},\n\t\tnoDataExpression: true,\n\t\trequired: true,\n\t\ttypeOptions: {\n\t\t\tloadOptionsDependsOn: ['table.value', 'operation'],\n\t\t\tresourceMapper: {\n\t\t\t\tresourceMapperMethod: 'getMappingColumns',\n\t\t\t\tmode: 'add',\n\t\t\t\tfieldWords: {\n\t\t\t\t\tsingular: 'column',\n\t\t\t\t\tplural: 'columns',\n\t\t\t\t},\n\t\t\t\taddAllFields: true,\n\t\t\t\tmultiKeyMatch: true,\n\t\t\t},\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [{ _cnd: { gte: 2.2 } }],\n\t\t\t},\n\t\t},\n\t},\n\toptionsCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['database'],\n\t\toperation: ['insert'],\n\t},\n\thide: {\n\t\ttable: [''],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\trunQueries: QueriesRunner,\n\titems: INodeExecutionData[],\n\tnodeOptions: PostgresNodeOptions,\n\tdb: PgpDatabase,\n\tpgp: PgpClient,\n): Promise<INodeExecutionData[]> {\n\titems = replaceEmptyStringsByNulls(items, nodeOptions.replaceEmptyStrings as boolean);\n\tconst nodeVersion = nodeOptions.nodeVersion as number;\n\n\tlet schema = this.getNodeParameter('schema', 0, undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tlet table = this.getNodeParameter('table', 0, undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst updateTableSchema = configureTableSchemaUpdater(schema, table);\n\n\tlet tableSchema = await getTableSchema(db, schema, table);\n\n\tconst queries: QueryWithValues[] = [];\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tschema = this.getNodeParameter('schema', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\ttable = this.getNodeParameter('table', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst options = this.getNodeParameter('options', i, {});\n\n\t\tlet onConflict = '';\n\t\tif (options.skipOnConflict) {\n\t\t\tonConflict = ' ON CONFLICT DO NOTHING';\n\t\t}\n\n\t\tlet query = `INSERT INTO $1:name.$2:name($3:name) VALUES($3:csv)${onConflict}`;\n\t\tlet values: QueryValues = [schema, table];\n\n\t\tconst dataMode =\n\t\t\tnodeVersion < 2.2\n\t\t\t\t? (this.getNodeParameter('dataMode', i) as string)\n\t\t\t\t: (this.getNodeParameter('columns.mappingMode', i) as string);\n\n\t\tlet item: IDataObject = {};\n\n\t\tif (dataMode === 'autoMapInputData') {\n\t\t\titem = items[i].json;\n\t\t}\n\n\t\tif (dataMode === 'defineBelow') {\n\t\t\tconst valuesToSend =\n\t\t\t\tnodeVersion < 2.2\n\t\t\t\t\t? ((this.getNodeParameter('valuesToSend', i, []) as IDataObject).values as IDataObject[])\n\t\t\t\t\t: ((this.getNodeParameter('columns.values', i, []) as IDataObject)\n\t\t\t\t\t\t\t.values as IDataObject[]);\n\n\t\t\titem =\n\t\t\t\tnodeVersion < 2.2\n\t\t\t\t\t? prepareItem(valuesToSend)\n\t\t\t\t\t: hasJsonDataTypeInSchema(tableSchema)\n\t\t\t\t\t\t? convertValuesToJsonWithPgp(\n\t\t\t\t\t\t\t\tpgp,\n\t\t\t\t\t\t\t\ttableSchema,\n\t\t\t\t\t\t\t\t(this.getNodeParameter('columns', i) as IDataObject)?.value as IDataObject,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: (this.getNodeParameter('columns.value', i) as IDataObject);\n\t\t}\n\n\t\ttableSchema = await updateTableSchema(db, tableSchema, schema, table);\n\n\t\tif (nodeVersion >= 2.4) {\n\t\t\tconvertArraysToPostgresFormat(item, tableSchema, this.getNode(), i);\n\t\t}\n\n\t\tvalues.push(checkItemAgainstSchema(this.getNode(), item, tableSchema, i));\n\n\t\tconst outputColumns = this.getNodeParameter('options.outputColumns', i, ['*']) as string[];\n\n\t\tif (nodeVersion >= 2.6 && Object.keys(item).length === 0) {\n\t\t\tquery = 'INSERT INTO $1:name.$2:name DEFAULT VALUES';\n\t\t}\n\n\t\t[query, values] = addReturning(query, outputColumns, values);\n\n\t\tqueries.push({ query, values });\n\t}\n\n\treturn await runQueries(queries, items, nodeOptions);\n}\n"
            },
            {
              "file": "actions/database/select.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '@utils/utilities';\n\nimport type {\n\tPgpDatabase,\n\tPostgresNodeOptions,\n\tQueriesRunner,\n\tQueryValues,\n\tQueryWithValues,\n\tSortRule,\n\tWhereClause,\n} from '../../helpers/interfaces';\nimport { addSortRules, addWhereClauses, replaceEmptyStringsByNulls } from '../../helpers/utils';\nimport {\n\tcombineConditionsCollection,\n\toptionsCollection,\n\tsortFixedCollection,\n\twhereFixedCollection,\n} from '../common.descriptions';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Return All',\n\t\tname: 'returnAll',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tdescription: 'Whether to return all results or only up to a given limit',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['event'],\n\t\t\t\toperation: ['getAll'],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Limit',\n\t\tname: 'limit',\n\t\ttype: 'number',\n\t\tdefault: 50,\n\t\tdescription: 'Max number of results to return',\n\t\ttypeOptions: {\n\t\t\tminValue: 1,\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\treturnAll: [false],\n\t\t\t},\n\t\t},\n\t},\n\twhereFixedCollection,\n\tcombineConditionsCollection,\n\tsortFixedCollection,\n\toptionsCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['database'],\n\t\toperation: ['select'],\n\t},\n\thide: {\n\t\ttable: [''],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\trunQueries: QueriesRunner,\n\titems: INodeExecutionData[],\n\tnodeOptions: PostgresNodeOptions,\n\t_db?: PgpDatabase,\n): Promise<INodeExecutionData[]> {\n\titems = replaceEmptyStringsByNulls(items, nodeOptions.replaceEmptyStrings as boolean);\n\n\tconst queries: QueryWithValues[] = [];\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst schema = this.getNodeParameter('schema', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst table = this.getNodeParameter('table', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tlet values: QueryValues = [schema, table];\n\n\t\tconst outputColumns = this.getNodeParameter('options.outputColumns', i, ['*']) as string[];\n\n\t\tlet query = '';\n\n\t\tif (outputColumns.includes('*')) {\n\t\t\tquery = 'SELECT * FROM $1:name.$2:name';\n\t\t} else {\n\t\t\tvalues.push(outputColumns);\n\t\t\tquery = `SELECT $${values.length}:name FROM $1:name.$2:name`;\n\t\t}\n\n\t\tconst whereClauses =\n\t\t\t((this.getNodeParameter('where', i, []) as IDataObject).values as WhereClause[]) || [];\n\n\t\tconst combineConditions = this.getNodeParameter('combineConditions', i, 'AND') as string;\n\n\t\t[query, values] = addWhereClauses(\n\t\t\tthis.getNode(),\n\t\t\ti,\n\t\t\tquery,\n\t\t\twhereClauses,\n\t\t\tvalues,\n\t\t\tcombineConditions,\n\t\t);\n\n\t\tconst sortRules =\n\t\t\t((this.getNodeParameter('sort', i, []) as IDataObject).values as SortRule[]) || [];\n\n\t\t[query, values] = addSortRules(query, sortRules, values);\n\n\t\tconst returnAll = this.getNodeParameter('returnAll', i, false);\n\t\tif (!returnAll) {\n\t\t\tconst limit = this.getNodeParameter('limit', i, 50);\n\t\t\tquery += ` LIMIT ${limit}`;\n\t\t}\n\n\t\tconst queryWithValues = { query, values };\n\t\tqueries.push(queryWithValues);\n\t}\n\n\treturn await runQueries(queries, items, nodeOptions);\n}\n"
            },
            {
              "file": "actions/database/update.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '@utils/utilities';\n\nimport type {\n\tPgpDatabase,\n\tPostgresNodeOptions,\n\tQueriesRunner,\n\tQueryValues,\n\tQueryWithValues,\n} from '../../helpers/interfaces';\nimport {\n\taddReturning,\n\tcheckItemAgainstSchema,\n\tconfigureTableSchemaUpdater,\n\tdoesRowExist,\n\tgetTableSchema,\n\tprepareItem,\n\tconvertArraysToPostgresFormat,\n\treplaceEmptyStringsByNulls,\n} from '../../helpers/utils';\nimport { optionsCollection } from '../common.descriptions';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Data Mode',\n\t\tname: 'dataMode',\n\t\ttype: 'options',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Auto-Map Input Data to Columns',\n\t\t\t\tvalue: 'autoMapInputData',\n\t\t\t\tdescription: 'Use when node input properties names exactly match the table column names',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Map Each Column Manually',\n\t\t\t\tvalue: 'defineBelow',\n\t\t\t\tdescription: 'Set the value for each destination column manually',\n\t\t\t},\n\t\t],\n\t\tdefault: 'autoMapInputData',\n\t\tdescription:\n\t\t\t'Whether to map node input properties and the table data automatically or manually',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: `\n\t\tIn this mode, make sure incoming data fields are named the same as the columns in your table. If needed, use an 'Edit Fields' node before this node to change the field names.\n\t\t`,\n\t\tname: 'notice',\n\t\ttype: 'notice',\n\t\tdefault: '',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['autoMapInputData'],\n\t\t\t\t'@version': [2],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\tdisplayName: 'Column to Match On',\n\t\tname: 'columnToMatchOn',\n\t\ttype: 'options',\n\t\trequired: true,\n\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\tdescription:\n\t\t\t'The column to compare when finding the rows to update. Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>.',\n\t\ttypeOptions: {\n\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t},\n\t\tdefault: '',\n\t\thint: 'The column to use when matching rows in Postgres to the input items of this node. Usually an ID.',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Value of Column to Match On',\n\t\tname: 'valueToMatchOn',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription:\n\t\t\t'Rows with a value in the specified \"Column to Match On\" that corresponds to the value in this field will be updated',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['defineBelow'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Values to Send',\n\t\tname: 'valuesToSend',\n\t\tplaceholder: 'Add Value',\n\t\ttype: 'fixedCollection',\n\t\ttypeOptions: {\n\t\t\tmultipleValueButtonText: 'Add Value',\n\t\t\tmultipleValues: true,\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['defineBelow'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Values',\n\t\t\t\tname: 'values',\n\t\t\t\tvalues: [\n\t\t\t\t\t{\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\t\tname: 'column',\n\t\t\t\t\t\ttype: 'options',\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\t\tloadOptionsMethod: 'getColumnsWithoutColumnToMatchOn',\n\t\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdefault: [],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\t\tname: 'value',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tdisplayName: 'Columns',\n\t\tname: 'columns',\n\t\ttype: 'resourceMapper',\n\t\tnoDataExpression: true,\n\t\tdefault: {\n\t\t\tmappingMode: 'defineBelow',\n\t\t\tvalue: null,\n\t\t},\n\t\trequired: true,\n\t\ttypeOptions: {\n\t\t\tloadOptionsDependsOn: ['table.value', 'operation'],\n\t\t\tresourceMapper: {\n\t\t\t\tresourceMapperMethod: 'getMappingColumns',\n\t\t\t\tmode: 'update',\n\t\t\t\tfieldWords: {\n\t\t\t\t\tsingular: 'column',\n\t\t\t\t\tplural: 'columns',\n\t\t\t\t},\n\t\t\t\taddAllFields: true,\n\t\t\t\tmultiKeyMatch: true,\n\t\t\t},\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [{ _cnd: { gte: 2.2 } }],\n\t\t\t},\n\t\t},\n\t},\n\toptionsCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['database'],\n\t\toperation: ['update'],\n\t},\n\thide: {\n\t\ttable: [''],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\trunQueries: QueriesRunner,\n\titems: INodeExecutionData[],\n\tnodeOptions: PostgresNodeOptions,\n\tdb: PgpDatabase,\n): Promise<INodeExecutionData[]> {\n\titems = replaceEmptyStringsByNulls(items, nodeOptions.replaceEmptyStrings as boolean);\n\tconst nodeVersion = nodeOptions.nodeVersion as number;\n\n\tlet schema = this.getNodeParameter('schema', 0, undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tlet table = this.getNodeParameter('table', 0, undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst updateTableSchema = configureTableSchemaUpdater(schema, table);\n\n\tlet tableSchema = await getTableSchema(db, schema, table);\n\n\tconst queries: QueryWithValues[] = [];\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tschema = this.getNodeParameter('schema', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\ttable = this.getNodeParameter('table', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst columnsToMatchOn: string[] =\n\t\t\tnodeVersion < 2.2\n\t\t\t\t? [this.getNodeParameter('columnToMatchOn', i) as string]\n\t\t\t\t: (this.getNodeParameter('columns.matchingColumns', i) as string[]);\n\n\t\tconst dataMode =\n\t\t\tnodeVersion < 2.2\n\t\t\t\t? (this.getNodeParameter('dataMode', i) as string)\n\t\t\t\t: (this.getNodeParameter('columns.mappingMode', i) as string);\n\n\t\tlet item: IDataObject = {};\n\t\tlet valueToMatchOn: string | IDataObject = '';\n\t\tif (nodeVersion < 2.2) {\n\t\t\tvalueToMatchOn = this.getNodeParameter('valueToMatchOn', i) as string;\n\t\t}\n\n\t\tif (dataMode === 'autoMapInputData') {\n\t\t\titem = items[i].json;\n\t\t\tif (nodeVersion < 2.2) {\n\t\t\t\tvalueToMatchOn = item[columnsToMatchOn[0]] as string;\n\t\t\t}\n\t\t}\n\n\t\tif (dataMode === 'defineBelow') {\n\t\t\tconst valuesToSend =\n\t\t\t\tnodeVersion < 2.2\n\t\t\t\t\t? ((this.getNodeParameter('valuesToSend', i, []) as IDataObject).values as IDataObject[])\n\t\t\t\t\t: ((this.getNodeParameter('columns.values', i, []) as IDataObject)\n\t\t\t\t\t\t\t.values as IDataObject[]);\n\n\t\t\tif (nodeVersion < 2.2) {\n\t\t\t\titem = prepareItem(valuesToSend);\n\t\t\t\titem[columnsToMatchOn[0]] = this.getNodeParameter('valueToMatchOn', i) as string;\n\t\t\t} else {\n\t\t\t\titem = this.getNodeParameter('columns.value', i) as IDataObject;\n\t\t\t}\n\t\t}\n\n\t\tconst matchValues: string[] = [];\n\t\tif (nodeVersion < 2.2) {\n\t\t\tif (!item[columnsToMatchOn[0]] && dataMode === 'autoMapInputData') {\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t\"Column to match on not found in input item. Add a column to match on or set the 'Data Mode' to 'Define Below' to define the value to match on.\",\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchValues.push(valueToMatchOn);\n\t\t\tmatchValues.push(columnsToMatchOn[0]);\n\t\t} else {\n\t\t\tcolumnsToMatchOn.forEach((column) => {\n\t\t\t\tmatchValues.push(column);\n\t\t\t\tmatchValues.push(item[column] as string);\n\t\t\t});\n\t\t\tconst rowExists = await doesRowExist(db, schema, table, matchValues);\n\t\t\tif (!rowExists) {\n\t\t\t\tconst descriptionValues: string[] = [];\n\t\t\t\tmatchValues.forEach((_, index) => {\n\t\t\t\t\tif (index % 2 === 0) {\n\t\t\t\t\t\tdescriptionValues.push(`${matchValues[index]}=${matchValues[index + 1]}`);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t\"The row you are trying to update doesn't exist\",\n\t\t\t\t\t{\n\t\t\t\t\t\tdescription: `No rows matching the provided values (${descriptionValues.join(\n\t\t\t\t\t\t\t', ',\n\t\t\t\t\t\t)}) were found in the table \"${table}\".`,\n\t\t\t\t\t\titemIndex: i,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\ttableSchema = await updateTableSchema(db, tableSchema, schema, table);\n\n\t\tif (nodeVersion >= 2.4) {\n\t\t\tconvertArraysToPostgresFormat(item, tableSchema, this.getNode(), i);\n\t\t}\n\n\t\titem = checkItemAgainstSchema(this.getNode(), item, tableSchema, i);\n\n\t\tlet values: QueryValues = [schema, table];\n\n\t\tlet valuesLength = values.length + 1;\n\n\t\tlet condition = '';\n\t\tif (nodeVersion < 2.2) {\n\t\t\tcondition = `$${valuesLength}:name = $${valuesLength + 1}`;\n\t\t\tvaluesLength = valuesLength + 2;\n\t\t\tvalues.push(columnsToMatchOn[0], valueToMatchOn);\n\t\t} else {\n\t\t\tconst conditions: string[] = [];\n\t\t\tfor (const column of columnsToMatchOn) {\n\t\t\t\tconditions.push(`$${valuesLength}:name = $${valuesLength + 1}`);\n\t\t\t\tvaluesLength = valuesLength + 2;\n\t\t\t\tvalues.push(column, item[column] as string);\n\t\t\t}\n\t\t\tcondition = conditions.join(' AND ');\n\t\t}\n\n\t\tconst updateColumns = Object.keys(item).filter((column) => !columnsToMatchOn.includes(column));\n\n\t\tif (!Object.keys(updateColumns).length) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t\"Add values to update to the input item or set the 'Data Mode' to 'Define Below' to define the values to update.\",\n\t\t\t);\n\t\t}\n\n\t\tconst updates: string[] = [];\n\n\t\tfor (const column of updateColumns) {\n\t\t\tupdates.push(`$${valuesLength}:name = $${valuesLength + 1}`);\n\t\t\tvaluesLength = valuesLength + 2;\n\t\t\tvalues.push(column, item[column] as string);\n\t\t}\n\n\t\tlet query = `UPDATE $1:name.$2:name SET ${updates.join(', ')} WHERE ${condition}`;\n\n\t\tconst outputColumns = this.getNodeParameter('options.outputColumns', i, ['*']) as string[];\n\n\t\t[query, values] = addReturning(query, outputColumns, values);\n\n\t\tqueries.push({ query, values });\n\t}\n\n\tconst results = await runQueries(queries, items, nodeOptions);\n\treturn results;\n}\n"
            },
            {
              "file": "actions/database/upsert.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '@utils/utilities';\n\nimport type {\n\tPgpDatabase,\n\tPostgresNodeOptions,\n\tQueriesRunner,\n\tQueryValues,\n\tQueryWithValues,\n} from '../../helpers/interfaces';\nimport {\n\taddReturning,\n\tcheckItemAgainstSchema,\n\tgetTableSchema,\n\tprepareItem,\n\treplaceEmptyStringsByNulls,\n\tconfigureTableSchemaUpdater,\n\tconvertArraysToPostgresFormat,\n} from '../../helpers/utils';\nimport { optionsCollection } from '../common.descriptions';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Data Mode',\n\t\tname: 'dataMode',\n\t\ttype: 'options',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Auto-Map Input Data to Columns',\n\t\t\t\tvalue: 'autoMapInputData',\n\t\t\t\tdescription: 'Use when node input properties names exactly match the table column names',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Map Each Column Manually',\n\t\t\t\tvalue: 'defineBelow',\n\t\t\t\tdescription: 'Set the value for each destination column manually',\n\t\t\t},\n\t\t],\n\t\tdefault: 'autoMapInputData',\n\t\tdescription:\n\t\t\t'Whether to map node input properties and the table data automatically or manually',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: `\n\t\tIn this mode, make sure incoming data fields are named the same as the columns in your table. If needed, use an 'Edit Fields' node before this node to change the field names.\n\t\t`,\n\t\tname: 'notice',\n\t\ttype: 'notice',\n\t\tdefault: '',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['autoMapInputData'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\tdisplayName: 'Unique Column',\n\t\tname: 'columnToMatchOn',\n\t\ttype: 'options',\n\t\trequired: true,\n\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\tdescription:\n\t\t\t'The column to compare when finding the rows to update. Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>.',\n\t\ttypeOptions: {\n\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t},\n\t\tdefault: '',\n\t\thint: \"Used to find the correct row(s) to update. Doesn't get changed. Has to be unique.\",\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Value of Unique Column',\n\t\tname: 'valueToMatchOn',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription:\n\t\t\t'Rows with a value in the specified \"Column to Match On\" that corresponds to the value in this field will be updated. New rows will be created for non-matching items.',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['defineBelow'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Values to Send',\n\t\tname: 'valuesToSend',\n\t\tplaceholder: 'Add Value',\n\t\ttype: 'fixedCollection',\n\t\ttypeOptions: {\n\t\t\tmultipleValueButtonText: 'Add Value',\n\t\t\tmultipleValues: true,\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['defineBelow'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Values',\n\t\t\t\tname: 'values',\n\t\t\t\tvalues: [\n\t\t\t\t\t{\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\t\tname: 'column',\n\t\t\t\t\t\ttype: 'options',\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\t\tloadOptionsMethod: 'getColumnsWithoutColumnToMatchOn',\n\t\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdefault: [],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\t\tname: 'value',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tdisplayName: 'Columns',\n\t\tname: 'columns',\n\t\ttype: 'resourceMapper',\n\t\tnoDataExpression: true,\n\t\tdefault: {\n\t\t\tmappingMode: 'defineBelow',\n\t\t\tvalue: null,\n\t\t},\n\t\trequired: true,\n\t\ttypeOptions: {\n\t\t\tloadOptionsDependsOn: ['table.value', 'operation'],\n\t\t\tresourceMapper: {\n\t\t\t\tresourceMapperMethod: 'getMappingColumns',\n\t\t\t\tmode: 'upsert',\n\t\t\t\tfieldWords: {\n\t\t\t\t\tsingular: 'column',\n\t\t\t\t\tplural: 'columns',\n\t\t\t\t},\n\t\t\t\taddAllFields: true,\n\t\t\t\tmultiKeyMatch: true,\n\t\t\t},\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [{ _cnd: { gte: 2.2 } }],\n\t\t\t},\n\t\t},\n\t},\n\toptionsCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['database'],\n\t\toperation: ['upsert'],\n\t},\n\thide: {\n\t\ttable: [''],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\trunQueries: QueriesRunner,\n\titems: INodeExecutionData[],\n\tnodeOptions: PostgresNodeOptions,\n\tdb: PgpDatabase,\n): Promise<INodeExecutionData[]> {\n\titems = replaceEmptyStringsByNulls(items, nodeOptions.replaceEmptyStrings as boolean);\n\tconst nodeVersion = nodeOptions.nodeVersion as number;\n\n\tlet schema = this.getNodeParameter('schema', 0, undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tlet table = this.getNodeParameter('table', 0, undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst updateTableSchema = configureTableSchemaUpdater(schema, table);\n\n\tlet tableSchema = await getTableSchema(db, schema, table);\n\n\tconst queries: QueryWithValues[] = [];\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tschema = this.getNodeParameter('schema', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\ttable = this.getNodeParameter('table', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst columnsToMatchOn: string[] =\n\t\t\tnodeVersion < 2.2\n\t\t\t\t? [this.getNodeParameter('columnToMatchOn', i) as string]\n\t\t\t\t: (this.getNodeParameter('columns.matchingColumns', i) as string[]);\n\n\t\tconst dataMode =\n\t\t\tnodeVersion < 2.2\n\t\t\t\t? (this.getNodeParameter('dataMode', i) as string)\n\t\t\t\t: (this.getNodeParameter('columns.mappingMode', i) as string);\n\n\t\tlet item: IDataObject = {};\n\n\t\tif (dataMode === 'autoMapInputData') {\n\t\t\titem = items[i].json;\n\t\t}\n\n\t\tif (dataMode === 'defineBelow') {\n\t\t\tconst valuesToSend =\n\t\t\t\tnodeVersion < 2.2\n\t\t\t\t\t? ((this.getNodeParameter('valuesToSend', i, []) as IDataObject).values as IDataObject[])\n\t\t\t\t\t: ((this.getNodeParameter('columns.values', i, []) as IDataObject)\n\t\t\t\t\t\t\t.values as IDataObject[]);\n\n\t\t\tif (nodeVersion < 2.2) {\n\t\t\t\titem = prepareItem(valuesToSend);\n\t\t\t\titem[columnsToMatchOn[0]] = this.getNodeParameter('valueToMatchOn', i) as string;\n\t\t\t} else {\n\t\t\t\titem = this.getNodeParameter('columns.value', i) as IDataObject;\n\t\t\t}\n\t\t}\n\n\t\tif (!item[columnsToMatchOn[0]]) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t\"Column to match on not found in input item. Add a column to match on or set the 'Data Mode' to 'Define Below' to define the value to match on.\",\n\t\t\t);\n\t\t}\n\n\t\tif (item[columnsToMatchOn[0]] && Object.keys(item).length === 1) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t\"Add values to update or insert to the input item or set the 'Data Mode' to 'Define Below' to define the values to insert or update.\",\n\t\t\t);\n\t\t}\n\n\t\ttableSchema = await updateTableSchema(db, tableSchema, schema, table);\n\n\t\tif (nodeVersion >= 2.4) {\n\t\t\tconvertArraysToPostgresFormat(item, tableSchema, this.getNode(), i);\n\t\t}\n\n\t\titem = checkItemAgainstSchema(this.getNode(), item, tableSchema, i);\n\n\t\tlet values: QueryValues = [schema, table];\n\n\t\tlet valuesLength = values.length + 1;\n\t\tconst conflictColumns: string[] = [];\n\t\tcolumnsToMatchOn.forEach((column) => {\n\t\t\tconflictColumns.push(`$${valuesLength}:name`);\n\t\t\tvaluesLength = valuesLength + 1;\n\t\t\tvalues.push(column);\n\t\t});\n\t\tconst onConflict = ` ON CONFLICT (${conflictColumns.join(',')})`;\n\n\t\tconst insertQuery = `INSERT INTO $1:name.$2:name($${valuesLength}:name) VALUES($${valuesLength}:csv)${onConflict}`;\n\t\tvaluesLength = valuesLength + 1;\n\t\tvalues.push(item);\n\n\t\tconst updateColumns = Object.keys(item).filter((column) => !columnsToMatchOn.includes(column));\n\t\tconst updates: string[] = [];\n\n\t\tfor (const column of updateColumns) {\n\t\t\tupdates.push(`$${valuesLength}:name = $${valuesLength + 1}`);\n\t\t\tvaluesLength = valuesLength + 2;\n\t\t\tvalues.push(column, item[column] as string);\n\t\t}\n\n\t\tconst updateQuery =\n\t\t\tupdates?.length > 0 ? ` DO UPDATE  SET ${updates.join(', ')}` : ' DO NOTHING ';\n\t\tlet query = `${insertQuery}${updateQuery}`;\n\n\t\tconst outputColumns = this.getNodeParameter('options.outputColumns', i, ['*']) as string[];\n\n\t\t[query, values] = addReturning(query, outputColumns, values);\n\n\t\tqueries.push({ query, values });\n\t}\n\n\treturn await runQueries(queries, items, nodeOptions);\n}\n"
            },
            {
              "file": "actions/node.type.ts",
              "content": "import type { AllEntities, Entity } from 'n8n-workflow';\n\ntype PostgresMap = {\n\tdatabase: 'deleteTable' | 'executeQuery' | 'insert' | 'select' | 'update' | 'upsert';\n};\n\nexport type PostgresType = AllEntities<PostgresMap>;\n\nexport type PostgresDatabaseType = Entity<PostgresMap, 'database'>;\n"
            },
            {
              "file": "actions/router.ts",
              "content": "import type { IExecuteFunctions, INodeExecutionData } from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport * as database from './database/Database.resource';\nimport type { PostgresType } from './node.type';\nimport { addExecutionHints } from '../../../../utils/utilities';\nimport { configurePostgres } from '../../transport';\nimport type { PostgresNodeCredentials, PostgresNodeOptions } from '../helpers/interfaces';\nimport { configureQueryRunner } from '../helpers/utils';\n\nexport async function router(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {\n\tlet returnData: INodeExecutionData[] = [];\n\n\tconst items = this.getInputData();\n\tconst resource = this.getNodeParameter<PostgresType>('resource', 0);\n\tconst operation = this.getNodeParameter('operation', 0);\n\n\tconst credentials = await this.getCredentials<PostgresNodeCredentials>('postgres');\n\tconst options = this.getNodeParameter('options', 0, {}) as PostgresNodeOptions;\n\tconst node = this.getNode();\n\toptions.nodeVersion = node.typeVersion;\n\toptions.operation = operation;\n\n\tconst { db, pgp } = await configurePostgres.call(this, credentials, options);\n\n\tconst runQueries = configureQueryRunner.call(\n\t\tthis,\n\t\tthis.getNode(),\n\t\tthis.continueOnFail(),\n\t\tpgp,\n\t\tdb,\n\t);\n\n\tconst postgresNodeData = {\n\t\tresource,\n\t\toperation,\n\t} as PostgresType;\n\n\tswitch (postgresNodeData.resource) {\n\t\tcase 'database':\n\t\t\treturnData = await database[postgresNodeData.operation].execute.call(\n\t\t\t\tthis,\n\t\t\t\trunQueries,\n\t\t\t\titems,\n\t\t\t\toptions,\n\t\t\t\tdb,\n\t\t\t\tpgp,\n\t\t\t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t`The operation \"${operation}\" is not supported!`,\n\t\t\t);\n\t}\n\n\taddExecutionHints(this, node, items, operation, node.executeOnce);\n\n\treturn [returnData];\n}\n"
            },
            {
              "file": "actions/versionDescription.ts",
              "content": "/* eslint-disable n8n-nodes-base/node-filename-against-convention */\nimport { NodeConnectionTypes, type INodeTypeDescription } from 'n8n-workflow';\n\nimport * as database from './database/Database.resource';\n\nexport const versionDescription: INodeTypeDescription = {\n\tdisplayName: 'Postgres',\n\tname: 'postgres',\n\ticon: 'file:postgres.svg',\n\tgroup: ['input'],\n\tversion: [2, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6],\n\tsubtitle: '={{ $parameter[\"operation\"] }}',\n\tdescription: 'Get, add and update data in Postgres',\n\tdefaults: {\n\t\tname: 'Postgres',\n\t},\n\tinputs: [NodeConnectionTypes.Main],\n\toutputs: [NodeConnectionTypes.Main],\n\tusableAsTool: true,\n\tcredentials: [\n\t\t{\n\t\t\tname: 'postgres',\n\t\t\trequired: true,\n\t\t\ttestedBy: 'postgresConnectionTest',\n\t\t},\n\t],\n\tproperties: [\n\t\t{\n\t\t\tdisplayName: 'Resource',\n\t\t\tname: 'resource',\n\t\t\ttype: 'hidden',\n\t\t\tnoDataExpression: true,\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Database',\n\t\t\t\t\tvalue: 'database',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'database',\n\t\t},\n\t\t...database.description,\n\t],\n};\n"
            },
            {
              "file": "helpers/interfaces.ts",
              "content": "import type { IDataObject, INodeExecutionData, SSHCredentials } from 'n8n-workflow';\nimport type pgPromise from 'pg-promise';\nimport { type IFormattingOptions } from 'pg-promise';\nimport type pg from 'pg-promise/typescript/pg-subset';\n\nexport type QueryMode = 'single' | 'transaction' | 'independently';\n\nexport type QueryValue = string | number | IDataObject | string[];\nexport type QueryValues = QueryValue[];\nexport type QueryWithValues = { query: string; values?: QueryValues; options?: IFormattingOptions };\n\nexport type WhereClause = { column: string; condition: string; value: string | number };\nexport type SortRule = { column: string; direction: string };\nexport type ColumnInfo = {\n\tcolumn_name: string;\n\tdata_type: string;\n\tis_nullable: string;\n\tudt_name?: string;\n\tcolumn_default?: string | null;\n\tis_generated?: 'ALWAYS' | 'NEVER';\n\tidentity_generation?: 'ALWAYS' | 'NEVER';\n};\nexport type EnumInfo = {\n\ttypname: string;\n\tenumlabel: string;\n};\n\nexport type PgpClient = pgPromise.IMain<{}, pg.IClient>;\nexport type PgpDatabase = pgPromise.IDatabase<{}, pg.IClient>;\nexport type PgpConnectionParameters = pg.IConnectionParameters<pg.IClient>;\nexport type PgpConnection = pgPromise.IConnected<{}, pg.IClient>;\nexport type ConnectionsData = { db: PgpDatabase; pgp: PgpClient };\n\nexport type QueriesRunner = (\n\tqueries: QueryWithValues[],\n\titems: INodeExecutionData[],\n\toptions: IDataObject,\n) => Promise<INodeExecutionData[]>;\n\nexport type PostgresNodeOptions = {\n\tnodeVersion?: number;\n\toperation?: string;\n\tcascade?: boolean;\n\tconnectionTimeout?: number;\n\tdelayClosingIdleConnection?: number;\n\tqueryBatching?: QueryMode;\n\tqueryReplacement?: string;\n\toutputColumns?: string[];\n\tlargeNumbersOutput?: 'numbers' | 'text';\n\tskipOnConflict?: boolean;\n\treplaceEmptyStrings?: boolean;\n\ttreatQueryParametersInSingleQuotesAsText?: boolean;\n};\n\nexport type PostgresNodeCredentials = {\n\thost: string;\n\tport: number;\n\tdatabase: string;\n\tuser: string;\n\tpassword: string;\n\tmaxConnections: number;\n\tallowUnauthorizedCerts?: boolean;\n\tssl?: 'disable' | 'allow' | 'require' | 'verify' | 'verify-full';\n} & (\n\t| { sshTunnel: false }\n\t| ({\n\t\t\tsshTunnel: true;\n\t  } & SSHCredentials)\n);\n"
            },
            {
              "file": "helpers/utils.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINode,\n\tINodeExecutionData,\n\tINodePropertyOptions,\n\tNodeParameterValueType,\n} from 'n8n-workflow';\nimport { NodeOperationError, jsonParse } from 'n8n-workflow';\n\nimport type {\n\tColumnInfo,\n\tEnumInfo,\n\tPgpClient,\n\tPgpDatabase,\n\tQueryMode,\n\tQueryValues,\n\tQueryWithValues,\n\tSortRule,\n\tWhereClause,\n} from './interfaces';\nimport { generatePairedItemData } from '../../../../utils/utilities';\n\nexport function isJSON(str: string) {\n\ttry {\n\t\tJSON.parse(str.trim());\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport function evaluateExpression(expression: NodeParameterValueType) {\n\tif (expression === undefined) {\n\t\treturn '';\n\t} else if (expression === null) {\n\t\treturn 'null';\n\t} else {\n\t\treturn typeof expression === 'object' ? JSON.stringify(expression) : expression.toString();\n\t}\n}\n\nexport function stringToArray(str: NodeParameterValueType | undefined) {\n\tif (str === undefined) return [];\n\treturn String(str)\n\t\t.split(',')\n\t\t.filter((entry) => entry)\n\t\t.map((entry) => entry.trim());\n}\n\nexport function wrapData(data: IDataObject | IDataObject[]): INodeExecutionData[] {\n\tif (!Array.isArray(data)) {\n\t\treturn [{ json: data }];\n\t}\n\treturn data.map((item) => ({\n\t\tjson: item,\n\t}));\n}\n\nexport function prepareErrorItem(\n\titems: INodeExecutionData[],\n\terror: IDataObject | NodeOperationError | Error,\n\tindex: number,\n) {\n\treturn {\n\t\tjson: { message: error.message, item: { ...items[index].json }, error: { ...error } },\n\t\tpairedItem: { item: index },\n\t} as INodeExecutionData;\n}\n\nexport function parsePostgresError(\n\tnode: INode,\n\terror: any,\n\tqueries: QueryWithValues[],\n\titemIndex?: number,\n) {\n\tif (error.message.includes('syntax error at or near') && queries.length) {\n\t\ttry {\n\t\t\tconst snippet = error.message.match(/syntax error at or near \"(.*)\"/)[1] as string;\n\t\t\tconst failedQureryIndex = queries.findIndex((query) => query.query.includes(snippet));\n\n\t\t\tif (failedQureryIndex !== -1) {\n\t\t\t\tif (!itemIndex) {\n\t\t\t\t\titemIndex = failedQureryIndex;\n\t\t\t\t}\n\t\t\t\tconst failedQuery = queries[failedQureryIndex].query;\n\t\t\t\tconst lines = failedQuery.split('\\n');\n\t\t\t\tconst lineIndex = lines.findIndex((line) => line.includes(snippet));\n\t\t\t\tconst errorMessage = `Syntax error at line ${lineIndex + 1} near \"${snippet}\"`;\n\t\t\t\terror.message = errorMessage;\n\t\t\t}\n\t\t} catch {}\n\t}\n\n\tlet message = error.message;\n\tconst errorDescription = error.description ? error.description : error.detail || error.hint;\n\tlet description = errorDescription;\n\n\tif (!description && queries[itemIndex || 0]?.query) {\n\t\tdescription = `Failed query: ${queries[itemIndex || 0].query}`;\n\t}\n\n\tif (error.message.includes('ECONNREFUSED')) {\n\t\tmessage = 'Connection refused';\n\t\ttry {\n\t\t\tdescription = error.message.split('ECONNREFUSED ')[1].trim();\n\t\t} catch (e) {}\n\t}\n\n\tif (error.message.includes('ENOTFOUND')) {\n\t\tmessage = 'Host not found';\n\t\ttry {\n\t\t\tdescription = error.message.split('ENOTFOUND ')[1].trim();\n\t\t} catch (e) {}\n\t}\n\n\tif (error.message.includes('ETIMEDOUT')) {\n\t\tmessage = 'Connection timed out';\n\t\ttry {\n\t\t\tdescription = error.message.split('ETIMEDOUT ')[1].trim();\n\t\t} catch (e) {}\n\t}\n\n\treturn new NodeOperationError(node, error as Error, {\n\t\tmessage,\n\t\tdescription,\n\t\titemIndex,\n\t});\n}\n\nexport function addWhereClauses(\n\tnode: INode,\n\titemIndex: number,\n\tquery: string,\n\tclauses: WhereClause[],\n\treplacements: QueryValues,\n\tcombineConditions: string,\n): [string, QueryValues] {\n\tif (clauses.length === 0) return [query, replacements];\n\n\tlet combineWith = 'AND';\n\n\tif (combineConditions === 'OR') {\n\t\tcombineWith = 'OR';\n\t}\n\n\tlet replacementIndex = replacements.length + 1;\n\n\tlet whereQuery = ' WHERE';\n\tconst values: QueryValues = [];\n\n\tclauses.forEach((clause, index) => {\n\t\tif (clause.condition === 'equal') {\n\t\t\tclause.condition = '=';\n\t\t}\n\t\tif (['>', '<', '>=', '<='].includes(clause.condition)) {\n\t\t\tconst value = Number(clause.value);\n\n\t\t\tif (Number.isNaN(value)) {\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tnode,\n\t\t\t\t\t`Operator in entry ${index + 1} of 'Select Rows' works with numbers, but value ${\n\t\t\t\t\t\tclause.value\n\t\t\t\t\t} is not a number`,\n\t\t\t\t\t{\n\t\t\t\t\t\titemIndex,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tclause.value = value;\n\t\t}\n\t\tconst columnReplacement = `$${replacementIndex}:name`;\n\t\tvalues.push(clause.column);\n\t\treplacementIndex = replacementIndex + 1;\n\n\t\tlet valueReplacement = '';\n\t\tif (clause.condition !== 'IS NULL' && clause.condition !== 'IS NOT NULL') {\n\t\t\tvalueReplacement = ` $${replacementIndex}`;\n\t\t\tvalues.push(clause.value);\n\t\t\treplacementIndex = replacementIndex + 1;\n\t\t}\n\n\t\tconst operator = index === clauses.length - 1 ? '' : ` ${combineWith}`;\n\n\t\twhereQuery += ` ${columnReplacement} ${clause.condition}${valueReplacement}${operator}`;\n\t});\n\n\treturn [`${query}${whereQuery}`, replacements.concat(...values)];\n}\n\nexport function addSortRules(\n\tquery: string,\n\trules: SortRule[],\n\treplacements: QueryValues,\n): [string, QueryValues] {\n\tif (rules.length === 0) return [query, replacements];\n\n\tlet replacementIndex = replacements.length + 1;\n\n\tlet orderByQuery = ' ORDER BY';\n\tconst values: string[] = [];\n\n\trules.forEach((rule, index) => {\n\t\tconst columnReplacement = `$${replacementIndex}:name`;\n\t\tvalues.push(rule.column);\n\t\treplacementIndex = replacementIndex + 1;\n\n\t\tconst endWith = index === rules.length - 1 ? '' : ',';\n\n\t\tconst sortDirection = rule.direction === 'DESC' ? 'DESC' : 'ASC';\n\n\t\torderByQuery += ` ${columnReplacement} ${sortDirection}${endWith}`;\n\t});\n\n\treturn [`${query}${orderByQuery}`, replacements.concat(...values)];\n}\n\nexport function addReturning(\n\tquery: string,\n\toutputColumns: string[],\n\treplacements: QueryValues,\n): [string, QueryValues] {\n\tif (outputColumns.includes('*')) return [`${query} RETURNING *`, replacements];\n\n\tconst replacementIndex = replacements.length + 1;\n\n\treturn [`${query} RETURNING $${replacementIndex}:name`, [...replacements, outputColumns]];\n}\n\nconst isSelectQuery = (query: string) => {\n\treturn query\n\t\t.replace(/\\/\\*.*?\\*\\//g, '') // remove multiline comments\n\t\t.replace(/\\n/g, '')\n\t\t.split(';')\n\t\t.filter((statement) => statement && !statement.startsWith('--')) // remove comments and empty statements\n\t\t.every((statement) => statement.trim().toLowerCase().startsWith('select'));\n};\n\nexport function configureQueryRunner(\n\tthis: IExecuteFunctions,\n\tnode: INode,\n\tcontinueOnFail: boolean,\n\tpgp: PgpClient,\n\tdb: PgpDatabase,\n) {\n\treturn async (queries: QueryWithValues[], items: INodeExecutionData[], options: IDataObject) => {\n\t\tlet returnData: INodeExecutionData[] = [];\n\t\tconst emptyReturnData: INodeExecutionData[] =\n\t\t\toptions.operation === 'select' ? [] : [{ json: { success: true } }];\n\n\t\tconst queryBatching = (options.queryBatching as QueryMode) || 'single';\n\n\t\tif (queryBatching === 'single') {\n\t\t\ttry {\n\t\t\t\treturnData = (await db.multi(pgp.helpers.concat(queries)))\n\t\t\t\t\t.map((result, i) => {\n\t\t\t\t\t\treturn this.helpers.constructExecutionMetaData(wrapData(result as IDataObject[]), {\n\t\t\t\t\t\t\titemData: { item: i },\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t\t.flat();\n\n\t\t\t\tif (!returnData.length) {\n\t\t\t\t\tconst pairedItem = generatePairedItemData(queries.length);\n\n\t\t\t\t\tif ((options?.nodeVersion as number) < 2.3) {\n\t\t\t\t\t\tif (emptyReturnData.length) {\n\t\t\t\t\t\t\temptyReturnData[0].pairedItem = pairedItem;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturnData = emptyReturnData;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturnData = queries.every((query) => isSelectQuery(query.query))\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: [{ json: { success: true }, pairedItem }];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tconst error = parsePostgresError(node, err, queries);\n\t\t\t\tif (!continueOnFail) throw error;\n\n\t\t\t\treturn [\n\t\t\t\t\t{\n\t\t\t\t\t\tjson: {\n\t\t\t\t\t\t\tmessage: error.message,\n\t\t\t\t\t\t\terror: { ...error },\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tif (queryBatching === 'transaction') {\n\t\t\treturnData = await db.tx(async (transaction) => {\n\t\t\t\tconst result: INodeExecutionData[] = [];\n\t\t\t\tfor (let i = 0; i < queries.length; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst query = queries[i].query;\n\t\t\t\t\t\tconst values = queries[i].values;\n\n\t\t\t\t\t\tlet transactionResults;\n\t\t\t\t\t\tif ((options?.nodeVersion as number) < 2.3) {\n\t\t\t\t\t\t\ttransactionResults = await transaction.any(query, values);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttransactionResults = (await transaction.multi(query, values)).flat();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!transactionResults.length) {\n\t\t\t\t\t\t\tif ((options?.nodeVersion as number) < 2.3) {\n\t\t\t\t\t\t\t\ttransactionResults = emptyReturnData;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransactionResults = isSelectQuery(query) ? [] : [{ success: true }];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\t\t\t\twrapData(transactionResults),\n\t\t\t\t\t\t\t{ itemData: { item: i } },\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tresult.push(...executionData);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconst error = parsePostgresError(node, err, queries, i);\n\t\t\t\t\t\tif (!continueOnFail) throw error;\n\t\t\t\t\t\tresult.push(prepareErrorItem(items, error, i));\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t});\n\t\t}\n\n\t\tif (queryBatching === 'independently') {\n\t\t\treturnData = await db.task(async (task) => {\n\t\t\t\tconst result: INodeExecutionData[] = [];\n\t\t\t\tfor (let i = 0; i < queries.length; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst query = queries[i].query;\n\t\t\t\t\t\tconst values = queries[i].values;\n\n\t\t\t\t\t\tlet transactionResults;\n\t\t\t\t\t\tif ((options?.nodeVersion as number) < 2.3) {\n\t\t\t\t\t\t\ttransactionResults = await task.any(query, values);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttransactionResults = (await task.multi(query, values)).flat();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!transactionResults.length) {\n\t\t\t\t\t\t\tif ((options?.nodeVersion as number) < 2.3) {\n\t\t\t\t\t\t\t\ttransactionResults = emptyReturnData;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransactionResults = isSelectQuery(query) ? [] : [{ success: true }];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\t\t\t\twrapData(transactionResults),\n\t\t\t\t\t\t\t{ itemData: { item: i } },\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tresult.push(...executionData);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconst error = parsePostgresError(node, err, queries, i);\n\t\t\t\t\t\tif (!continueOnFail) throw error;\n\t\t\t\t\t\tresult.push(prepareErrorItem(items, error, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t});\n\t\t}\n\n\t\treturn returnData;\n\t};\n}\n\nexport function replaceEmptyStringsByNulls(\n\titems: INodeExecutionData[],\n\treplace?: boolean,\n): INodeExecutionData[] {\n\tif (!replace) return items;\n\n\tconst returnData: INodeExecutionData[] = items.map((item) => {\n\t\tconst newItem = { ...item };\n\t\tconst keys = Object.keys(newItem.json);\n\n\t\tfor (const key of keys) {\n\t\t\tif (newItem.json[key] === '') {\n\t\t\t\tnewItem.json[key] = null;\n\t\t\t}\n\t\t}\n\n\t\treturn newItem;\n\t});\n\n\treturn returnData;\n}\n\nexport function prepareItem(values: IDataObject[]) {\n\tconst item = values.reduce((acc, { column, value }) => {\n\t\tacc[column as string] = value;\n\t\treturn acc;\n\t}, {} as IDataObject);\n\n\treturn item;\n}\n\nexport function hasJsonDataTypeInSchema(schema: ColumnInfo[]) {\n\treturn schema.some(({ data_type }) => data_type === 'json');\n}\n\nexport function convertValuesToJsonWithPgp(\n\tpgp: PgpClient,\n\tschema: ColumnInfo[],\n\tvalues: IDataObject,\n) {\n\tschema\n\t\t.filter(\n\t\t\t({ data_type, column_name }) =>\n\t\t\t\tdata_type === 'json' && values[column_name] !== null && values[column_name] !== undefined,\n\t\t)\n\t\t.forEach(({ column_name }) => {\n\t\t\tvalues[column_name] = pgp.as.json(values[column_name], true);\n\t\t});\n\n\treturn values;\n}\n\nexport async function columnFeatureSupport(\n\tdb: PgpDatabase,\n): Promise<{ identity_generation: boolean; is_generated: boolean }> {\n\tconst result = await db.any(\n\t\t`SELECT EXISTS (\n\t\t\tSELECT 1 FROM information_schema.columns WHERE table_name = 'columns' AND table_schema = 'information_schema' AND column_name = 'is_generated'\n\t\t) as is_generated,\n\t\tEXISTS (\n\t\t\tSELECT 1 FROM information_schema.columns WHERE table_name = 'columns' AND table_schema = 'information_schema' AND column_name = 'identity_generation'\n\t\t) as identity_generation;`,\n\t);\n\n\treturn result[0];\n}\n\nexport async function getTableSchema(\n\tdb: PgpDatabase,\n\tschema: string,\n\ttable: string,\n\toptions?: { getColumnsForResourceMapper?: boolean },\n): Promise<ColumnInfo[]> {\n\tconst select = ['column_name', 'data_type', 'is_nullable', 'udt_name', 'column_default'];\n\n\tif (options?.getColumnsForResourceMapper) {\n\t\t// Check if columns exist before querying (identity_generation was added in v10, is_generated in v12)\n\t\tconst supported = await columnFeatureSupport(db);\n\n\t\tif (supported.identity_generation) {\n\t\t\tselect.push('identity_generation');\n\t\t}\n\n\t\tif (supported.is_generated) {\n\t\t\tselect.push('is_generated');\n\t\t}\n\t}\n\n\tconst selectString = select.join(', ');\n\tconst columns = await db.any(\n\t\t`SELECT ${selectString} FROM information_schema.columns WHERE table_schema = $1 AND table_name = $2`,\n\t\t[schema, table],\n\t);\n\n\treturn columns;\n}\n\nexport async function uniqueColumns(db: PgpDatabase, table: string, schema = 'public') {\n\t// Using the modified query from https://wiki.postgresql.org/wiki/Retrieve_primary_key_columns\n\t// `quote_ident` - properly quote and escape an identifier\n\t// `::regclass` - cast a string to a regclass (internal type for object names)\n\tconst unique = await db.any(\n\t\t`\n\t\tSELECT DISTINCT a.attname\n\t\t\tFROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)\n\t\tWHERE i.indrelid = (quote_ident($1) || '.' || quote_ident($2))::regclass\n\t\t\tAND (i.indisprimary OR i.indisunique);\n\t\t`,\n\t\t[schema, table],\n\t);\n\treturn unique as IDataObject[];\n}\n\nexport async function getEnums(db: PgpDatabase): Promise<EnumInfo[]> {\n\tconst enumsData = await db.any(\n\t\t'SELECT pg_type.typname, pg_enum.enumlabel FROM pg_type JOIN pg_enum ON pg_enum.enumtypid = pg_type.oid;',\n\t);\n\treturn enumsData as EnumInfo[];\n}\n\nexport function getEnumValues(enumInfo: EnumInfo[], enumName: string): INodePropertyOptions[] {\n\treturn enumInfo.reduce((acc, current) => {\n\t\tif (current.typname === enumName) {\n\t\t\tacc.push({ name: current.enumlabel, value: current.enumlabel });\n\t\t}\n\t\treturn acc;\n\t}, [] as INodePropertyOptions[]);\n}\n\nexport async function doesRowExist(\n\tdb: PgpDatabase,\n\tschema: string,\n\ttable: string,\n\tvalues: string[],\n): Promise<boolean> {\n\tconst where = [];\n\tfor (let i = 3; i < 3 + values.length; i += 2) {\n\t\twhere.push(`$${i}:name=$${i + 1}`);\n\t}\n\tconst exists = await db.any(\n\t\t`SELECT EXISTS(SELECT 1 FROM $1:name.$2:name WHERE ${where.join(' AND ')})`,\n\t\t[schema, table, ...values],\n\t);\n\treturn exists[0].exists;\n}\n\nexport function checkItemAgainstSchema(\n\tnode: INode,\n\titem: IDataObject,\n\tcolumnsInfo: ColumnInfo[],\n\tindex: number,\n) {\n\tif (columnsInfo.length === 0) return item;\n\tconst schema = columnsInfo.reduce((acc, { column_name, data_type, is_nullable }) => {\n\t\tacc[column_name] = { type: data_type.toUpperCase(), nullable: is_nullable === 'YES' };\n\t\treturn acc;\n\t}, {} as IDataObject);\n\n\tfor (const key of Object.keys(item)) {\n\t\tif (schema[key] === undefined) {\n\t\t\tthrow new NodeOperationError(node, `Column '${key}' does not exist in selected table`, {\n\t\t\t\titemIndex: index,\n\t\t\t});\n\t\t}\n\t\tif (item[key] === null && !(schema[key] as IDataObject)?.nullable) {\n\t\t\tthrow new NodeOperationError(node, `Column '${key}' is not nullable`, {\n\t\t\t\titemIndex: index,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn item;\n}\n\nexport const configureTableSchemaUpdater = (initialSchema: string, initialTable: string) => {\n\tlet currentSchema = initialSchema;\n\tlet currentTable = initialTable;\n\treturn async (db: PgpDatabase, tableSchema: ColumnInfo[], schema: string, table: string) => {\n\t\tif (currentSchema !== schema || currentTable !== table) {\n\t\t\tcurrentSchema = schema;\n\t\t\tcurrentTable = table;\n\t\t\ttableSchema = await getTableSchema(db, schema, table);\n\t\t}\n\t\treturn tableSchema;\n\t};\n};\n\n/**\n * If postgress column type is array we need to convert it to fornmat that postgres understands, original object data would be modified\n * @param data the object with keys representing column names and values\n * @param schema table schema\n * @param node INode\n * @param itemIndex the index of the current item\n */\nexport const convertArraysToPostgresFormat = (\n\tdata: IDataObject,\n\tschema: ColumnInfo[],\n\tnode: INode,\n\titemIndex = 0,\n) => {\n\tfor (const columnInfo of schema) {\n\t\t//in case column type is array we need to convert it to fornmat that postgres understands\n\t\tif (columnInfo.data_type.toUpperCase() === 'ARRAY') {\n\t\t\tlet columnValue = data[columnInfo.column_name];\n\n\t\t\tif (typeof columnValue === 'string') {\n\t\t\t\tcolumnValue = jsonParse(columnValue);\n\t\t\t}\n\n\t\t\tif (Array.isArray(columnValue)) {\n\t\t\t\tconst arrayEntries = columnValue.map((entry) => {\n\t\t\t\t\tif (typeof entry === 'number') {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof entry === 'boolean') {\n\t\t\t\t\t\tentry = String(entry);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof entry === 'object') {\n\t\t\t\t\t\tentry = JSON.stringify(entry);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof entry === 'string') {\n\t\t\t\t\t\treturn `\"${entry.replace(/\"/g, '\\\\\"')}\"`; //escape double quotes\n\t\t\t\t\t}\n\n\t\t\t\t\treturn entry;\n\t\t\t\t});\n\n\t\t\t\t//wrap in {} instead of [] as postgres does and join with ,\n\t\t\t\tdata[columnInfo.column_name] = `{${arrayEntries.join(',')}}`;\n\t\t\t} else {\n\t\t\t\tif (columnInfo.is_nullable === 'NO') {\n\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\t`Column '${columnInfo.column_name}' has to be an array`,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n"
            },
            {
              "file": "methods/credentialTest.ts",
              "content": "import type {\n\tICredentialsDecrypted,\n\tICredentialTestFunctions,\n\tINodeCredentialTestResult,\n} from 'n8n-workflow';\n\nimport { configurePostgres } from '../../transport';\nimport type { PgpConnection, PostgresNodeCredentials } from '../helpers/interfaces';\n\nexport async function postgresConnectionTest(\n\tthis: ICredentialTestFunctions,\n\tcredential: ICredentialsDecrypted,\n): Promise<INodeCredentialTestResult> {\n\tconst credentials = credential.data as PostgresNodeCredentials;\n\n\tlet connection: PgpConnection | undefined;\n\n\ttry {\n\t\tconst { db } = await configurePostgres.call(this, credentials, {});\n\n\t\tconnection = await db.connect();\n\t} catch (error) {\n\t\tlet message = error.message as string;\n\n\t\tif (error.message.includes('ECONNREFUSED')) {\n\t\t\tmessage = 'Connection refused';\n\t\t}\n\n\t\tif (error.message.includes('ENOTFOUND')) {\n\t\t\tmessage = 'Host not found, please check your host name';\n\t\t}\n\n\t\tif (error.message.includes('ETIMEDOUT')) {\n\t\t\tmessage = 'Connection timed out';\n\t\t}\n\n\t\treturn {\n\t\t\tstatus: 'Error',\n\t\t\tmessage,\n\t\t};\n\t} finally {\n\t\tif (connection) {\n\t\t\tawait connection.done();\n\t\t}\n\t}\n\treturn {\n\t\tstatus: 'OK',\n\t\tmessage: 'Connection successful!',\n\t};\n}\n"
            },
            {
              "file": "methods/index.ts",
              "content": "export * as credentialTest from './credentialTest';\nexport * as listSearch from './listSearch';\nexport * as loadOptions from './loadOptions';\nexport * as resourceMapping from './resourceMapping';\n"
            },
            {
              "file": "methods/listSearch.ts",
              "content": "import type { ILoadOptionsFunctions, INodeListSearchResult } from 'n8n-workflow';\n\nimport { configurePostgres } from '../../transport';\nimport type { PostgresNodeCredentials } from '../helpers/interfaces';\n\nexport async function schemaSearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst credentials = await this.getCredentials<PostgresNodeCredentials>('postgres');\n\tconst options = { nodeVersion: this.getNode().typeVersion };\n\n\tconst { db } = await configurePostgres.call(this, credentials, options);\n\n\tconst response = await db.any('SELECT schema_name FROM information_schema.schemata');\n\n\treturn {\n\t\tresults: response.map((schema) => ({\n\t\t\tname: schema.schema_name as string,\n\t\t\tvalue: schema.schema_name as string,\n\t\t})),\n\t};\n}\nexport async function tableSearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst credentials = await this.getCredentials<PostgresNodeCredentials>('postgres');\n\tconst options = { nodeVersion: this.getNode().typeVersion };\n\n\tconst { db } = await configurePostgres.call(this, credentials, options);\n\n\tconst schema = this.getNodeParameter('schema', 0, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst response = await db.any(\n\t\t'SELECT table_name FROM information_schema.tables WHERE table_schema=$1',\n\t\t[schema],\n\t);\n\n\treturn {\n\t\tresults: response.map((table) => ({\n\t\t\tname: table.table_name as string,\n\t\t\tvalue: table.table_name as string,\n\t\t})),\n\t};\n}\n"
            },
            {
              "file": "methods/loadOptions.ts",
              "content": "import type { ILoadOptionsFunctions, INodePropertyOptions } from 'n8n-workflow';\n\nimport { configurePostgres } from '../../transport';\nimport type { PostgresNodeCredentials } from '../helpers/interfaces';\nimport { getTableSchema } from '../helpers/utils';\n\nexport async function getColumns(this: ILoadOptionsFunctions): Promise<INodePropertyOptions[]> {\n\tconst credentials = await this.getCredentials<PostgresNodeCredentials>('postgres');\n\tconst options = { nodeVersion: this.getNode().typeVersion };\n\n\tconst { db } = await configurePostgres.call(this, credentials, options);\n\n\tconst schema = this.getNodeParameter('schema', 0, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst table = this.getNodeParameter('table', 0, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst columns = await getTableSchema(db, schema, table);\n\n\treturn columns.map((column) => ({\n\t\tname: column.column_name,\n\t\tvalue: column.column_name,\n\t\tdescription: `Type: ${column.data_type.toUpperCase()}, Nullable: ${column.is_nullable}`,\n\t}));\n}\n\nexport async function getColumnsMultiOptions(\n\tthis: ILoadOptionsFunctions,\n): Promise<INodePropertyOptions[]> {\n\tconst returnData = await getColumns.call(this);\n\tconst returnAll = { name: '*', value: '*', description: 'All columns' };\n\treturn [returnAll, ...returnData];\n}\n\nexport async function getColumnsWithoutColumnToMatchOn(\n\tthis: ILoadOptionsFunctions,\n): Promise<INodePropertyOptions[]> {\n\tconst columnToMatchOn = this.getNodeParameter('columnToMatchOn') as string;\n\tconst returnData = await getColumns.call(this);\n\treturn returnData.filter((column) => column.value !== columnToMatchOn);\n}\n"
            },
            {
              "file": "methods/resourceMapping.ts",
              "content": "import type { ILoadOptionsFunctions, ResourceMapperFields, FieldType } from 'n8n-workflow';\n\nimport { configurePostgres } from '../../transport';\nimport type { PostgresNodeCredentials } from '../helpers/interfaces';\nimport { getEnumValues, getEnums, getTableSchema, uniqueColumns } from '../helpers/utils';\n\nconst fieldTypeMapping: Partial<Record<FieldType, string[]>> = {\n\tstring: ['text', 'varchar', 'character varying', 'character', 'char'],\n\tnumber: [\n\t\t'integer',\n\t\t'smallint',\n\t\t'bigint',\n\t\t'decimal',\n\t\t'numeric',\n\t\t'real',\n\t\t'double precision',\n\t\t'smallserial',\n\t\t'serial',\n\t\t'bigserial',\n\t],\n\tboolean: ['boolean'],\n\tdateTime: [\n\t\t'timestamp',\n\t\t'date',\n\t\t'timestampz',\n\t\t'timestamp without time zone',\n\t\t'timestamp with time zone',\n\t],\n\ttime: ['time', 'time without time zone', 'time with time zone'],\n\tobject: ['json', 'jsonb'],\n\toptions: ['enum', 'USER-DEFINED'],\n\tarray: ['ARRAY'],\n};\n\nfunction mapPostgresType(postgresType: string): FieldType {\n\tlet mappedType: FieldType = 'string';\n\n\tfor (const t of Object.keys(fieldTypeMapping)) {\n\t\tconst postgresTypes = fieldTypeMapping[t as FieldType];\n\t\tif (postgresTypes?.includes(postgresType)) {\n\t\t\tmappedType = t as FieldType;\n\t\t}\n\t}\n\treturn mappedType;\n}\n\nexport async function getMappingColumns(\n\tthis: ILoadOptionsFunctions,\n): Promise<ResourceMapperFields> {\n\tconst credentials = await this.getCredentials<PostgresNodeCredentials>('postgres');\n\n\tconst { db } = await configurePostgres.call(this, credentials);\n\n\tconst schema = this.getNodeParameter('schema', 0, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst table = this.getNodeParameter('table', 0, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst operation = this.getNodeParameter('operation', 0, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst columns = await getTableSchema(db, schema, table, { getColumnsForResourceMapper: true });\n\tconst unique = operation === 'upsert' ? await uniqueColumns(db, table, schema) : [];\n\tconst enumInfo = await getEnums(db);\n\tconst fields = await Promise.all(\n\t\tcolumns.map(async (col) => {\n\t\t\tconst canBeUsedToMatch =\n\t\t\t\toperation === 'upsert' ? unique.some((u) => u.attname === col.column_name) : true;\n\t\t\tconst type = mapPostgresType(col.data_type);\n\t\t\tconst options =\n\t\t\t\ttype === 'options' ? getEnumValues(enumInfo, col.udt_name as string) : undefined;\n\t\t\tconst hasDefault = Boolean(col.column_default);\n\t\t\tconst isGenerated =\n\t\t\t\tcol.is_generated === 'ALWAYS' ||\n\t\t\t\t['ALWAYS', 'BY DEFAULT'].includes(col.identity_generation ?? '');\n\t\t\tconst nullable = col.is_nullable === 'YES';\n\t\t\treturn {\n\t\t\t\tid: col.column_name,\n\t\t\t\tdisplayName: col.column_name,\n\t\t\t\trequired: !nullable && !hasDefault && !isGenerated,\n\t\t\t\tdefaultMatch: (col.column_name === 'id' && canBeUsedToMatch) || false,\n\t\t\t\tdisplay: true,\n\t\t\t\ttype,\n\t\t\t\tcanBeUsedToMatch,\n\t\t\t\toptions,\n\t\t\t};\n\t\t}),\n\t);\n\treturn { fields };\n}\n"
            }
          ]
        },
        "metadata": {
          "fetch_time": "2026-01-07T08:26:09.401936+00:00",
          "source_type": "TYPE1",
          "source_path": "input_sources/postgres",
          "file_count": 19,
          "content_hash": "578404df52143536"
        },
        "artifacts": {
          "raw_source": "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/raw_source.txt",
          "parsed_source": "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/parsed_source.json",
          "source_bundle": "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/source_bundle"
        }
      },
      "artifacts_produced": [
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/raw_source.txt",
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/parsed_source.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "infer-schema",
      "skill_name": "schema-infer",
      "status": "blocked",
      "started_at": "2026-01-07T08:26:09.408431",
      "completed_at": "2026-01-07T08:26:09.924085",
      "duration_ms": 515,
      "outputs": {
        "inferred_schema": {
          "type": "postgres",
          "version": 1,
          "description": {
            "displayName": "Postgres",
            "name": "postgres",
            "inputs": [
              {
                "name": "main",
                "type": "main"
              }
            ],
            "outputs": [
              {
                "name": "main",
                "type": "main"
              }
            ]
          },
          "properties": {
            "parameters": [
              {
                "name": "resource",
                "display_name": "Resource",
                "type": "OPTIONS",
                "options": [
                  {
                    "name": "Database",
                    "value": "database"
                  }
                ],
                "default": "database",
                "description": "The resource to operate on"
              }
            ],
            "credentials": [
              {
                "name": "postgres",
                "required": true
              }
            ]
          },
          "operations": [
            {
              "name": "execute",
              "description": "Default operation"
            }
          ],
          "resources": [
            {
              "name": "Database",
              "value": "database"
            }
          ],
          "credentials": [
            {
              "name": "postgres",
              "required": true
            }
          ]
        },
        "trace_map": {
          "correlation_id": "node-postgres-fix32-test",
          "node_type": "postgres",
          "trace_entries": [
            {
              "field_path": "resources[0]",
              "source": "SOURCE_CODE",
              "evidence": "Resource 'database' defined in actions/versionDescription.ts",
              "confidence": "high",
              "source_file": "actions/versionDescription.ts"
            },
            {
              "field_path": "credentials[0]",
              "source": "SOURCE_CODE",
              "evidence": "Credential 'postgres' (required=True) in actions/versionDescription.ts",
              "confidence": "high",
              "source_file": "actions/versionDescription.ts"
            },
            {
              "field_path": "operations[0]",
              "source": "ASSUMPTION",
              "evidence": "No operations found in source; defaulting to single 'execute' operation",
              "confidence": "low",
              "assumption_rationale": "Source may be incomplete or use different patterns"
            }
          ],
          "generated_at": "2026-01-07T08:26:09.660192",
          "skill_version": "1.0.0",
          "_hybrid_metadata": {
            "source_type": "TYPE1",
            "extraction_confidence": 0.7,
            "advisor_used": false,
            "assumption_ratio": 0.3333333333333333,
            "deterministic_operations": 2,
            "assumption_operations": 1
          }
        },
        "schema": {
          "type": "postgres",
          "version": 1,
          "description": {
            "displayName": "Postgres",
            "name": "postgres",
            "inputs": [
              {
                "name": "main",
                "type": "main"
              }
            ],
            "outputs": [
              {
                "name": "main",
                "type": "main"
              }
            ]
          },
          "properties": {
            "parameters": [
              {
                "name": "resource",
                "display_name": "Resource",
                "type": "OPTIONS",
                "options": [
                  {
                    "name": "Database",
                    "value": "database"
                  }
                ],
                "default": "database",
                "description": "The resource to operate on"
              }
            ],
            "credentials": [
              {
                "name": "postgres",
                "required": true
              }
            ]
          },
          "operations": [
            {
              "name": "execute",
              "description": "Default operation"
            }
          ],
          "resources": [
            {
              "name": "Database",
              "value": "database"
            }
          ],
          "credentials": [
            {
              "name": "postgres",
              "required": true
            }
          ]
        },
        "assumptions": [
          "Default 'execute' operation assumed - verify against actual API",
          "WARNING: High assumption ratio (33.3%) exceeds 30% threshold"
        ],
        "artifacts_written": [
          "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/schema/inferred_schema.json",
          "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/schema/trace_map.json"
        ],
        "extraction_confidence": 0.7,
        "advisor_used": false
      },
      "artifacts_produced": [
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/inferred_schema.json",
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/trace_map.json"
      ],
      "errors": [
        "Too many assumptions: 33.3% > 30% allowed",
        "Trace map validation failed"
      ],
      "skipped_reason": null
    },
    {
      "step_name": "scaffold",
      "skill_name": "node-scaffold",
      "status": "completed",
      "started_at": "2026-01-07T08:26:09.924114",
      "completed_at": "2026-01-07T08:26:09.930875",
      "duration_ms": 6,
      "outputs": {
        "files_created": [
          "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/generated_node/postgres.py",
          "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/generated_node/__init__.py"
        ],
        "allowlist": {
          "node_name": "postgres",
          "patterns": [
            "nodes/postgres*",
            "nodes/postgres*",
            "tests/*postgres*",
            "tests/*postgres*",
            "credentials/*postgres*",
            "credentials/*postgres*"
          ]
        }
      },
      "artifacts_produced": [
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/scaffold_manifest.json",
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/allowlist.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "ground",
      "skill_name": "repo-ground",
      "status": "completed",
      "started_at": "2026-01-07T08:26:09.930892",
      "completed_at": "2026-01-07T08:26:09.975355",
      "duration_ms": 44,
      "outputs": {
        "repo_facts_path": "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/repo_facts.json",
        "repo_facts": {
          "basenode_contract_path": "contracts/BASENODE_CONTRACT.md",
          "node_loader_paths": [
            "runtime/kb/loader.py"
          ],
          "golden_node_paths": [
            "nodepacks/core/nodes.py",
            "src/node_sdk/basenode.py"
          ],
          "test_command": "pytest tests/"
        },
        "target_repo_layout_path": "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/target_repo_layout.json",
        "target_repo_layout": {
          "target_repo_root": "/home/toni/agent-skills",
          "node_output_base_dir": "nodes",
          "registry_file": "nodes/__init__.py",
          "registry_strategy": "dict_import",
          "registry_dict_name": "node_definitions",
          "base_class_file": "nodes/base.py",
          "base_class_name": "BaseNode",
          "tests_dir": "tests",
          "python_version": null,
          "venv_path": ".venv",
          "extra_allowlist_patterns": []
        }
      },
      "artifacts_produced": [
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/repo_facts.json",
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/target_repo_layout.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "convert",
      "skill_name": "code-convert",
      "status": "blocked",
      "started_at": "2026-01-07T08:26:09.975403",
      "completed_at": "2026-01-07T08:26:09.997333",
      "duration_ms": 21,
      "outputs": {
        "files_modified": [
          "nodes/postgres.py"
        ],
        "all_target_files": [
          "nodes/postgres.py",
          "nodes/__init__.py"
        ],
        "artifact_paths": [
          "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/converted/postgres.py",
          "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/converted/__init__.py"
        ],
        "conversion_notes": [
          "Selected PostgresV2.node.ts as main node (name match)",
          "Found main node class for Postgres",
          "Found 0 operation handlers",
          "Using 1 parameters from inferred schema",
          "No GenericFunctions.ts found, generating default helpers"
        ],
        "generated_code": {
          "postgres.py": "#!/usr/bin/env python3\n\"\"\"\nPostgres Node\n\nConverted from TypeScript by agent-skills/code-convert\nCorrelation ID: node-postgres-fix32-test\nGenerated: 2026-01-07T08:26:09.993986\n\nSYNC-CELERY SAFE: All methods are synchronous with timeouts.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List\n\nimport requests\n\nfrom .base import BaseNode, NodeParameterType, NodeExecutionData\n\nlogger = logging.getLogger(__name__)\n\n\nclass PostgresNode(BaseNode):\n    \"\"\"\n    Postgres node.\n    \n    \n    \"\"\"\n\n    type = \"postgres\"\n    version = 1\n    \n    description = {\n        \"displayName\": \"Postgres\",\n        \"name\": \"postgres\",\n        \"icon\": \"file:postgres.svg\",\n        \"group\": ['output'],\n        \"description\": \"\",\n        \"inputs\": [{\"name\": \"main\", \"type\": \"main\", \"required\": True}],\n        \"outputs\": [{\"name\": \"main\", \"type\": \"main\", \"required\": True}],\n    }\n    \n    properties = {\n        \"parameters\": [\n            {\"name\": \"resource\", \"type\": NodeParameterType.OPTIONS, \"display_name\": \"Resource\", \"options\": [\n                {\"name\": \"Database\", \"value\": \"database\"}\n            ], \"default\": \"database\", \"description\": \"The resource to operate on\"}\n        ],\n        \"credentials\": [\n            {\"name\": \"postgres\", \"required\": True}\n        ]\n    }\n    \n    icon = \"postgres.svg\"\n\n    def execute(self) -> List[List[NodeExecutionData]]:\n        \"\"\"\n        Execute the node operations.\n        \n        SYNC-CELERY SAFE: All HTTP calls use timeout parameter.\n        \n        Returns:\n            List[List[NodeExecutionData]]: Nested list where outer list is output branches,\n            inner list is items in that branch.\n        \"\"\"\n        # Get input data from previous node\n        input_data = self.get_input_data()\n        \n        # Handle empty input\n        if not input_data:\n            return [[]]\n        \n        return_items: List[NodeExecutionData] = []\n\n        for i, item in enumerate(input_data):\n            try:\n                resource = self.get_node_parameter(\"resource\", i)\n                operation = self.get_node_parameter(\"operation\", i)\n                item_data = item.json_data if hasattr(item, 'json_data') else item.get('json', {})\n                \n                pass\n                else:\n                    raise ValueError(f\"Unknown resource/operation: {resource}/{operation}\")\n                \n                # Handle array results\n                if isinstance(result, list):\n                    for r in result:\n                        return_items.append(NodeExecutionData(json_data=r))\n                else:\n                    return_items.append(NodeExecutionData(json_data=result))\n                \n            except Exception as e:\n                logger.error(f\"Error in {resource}/{operation}: {e}\")\n                if self.node_data.continue_on_fail:\n                    return_items.append(NodeExecutionData(json_data={\"error\": str(e)}))\n                else:\n                    raise\n        \n        return [return_items]\n\"\"\"\nPostgreSQL connection helpers\n\"\"\"\n\nimport logging\nfrom typing import Any, Dict, List, Union\n\nlogger = logging.getLogger(__name__)\n\ndef _get_connection(self) -> Any:\n    \"\"\"\n    Get PostgreSQL database connection\n    \n    Returns:\n        Database connection object\n        \n    Raises:\n        ValueError: If credentials are missing or invalid\n    \"\"\"\n    credentials = self.get_credentials(\"postgres\")\n    if not credentials:\n        raise ValueError(\"PostgreSQL credentials not found\")\n    \n    # Extract connection parameters\n    host = credentials.get(\"host\", \"localhost\")\n    port = credentials.get(\"port\", {\"postgres\": 5432, \"mysql\": 3306, \"mongodb\": 27017}.get(\"postgres\", 5432))\n    database = credentials.get(\"database\", \"\")\n    user = credentials.get(\"user\", \"\")\n    password = credentials.get(\"password\", \"\")\n    ssl = credentials.get(\"ssl\", False)\n    timeout = credentials.get(\"connectionTimeout\", 30)\n    \n    if not database or not user:\n        raise ValueError(\"Database name and user are required\")\n    \n    try:\n        import psycopg\n        from psycopg.rows import dict_row\n        \n        # Build connection string\n        conn_parts = [\n            f\"host={{host}}\",\n            f\"port={{port}}\",\n            f\"dbname={{database}}\",\n            f\"user={{user}}\",\n            f\"password={{password}}\",\n            f\"connect_timeout={{timeout}}\"\n        ]\n        \n        if ssl:\n            conn_parts.append(\"sslmode=require\")\n        else:\n            conn_parts.append(\"sslmode=prefer\")\n        \n        conn_string = \" \".join(conn_parts)\n        \n        # Create connection with dict_row factory for easy JSON conversion\n        conn = psycopg.connect(conn_string, row_factory=dict_row)\n        return conn\n    except Exception as e:\n        logger.error(f\"Failed to connect to database: {str(e)}\")\n        raise ValueError(f\"Failed to connect to database: {str(e)}\")\n\n\n",
          "__init__.py": "\"\"\"\nPostgres Node Package\nConverted from TypeScript by agent-skills/code-convert\n\"\"\"\n\nfrom .postgres import PostgresNode\n\n__all__ = [\"PostgresNode\"]\n"
        }
      },
      "artifacts_produced": [
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/conversion_log.json"
      ],
      "errors": [
        "Advisor code validation failed: 1 file(s) with issues"
      ],
      "skipped_reason": null
    },
    {
      "step_name": "generate-tests",
      "skill_name": "test-generate",
      "status": "completed",
      "started_at": "2026-01-07T08:26:09.997362",
      "completed_at": "2026-01-07T08:26:10.014236",
      "duration_ms": 16,
      "outputs": {
        "stub": true,
        "message": "Skill test-generate has no implementation registered"
      },
      "artifacts_produced": [],
      "errors": [
        "Missing required output: test_files_created",
        "Missing required output: test_count"
      ],
      "skipped_reason": null
    },
    {
      "step_name": "validate",
      "skill_name": "code-validate",
      "status": "failed",
      "started_at": "2026-01-07T08:26:10.014272",
      "completed_at": "2026-01-07T08:26:10.020101",
      "duration_ms": 5,
      "outputs": {},
      "artifacts_produced": [],
      "errors": [
        "Missing required input: test_files",
        "Input validation failed"
      ],
      "skipped_reason": null
    }
  ],
  "outputs": {
    "ingest": {
      "raw_content": "// === File: PostgresV2.node.ts ===\nimport type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\n\nimport { router } from './actions/router';\nimport { versionDescription } from './actions/versionDescription';\nimport { credentialTest, listSearch, loadOptions, resourceMapping } from './methods';\n\nexport class PostgresV2 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t};\n\t}\n\n\tmethods = { credentialTest, listSearch, loadOptions, resourceMapping };\n\n\tasync execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {\n\t\treturn await router.call(this);\n\t}\n}\n\n\n// === File: actions/common.descriptions.ts ===\nimport type { INodeProperties } from 'n8n-workflow';\n\nexport const optionsCollection: INodeProperties = {\n\tdisplayName: 'Options',\n\tname: 'options',\n\ttype: 'collection',\n\tplaceholder: 'Add option',\n\tdefault: {},\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Cascade',\n\t\t\tname: 'cascade',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription:\n\t\t\t\t'Whether to drop all objects that depend on the table, such as views and sequences',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\t'/operation': ['deleteTable'],\n\t\t\t\t},\n\t\t\t\thide: {\n\t\t\t\t\t'/deleteCommand': ['delete'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Connection Timeout',\n\t\t\tname: 'connectionTimeout',\n\t\t\ttype: 'number',\n\t\t\tdefault: 30,\n\t\t\tdescription: 'Number of seconds reserved for connecting to the database',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Delay Closing Idle Connection',\n\t\t\tname: 'delayClosingIdleConnection',\n\t\t\ttype: 'number',\n\t\t\tdefault: 0,\n\t\t\tdescription: 'Number of seconds to wait before idle connection would be eligible for closing',\n\t\t\ttypeOptions: {\n\t\t\t\tminValue: 0,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Query Batching',\n\t\t\tname: 'queryBatching',\n\t\t\ttype: 'options',\n\t\t\tnoDataExpression: true,\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Single Query',\n\t\t\t\t\tvalue: 'single',\n\t\t\t\t\tdescription: 'A single query for all incoming items',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Independent',\n\t\t\t\t\tvalue: 'independently',\n\t\t\t\t\tdescription: 'Execute one query per incoming item of the run',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Transaction',\n\t\t\t\t\tvalue: 'transaction',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Execute all queries in a transaction, if a failure occurs, all changes are rolled back',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'single',\n\t\t\tdescription: 'The way queries should be sent to the database',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Query Parameters',\n\t\t\tname: 'queryReplacement',\n\t\t\ttype: 'string',\n\t\t\tdefault: '',\n\t\t\tdescription:\n\t\t\t\t'Comma-separated list of the values you want to use as query parameters. <a href=\"https://docs.n8n.io/integrations/builtin/app-nodes/n8n-nodes-base.postgres/#use-query-parameters\" target=\"_blank\">More info</a>.',\n\t\t\thint: 'Comma-separated list of values: reference them in your query as $1, $2, $3…',\n\t\t\tplaceholder: 'e.g. value1,value2,value3',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: { '/operation': ['executeQuery'] },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-miscased\n\t\t\tdisplayName: 'Treat query parameters in single quotes as text',\n\t\t\tname: 'treatQueryParametersInSingleQuotesAsText',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription: \"Whether to treat query parameters enclosed in single quotes as text e.g. '$1'\",\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: { queryReplacement: [{ _cnd: { exists: true } }] },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-multi-options\n\t\t\tdisplayName: 'Output Columns',\n\t\t\tname: 'outputColumns',\n\t\t\ttype: 'multiOptions',\n\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-multi-options\n\t\t\tdescription:\n\t\t\t\t'Choose from the list, or specify IDs using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\ttypeOptions: {\n\t\t\t\tloadOptionsMethod: 'getColumnsMultiOptions',\n\t\t\t\tloadOptionsDependsOn: ['table.value'],\n\t\t\t},\n\t\t\tdefault: [],\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: { '/operation': ['select', 'insert', 'update', 'upsert'] },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Output Large-Format Numbers As',\n\t\t\tname: 'largeNumbersOutput',\n\t\t\ttype: 'options',\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Numbers',\n\t\t\t\t\tvalue: 'numbers',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Text',\n\t\t\t\t\tvalue: 'text',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Use this if you expect numbers longer than 16 digits (otherwise numbers may be incorrect)',\n\t\t\t\t},\n\t\t\t],\n\t\t\thint: 'Applies to NUMERIC and BIGINT columns only',\n\t\t\tdefault: 'text',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Skip on Conflict',\n\t\t\tname: 'skipOnConflict',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription:\n\t\t\t\t'Whether to skip the row and do not throw error if a unique constraint or exclusion constraint is violated',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\t'/operation': ['insert'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Replace Empty Strings with NULL',\n\t\t\tname: 'replaceEmptyStrings',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription:\n\t\t\t\t'Whether to replace empty strings with NULL in input, could be useful when data come from spreadsheet',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\t'/operation': ['insert', 'update', 'upsert', 'executeQuery'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t],\n};\n\nexport const schemaRLC: INodeProperties = {\n\tdisplayName: 'Schema',\n\tname: 'schema',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: 'public' },\n\trequired: true,\n\tplaceholder: 'e.g. public',\n\tdescription: 'The schema that contains the table you want to work on',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'From List',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'schemaSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'name',\n\t\t\ttype: 'string',\n\t\t},\n\t],\n};\n\nexport const tableRLC: INodeProperties = {\n\tdisplayName: 'Table',\n\tname: 'table',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'The table you want to work on',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'From List',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'tableSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'name',\n\t\t\ttype: 'string',\n\t\t},\n\t],\n};\n\nexport const whereFixedCollection: INodeProperties = {\n\tdisplayName: 'Select Rows',\n\tname: 'where',\n\ttype: 'fixedCollection',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tplaceholder: 'Add Condition',\n\tdefault: {},\n\tdescription: 'If not set, all rows will be selected',\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\tname: 'column',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\tplaceholder: 'e.g. ID',\n\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Operator',\n\t\t\t\t\tname: 'condition',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"The operator to check the column against. When using 'LIKE' operator percent sign ( %) matches zero or more characters, underscore ( _ ) matches any single character.\",\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-options-type-unsorted-items\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Equal',\n\t\t\t\t\t\t\tvalue: 'equal',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Not Equal',\n\t\t\t\t\t\t\tvalue: '!=',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Like',\n\t\t\t\t\t\t\tvalue: 'LIKE',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Greater Than',\n\t\t\t\t\t\t\tvalue: '>',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Less Than',\n\t\t\t\t\t\t\tvalue: '<',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Greater Than Or Equal',\n\t\t\t\t\t\t\tvalue: '>=',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Less Than Or Equal',\n\t\t\t\t\t\t\tvalue: '<=',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Is Null',\n\t\t\t\t\t\t\tvalue: 'IS NULL',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Is Not Null',\n\t\t\t\t\t\t\tvalue: 'IS NOT NULL',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'equal',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\tname: 'value',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdisplayOptions: {\n\t\t\t\t\t\thide: {\n\t\t\t\t\t\t\tcondition: ['IS NULL', 'IS NOT NULL'],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const sortFixedCollection: INodeProperties = {\n\tdisplayName: 'Sort',\n\tname: 'sort',\n\ttype: 'fixedCollection',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tplaceholder: 'Add Sort Rule',\n\tdefault: {},\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\tname: 'column',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Direction',\n\t\t\t\t\tname: 'direction',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'ASC',\n\t\t\t\t\t\t\tvalue: 'ASC',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'DESC',\n\t\t\t\t\t\t\tvalue: 'DESC',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'ASC',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const combineConditionsCollection: INodeProperties = {\n\tdisplayName: 'Combine Conditions',\n\tname: 'combineConditions',\n\ttype: 'options',\n\tdescription:\n\t\t'How to combine the conditions defined in \"Select Rows\": AND requires all conditions to be true, OR requires at least one condition to be true',\n\toptions: [\n\t\t{\n\t\t\tname: 'AND',\n\t\t\tvalue: 'AND',\n\t\t\tdescription: 'Only rows that meet all the conditions are selected',\n\t\t},\n\t\t{\n\t\t\tname: 'OR',\n\t\t\tvalu",
      "parsed_sections": {
        "class_name": "PostgresV2",
        "node_type": "options",
        "version": null,
        "description": null,
        "properties": [],
        "methods": [
          "execute"
        ],
        "credentials": [
          "postgresConnectionTest"
        ],
        "resources": [
          "database",
          "event"
        ],
        "has_router": true,
        "files": [
          "PostgresV2.node.ts",
          "actions/common.descriptions.ts",
          "actions/database/Database.resource.ts",
          "actions/database/deleteTable.operation.ts",
          "actions/database/executeQuery.operation.ts",
          "actions/database/insert.operation.ts",
          "actions/database/select.operation.ts",
          "actions/database/update.operation.ts",
          "actions/database/upsert.operation.ts",
          "actions/node.type.ts",
          "actions/router.ts",
          "actions/versionDescription.ts",
          "helpers/interfaces.ts",
          "helpers/utils.ts",
          "methods/credentialTest.ts",
          "methods/index.ts",
          "methods/listSearch.ts",
          "methods/loadOptions.ts",
          "methods/resourceMapping.ts"
        ],
        "code": [
          {
            "file": "PostgresV2.node.ts",
            "content": "import type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\n\nimport { router } from './actions/router';\nimport { versionDescription } from './actions/versionDescription';\nimport { credentialTest, listSearch, loadOptions, resourceMapping } from './methods';\n\nexport class PostgresV2 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t};\n\t}\n\n\tmethods = { credentialTest, listSearch, loadOptions, resourceMapping };\n\n\tasync execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {\n\t\treturn await router.call(this);\n\t}\n}\n"
          },
          {
            "file": "actions/common.descriptions.ts",
            "content": "import type { INodeProperties } from 'n8n-workflow';\n\nexport const optionsCollection: INodeProperties = {\n\tdisplayName: 'Options',\n\tname: 'options',\n\ttype: 'collection',\n\tplaceholder: 'Add option',\n\tdefault: {},\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Cascade',\n\t\t\tname: 'cascade',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription:\n\t\t\t\t'Whether to drop all objects that depend on the table, such as views and sequences',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\t'/operation': ['deleteTable'],\n\t\t\t\t},\n\t\t\t\thide: {\n\t\t\t\t\t'/deleteCommand': ['delete'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Connection Timeout',\n\t\t\tname: 'connectionTimeout',\n\t\t\ttype: 'number',\n\t\t\tdefault: 30,\n\t\t\tdescription: 'Number of seconds reserved for connecting to the database',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Delay Closing Idle Connection',\n\t\t\tname: 'delayClosingIdleConnection',\n\t\t\ttype: 'number',\n\t\t\tdefault: 0,\n\t\t\tdescription: 'Number of seconds to wait before idle connection would be eligible for closing',\n\t\t\ttypeOptions: {\n\t\t\t\tminValue: 0,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Query Batching',\n\t\t\tname: 'queryBatching',\n\t\t\ttype: 'options',\n\t\t\tnoDataExpression: true,\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Single Query',\n\t\t\t\t\tvalue: 'single',\n\t\t\t\t\tdescription: 'A single query for all incoming items',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Independent',\n\t\t\t\t\tvalue: 'independently',\n\t\t\t\t\tdescription: 'Execute one query per incoming item of the run',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Transaction',\n\t\t\t\t\tvalue: 'transaction',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Execute all queries in a transaction, if a failure occurs, all changes are rolled back',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'single',\n\t\t\tdescription: 'The way queries should be sent to the database',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Query Parameters',\n\t\t\tname: 'queryReplacement',\n\t\t\ttype: 'string',\n\t\t\tdefault: '',\n\t\t\tdescription:\n\t\t\t\t'Comma-separated list of the values you want to use as query parameters. <a href=\"https://docs.n8n.io/integrations/builtin/app-nodes/n8n-nodes-base.postgres/#use-query-parameters\" target=\"_blank\">More info</a>.',\n\t\t\thint: 'Comma-separated list of values: reference them in your query as $1, $2, $3…',\n\t\t\tplaceholder: 'e.g. value1,value2,value3',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: { '/operation': ['executeQuery'] },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-miscased\n\t\t\tdisplayName: 'Treat query parameters in single quotes as text',\n\t\t\tname: 'treatQueryParametersInSingleQuotesAsText',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription: \"Whether to treat query parameters enclosed in single quotes as text e.g. '$1'\",\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: { queryReplacement: [{ _cnd: { exists: true } }] },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-multi-options\n\t\t\tdisplayName: 'Output Columns',\n\t\t\tname: 'outputColumns',\n\t\t\ttype: 'multiOptions',\n\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-multi-options\n\t\t\tdescription:\n\t\t\t\t'Choose from the list, or specify IDs using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\ttypeOptions: {\n\t\t\t\tloadOptionsMethod: 'getColumnsMultiOptions',\n\t\t\t\tloadOptionsDependsOn: ['table.value'],\n\t\t\t},\n\t\t\tdefault: [],\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: { '/operation': ['select', 'insert', 'update', 'upsert'] },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Output Large-Format Numbers As',\n\t\t\tname: 'largeNumbersOutput',\n\t\t\ttype: 'options',\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Numbers',\n\t\t\t\t\tvalue: 'numbers',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Text',\n\t\t\t\t\tvalue: 'text',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Use this if you expect numbers longer than 16 digits (otherwise numbers may be incorrect)',\n\t\t\t\t},\n\t\t\t],\n\t\t\thint: 'Applies to NUMERIC and BIGINT columns only',\n\t\t\tdefault: 'text',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Skip on Conflict',\n\t\t\tname: 'skipOnConflict',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription:\n\t\t\t\t'Whether to skip the row and do not throw error if a unique constraint or exclusion constraint is violated',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\t'/operation': ['insert'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Replace Empty Strings with NULL',\n\t\t\tname: 'replaceEmptyStrings',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription:\n\t\t\t\t'Whether to replace empty strings with NULL in input, could be useful when data come from spreadsheet',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\t'/operation': ['insert', 'update', 'upsert', 'executeQuery'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t],\n};\n\nexport const schemaRLC: INodeProperties = {\n\tdisplayName: 'Schema',\n\tname: 'schema',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: 'public' },\n\trequired: true,\n\tplaceholder: 'e.g. public',\n\tdescription: 'The schema that contains the table you want to work on',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'From List',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'schemaSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'name',\n\t\t\ttype: 'string',\n\t\t},\n\t],\n};\n\nexport const tableRLC: INodeProperties = {\n\tdisplayName: 'Table',\n\tname: 'table',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'The table you want to work on',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'From List',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'tableSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'name',\n\t\t\ttype: 'string',\n\t\t},\n\t],\n};\n\nexport const whereFixedCollection: INodeProperties = {\n\tdisplayName: 'Select Rows',\n\tname: 'where',\n\ttype: 'fixedCollection',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tplaceholder: 'Add Condition',\n\tdefault: {},\n\tdescription: 'If not set, all rows will be selected',\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\tname: 'column',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\tplaceholder: 'e.g. ID',\n\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Operator',\n\t\t\t\t\tname: 'condition',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"The operator to check the column against. When using 'LIKE' operator percent sign ( %) matches zero or more characters, underscore ( _ ) matches any single character.\",\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-options-type-unsorted-items\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Equal',\n\t\t\t\t\t\t\tvalue: 'equal',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Not Equal',\n\t\t\t\t\t\t\tvalue: '!=',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Like',\n\t\t\t\t\t\t\tvalue: 'LIKE',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Greater Than',\n\t\t\t\t\t\t\tvalue: '>',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Less Than',\n\t\t\t\t\t\t\tvalue: '<',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Greater Than Or Equal',\n\t\t\t\t\t\t\tvalue: '>=',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Less Than Or Equal',\n\t\t\t\t\t\t\tvalue: '<=',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Is Null',\n\t\t\t\t\t\t\tvalue: 'IS NULL',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Is Not Null',\n\t\t\t\t\t\t\tvalue: 'IS NOT NULL',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'equal',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\tname: 'value',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdisplayOptions: {\n\t\t\t\t\t\thide: {\n\t\t\t\t\t\t\tcondition: ['IS NULL', 'IS NOT NULL'],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const sortFixedCollection: INodeProperties = {\n\tdisplayName: 'Sort',\n\tname: 'sort',\n\ttype: 'fixedCollection',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tplaceholder: 'Add Sort Rule',\n\tdefault: {},\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\tname: 'column',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Direction',\n\t\t\t\t\tname: 'direction',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'ASC',\n\t\t\t\t\t\t\tvalue: 'ASC',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'DESC',\n\t\t\t\t\t\t\tvalue: 'DESC',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'ASC',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const combineConditionsCollection: INodeProperties = {\n\tdisplayName: 'Combine Conditions',\n\tname: 'combineConditions',\n\ttype: 'options',\n\tdescription:\n\t\t'How to combine the conditions defined in \"Select Rows\": AND requires all conditions to be true, OR requires at least one condition to be true',\n\toptions: [\n\t\t{\n\t\t\tname: 'AND',\n\t\t\tvalue: 'AND',\n\t\t\tdescription: 'Only rows that meet all the conditions are selected',\n\t\t},\n\t\t{\n\t\t\tname: 'OR',\n\t\t\tvalue: 'OR',\n\t\t\tdescription: 'Rows that meet at least one condition are selected',\n\t\t},\n\t],\n\tdefault: 'AND',\n};\n"
          },
          {
            "file": "actions/database/Database.resource.ts",
            "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport * as deleteTable from './deleteTable.operation';\nimport * as executeQuery from './executeQuery.operation';\nimport * as insert from './insert.operation';\nimport * as select from './select.operation';\nimport * as update from './update.operation';\nimport * as upsert from './upsert.operation';\nimport { schemaRLC, tableRLC } from '../common.descriptions';\n\nexport { deleteTable, executeQuery, insert, select, update, upsert };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Delete',\n\t\t\t\tvalue: 'deleteTable',\n\t\t\t\tdescription: 'Delete an entire table or rows in a table',\n\t\t\t\taction: 'Delete table or rows',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Execute Query',\n\t\t\t\tvalue: 'executeQuery',\n\t\t\t\tdescription: 'Execute an SQL query',\n\t\t\t\taction: 'Execute a SQL query',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Insert',\n\t\t\t\tvalue: 'insert',\n\t\t\t\tdescription: 'Insert rows in a table',\n\t\t\t\taction: 'Insert rows in a table',\n\t\t\t},\n\t\t\t{\n\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-option-name-wrong-for-upsert\n\t\t\t\tname: 'Insert or Update',\n\t\t\t\tvalue: 'upsert',\n\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-upsert\n\t\t\t\tdescription: 'Insert or update rows in a table',\n\t\t\t\taction: 'Insert or update rows in a table',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Select',\n\t\t\t\tvalue: 'select',\n\t\t\t\tdescription: 'Select rows from a table',\n\t\t\t\taction: 'Select rows from a table',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Update',\n\t\t\t\tvalue: 'update',\n\t\t\t\tdescription: 'Update rows in a table',\n\t\t\t\taction: 'Update rows in a table',\n\t\t\t},\n\t\t],\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['database'],\n\t\t\t},\n\t\t},\n\t\tdefault: 'insert',\n\t},\n\t{ ...schemaRLC, displayOptions: { hide: { operation: ['executeQuery'] } } },\n\t{ ...tableRLC, displayOptions: { hide: { operation: ['executeQuery'] } } },\n\t...deleteTable.description,\n\t...executeQuery.description,\n\t...insert.description,\n\t...select.description,\n\t...update.description,\n\t...upsert.description,\n];\n"
          },
          {
            "file": "actions/database/deleteTable.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '@utils/utilities';\n\nimport type {\n\tPgpDatabase,\n\tPostgresNodeOptions,\n\tQueriesRunner,\n\tQueryValues,\n\tQueryWithValues,\n\tWhereClause,\n} from '../../helpers/interfaces';\nimport { addWhereClauses } from '../../helpers/utils';\nimport {\n\tcombineConditionsCollection,\n\toptionsCollection,\n\twhereFixedCollection,\n} from '../common.descriptions';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Command',\n\t\tname: 'deleteCommand',\n\t\ttype: 'options',\n\t\tdefault: 'truncate',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Truncate',\n\t\t\t\tvalue: 'truncate',\n\t\t\t\tdescription: \"Only removes the table's data and preserves the table's structure\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Delete',\n\t\t\t\tvalue: 'delete',\n\t\t\t\tdescription:\n\t\t\t\t\t\"Delete the rows that match the 'Select Rows' conditions below. If no selection is made, all rows in the table are deleted.\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Drop',\n\t\t\t\tvalue: 'drop',\n\t\t\t\tdescription: \"Deletes the table's data and also the table's structure permanently\",\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tdisplayName: 'Restart Sequences',\n\t\tname: 'restartSequences',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tdescription: 'Whether to reset identity (auto-increment) columns to their initial values',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdeleteCommand: ['truncate'],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t...whereFixedCollection,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdeleteCommand: ['delete'],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t...combineConditionsCollection,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdeleteCommand: ['delete'],\n\t\t\t},\n\t\t},\n\t},\n\toptionsCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['database'],\n\t\toperation: ['deleteTable'],\n\t},\n\thide: {\n\t\ttable: [''],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\trunQueries: QueriesRunner,\n\titems: INodeExecutionData[],\n\tnodeOptions: PostgresNodeOptions,\n\t_db?: PgpDatabase,\n): Promise<INodeExecutionData[]> {\n\tconst queries: QueryWithValues[] = [];\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst options = this.getNodeParameter('options', i, {});\n\n\t\tconst schema = this.getNodeParameter('schema', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst table = this.getNodeParameter('table', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst deleteCommand = this.getNodeParameter('deleteCommand', i) as string;\n\n\t\tlet query = '';\n\t\tlet values: QueryValues = [schema, table];\n\n\t\tif (deleteCommand === 'drop') {\n\t\t\tconst cascade = options.cascade ? ' CASCADE' : '';\n\t\t\tquery = `DROP TABLE IF EXISTS $1:name.$2:name${cascade}`;\n\t\t}\n\n\t\tif (deleteCommand === 'truncate') {\n\t\t\tconst identity = this.getNodeParameter('restartSequences', i, false)\n\t\t\t\t? ' RESTART IDENTITY'\n\t\t\t\t: '';\n\t\t\tconst cascade = options.cascade ? ' CASCADE' : '';\n\t\t\tquery = `TRUNCATE TABLE $1:name.$2:name${identity}${cascade}`;\n\t\t}\n\n\t\tif (deleteCommand === 'delete') {\n\t\t\tconst whereClauses =\n\t\t\t\t((this.getNodeParameter('where', i, []) as IDataObject).values as WhereClause[]) || [];\n\n\t\t\tconst combineConditions = this.getNodeParameter('combineConditions', i, 'AND') as string;\n\n\t\t\t[query, values] = addWhereClauses(\n\t\t\t\tthis.getNode(),\n\t\t\t\ti,\n\t\t\t\t'DELETE FROM $1:name.$2:name',\n\t\t\t\twhereClauses,\n\t\t\t\tvalues,\n\t\t\t\tcombineConditions,\n\t\t\t);\n\t\t}\n\n\t\tif (query === '') {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t'Invalid delete command, only drop, delete and truncate are supported ',\n\t\t\t\t{ itemIndex: i },\n\t\t\t);\n\t\t}\n\n\t\tconst queryWithValues = { query, values };\n\n\t\tqueries.push(queryWithValues);\n\t}\n\n\treturn await runQueries(queries, items, nodeOptions);\n}\n"
          },
          {
            "file": "actions/database/executeQuery.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport { getResolvables, updateDisplayOptions } from '@utils/utilities';\n\nimport type {\n\tPgpDatabase,\n\tPostgresNodeOptions,\n\tQueriesRunner,\n\tQueryWithValues,\n} from '../../helpers/interfaces';\nimport {\n\tevaluateExpression,\n\tisJSON,\n\treplaceEmptyStringsByNulls,\n\tstringToArray,\n} from '../../helpers/utils';\nimport { optionsCollection } from '../common.descriptions';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Query',\n\t\tname: 'query',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tplaceholder: 'e.g. SELECT id, name FROM product WHERE quantity > $1 AND price <= $2',\n\t\tnoDataExpression: true,\n\t\trequired: true,\n\t\tdescription:\n\t\t\t\"The SQL query to execute. You can use n8n expressions and $1, $2, $3, etc to refer to the 'Query Parameters' set in options below.\",\n\t\ttypeOptions: {\n\t\t\teditor: 'sqlEditor',\n\t\t\tsqlDialect: 'PostgreSQL',\n\t\t},\n\t\thint: 'Consider using query parameters to prevent SQL injection attacks. Add them in the options below',\n\t},\n\toptionsCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['database'],\n\t\toperation: ['executeQuery'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\trunQueries: QueriesRunner,\n\titems: INodeExecutionData[],\n\tnodeOptions: PostgresNodeOptions,\n\t_db?: PgpDatabase,\n): Promise<INodeExecutionData[]> {\n\tconst queries: QueryWithValues[] = replaceEmptyStringsByNulls(\n\t\titems,\n\t\tnodeOptions.replaceEmptyStrings as boolean,\n\t).map((_, index) => {\n\t\tlet query = this.getNodeParameter('query', index) as string;\n\n\t\tfor (const resolvable of getResolvables(query)) {\n\t\t\tquery = query.replace(resolvable, this.evaluateExpression(resolvable, index) as string);\n\t\t}\n\n\t\tlet values: Array<IDataObject | string> = [];\n\n\t\tlet queryReplacement = this.getNodeParameter('options.queryReplacement', index, '');\n\n\t\tif (typeof queryReplacement === 'number') {\n\t\t\tqueryReplacement = String(queryReplacement);\n\t\t}\n\n\t\tif (typeof queryReplacement === 'string') {\n\t\t\tconst node = this.getNode();\n\n\t\t\tconst rawReplacements = (node.parameters.options as IDataObject)?.queryReplacement as string;\n\n\t\t\tif (rawReplacements) {\n\t\t\t\tconst nodeVersion = nodeOptions.nodeVersion as number;\n\n\t\t\t\tif (nodeVersion >= 2.5) {\n\t\t\t\t\tconst rawValues = rawReplacements.replace(/^=+/, '');\n\t\t\t\t\tconst resolvables = getResolvables(rawValues);\n\t\t\t\t\tif (resolvables.length) {\n\t\t\t\t\t\tfor (const resolvable of resolvables) {\n\t\t\t\t\t\t\tconst evaluatedExpression = evaluateExpression(\n\t\t\t\t\t\t\t\tthis.evaluateExpression(`${resolvable}`, index),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst evaluatedValues = isJSON(evaluatedExpression)\n\t\t\t\t\t\t\t\t? [evaluatedExpression]\n\t\t\t\t\t\t\t\t: stringToArray(evaluatedExpression);\n\n\t\t\t\t\t\t\tif (evaluatedValues.length) values.push(...evaluatedValues);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalues.push(...stringToArray(rawValues));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst rawValues = rawReplacements\n\t\t\t\t\t\t.replace(/^=+/, '')\n\t\t\t\t\t\t.split(',')\n\t\t\t\t\t\t.filter((entry) => entry)\n\t\t\t\t\t\t.map((entry) => entry.trim());\n\n\t\t\t\t\tfor (const rawValue of rawValues) {\n\t\t\t\t\t\tconst resolvables = getResolvables(rawValue);\n\n\t\t\t\t\t\tif (resolvables.length) {\n\t\t\t\t\t\t\tfor (const resolvable of resolvables) {\n\t\t\t\t\t\t\t\tvalues.push(this.evaluateExpression(`${resolvable}`, index) as IDataObject);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalues.push(rawValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (Array.isArray(queryReplacement)) {\n\t\t\t\tvalues = queryReplacement as IDataObject[];\n\t\t\t} else {\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t'Query Parameters must be a string of comma-separated values or an array of values',\n\t\t\t\t\t{ itemIndex: index },\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (!queryReplacement || nodeOptions.treatQueryParametersInSingleQuotesAsText) {\n\t\t\tlet nextValueIndex = values.length + 1;\n\t\t\tconst literals = query.match(/'\\$[0-9]+'/g) ?? [];\n\t\t\tfor (const literal of literals) {\n\t\t\t\tquery = query.replace(literal, `$${nextValueIndex}`);\n\t\t\t\tvalues.push(literal.replace(/'/g, ''));\n\t\t\t\tnextValueIndex++;\n\t\t\t}\n\t\t}\n\n\t\treturn { query, values, options: { partial: true } };\n\t});\n\n\treturn await runQueries(queries, items, nodeOptions);\n}\n"
          },
          {
            "file": "actions/database/insert.operation.ts",
            "content": "import {\n\ttype IDataObject,\n\ttype IExecuteFunctions,\n\ttype INodeExecutionData,\n\ttype INodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '@utils/utilities';\n\nimport type {\n\tPgpClient,\n\tPgpDatabase,\n\tPostgresNodeOptions,\n\tQueriesRunner,\n\tQueryValues,\n\tQueryWithValues,\n} from '../../helpers/interfaces';\nimport {\n\taddReturning,\n\tcheckItemAgainstSchema,\n\tconfigureTableSchemaUpdater,\n\tgetTableSchema,\n\tprepareItem,\n\tconvertArraysToPostgresFormat,\n\treplaceEmptyStringsByNulls,\n\thasJsonDataTypeInSchema,\n\tconvertValuesToJsonWithPgp,\n} from '../../helpers/utils';\nimport { optionsCollection } from '../common.descriptions';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Data Mode',\n\t\tname: 'dataMode',\n\t\ttype: 'options',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Auto-Map Input Data to Columns',\n\t\t\t\tvalue: 'autoMapInputData',\n\t\t\t\tdescription: 'Use when node input properties names exactly match the table column names',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Map Each Column Manually',\n\t\t\t\tvalue: 'defineBelow',\n\t\t\t\tdescription: 'Set the value for each destination column manually',\n\t\t\t},\n\t\t],\n\t\tdefault: 'autoMapInputData',\n\t\tdescription:\n\t\t\t'Whether to map node input properties and the table data automatically or manually',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: `\n\t\tIn this mode, make sure incoming data fields are named the same as the columns in your table. If needed, use an 'Edit Fields' node before this node to change the field names.\n\t\t`,\n\t\tname: 'notice',\n\t\ttype: 'notice',\n\t\tdefault: '',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['autoMapInputData'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Values to Send',\n\t\tname: 'valuesToSend',\n\t\tplaceholder: 'Add Value',\n\t\ttype: 'fixedCollection',\n\t\ttypeOptions: {\n\t\t\tmultipleValueButtonText: 'Add Value',\n\t\t\tmultipleValues: true,\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['defineBelow'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Values',\n\t\t\t\tname: 'values',\n\t\t\t\tvalues: [\n\t\t\t\t\t{\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\t\tname: 'column',\n\t\t\t\t\t\ttype: 'options',\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdefault: [],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\t\tname: 'value',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tdisplayName: 'Columns',\n\t\tname: 'columns',\n\t\ttype: 'resourceMapper',\n\t\tdefault: {\n\t\t\tmappingMode: 'defineBelow',\n\t\t\tvalue: null,\n\t\t},\n\t\tnoDataExpression: true,\n\t\trequired: true,\n\t\ttypeOptions: {\n\t\t\tloadOptionsDependsOn: ['table.value', 'operation'],\n\t\t\tresourceMapper: {\n\t\t\t\tresourceMapperMethod: 'getMappingColumns',\n\t\t\t\tmode: 'add',\n\t\t\t\tfieldWords: {\n\t\t\t\t\tsingular: 'column',\n\t\t\t\t\tplural: 'columns',\n\t\t\t\t},\n\t\t\t\taddAllFields: true,\n\t\t\t\tmultiKeyMatch: true,\n\t\t\t},\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [{ _cnd: { gte: 2.2 } }],\n\t\t\t},\n\t\t},\n\t},\n\toptionsCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['database'],\n\t\toperation: ['insert'],\n\t},\n\thide: {\n\t\ttable: [''],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\trunQueries: QueriesRunner,\n\titems: INodeExecutionData[],\n\tnodeOptions: PostgresNodeOptions,\n\tdb: PgpDatabase,\n\tpgp: PgpClient,\n): Promise<INodeExecutionData[]> {\n\titems = replaceEmptyStringsByNulls(items, nodeOptions.replaceEmptyStrings as boolean);\n\tconst nodeVersion = nodeOptions.nodeVersion as number;\n\n\tlet schema = this.getNodeParameter('schema', 0, undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tlet table = this.getNodeParameter('table', 0, undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst updateTableSchema = configureTableSchemaUpdater(schema, table);\n\n\tlet tableSchema = await getTableSchema(db, schema, table);\n\n\tconst queries: QueryWithValues[] = [];\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tschema = this.getNodeParameter('schema', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\ttable = this.getNodeParameter('table', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst options = this.getNodeParameter('options', i, {});\n\n\t\tlet onConflict = '';\n\t\tif (options.skipOnConflict) {\n\t\t\tonConflict = ' ON CONFLICT DO NOTHING';\n\t\t}\n\n\t\tlet query = `INSERT INTO $1:name.$2:name($3:name) VALUES($3:csv)${onConflict}`;\n\t\tlet values: QueryValues = [schema, table];\n\n\t\tconst dataMode =\n\t\t\tnodeVersion < 2.2\n\t\t\t\t? (this.getNodeParameter('dataMode', i) as string)\n\t\t\t\t: (this.getNodeParameter('columns.mappingMode', i) as string);\n\n\t\tlet item: IDataObject = {};\n\n\t\tif (dataMode === 'autoMapInputData') {\n\t\t\titem = items[i].json;\n\t\t}\n\n\t\tif (dataMode === 'defineBelow') {\n\t\t\tconst valuesToSend =\n\t\t\t\tnodeVersion < 2.2\n\t\t\t\t\t? ((this.getNodeParameter('valuesToSend', i, []) as IDataObject).values as IDataObject[])\n\t\t\t\t\t: ((this.getNodeParameter('columns.values', i, []) as IDataObject)\n\t\t\t\t\t\t\t.values as IDataObject[]);\n\n\t\t\titem =\n\t\t\t\tnodeVersion < 2.2\n\t\t\t\t\t? prepareItem(valuesToSend)\n\t\t\t\t\t: hasJsonDataTypeInSchema(tableSchema)\n\t\t\t\t\t\t? convertValuesToJsonWithPgp(\n\t\t\t\t\t\t\t\tpgp,\n\t\t\t\t\t\t\t\ttableSchema,\n\t\t\t\t\t\t\t\t(this.getNodeParameter('columns', i) as IDataObject)?.value as IDataObject,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: (this.getNodeParameter('columns.value', i) as IDataObject);\n\t\t}\n\n\t\ttableSchema = await updateTableSchema(db, tableSchema, schema, table);\n\n\t\tif (nodeVersion >= 2.4) {\n\t\t\tconvertArraysToPostgresFormat(item, tableSchema, this.getNode(), i);\n\t\t}\n\n\t\tvalues.push(checkItemAgainstSchema(this.getNode(), item, tableSchema, i));\n\n\t\tconst outputColumns = this.getNodeParameter('options.outputColumns', i, ['*']) as string[];\n\n\t\tif (nodeVersion >= 2.6 && Object.keys(item).length === 0) {\n\t\t\tquery = 'INSERT INTO $1:name.$2:name DEFAULT VALUES';\n\t\t}\n\n\t\t[query, values] = addReturning(query, outputColumns, values);\n\n\t\tqueries.push({ query, values });\n\t}\n\n\treturn await runQueries(queries, items, nodeOptions);\n}\n"
          },
          {
            "file": "actions/database/select.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '@utils/utilities';\n\nimport type {\n\tPgpDatabase,\n\tPostgresNodeOptions,\n\tQueriesRunner,\n\tQueryValues,\n\tQueryWithValues,\n\tSortRule,\n\tWhereClause,\n} from '../../helpers/interfaces';\nimport { addSortRules, addWhereClauses, replaceEmptyStringsByNulls } from '../../helpers/utils';\nimport {\n\tcombineConditionsCollection,\n\toptionsCollection,\n\tsortFixedCollection,\n\twhereFixedCollection,\n} from '../common.descriptions';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Return All',\n\t\tname: 'returnAll',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tdescription: 'Whether to return all results or only up to a given limit',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['event'],\n\t\t\t\toperation: ['getAll'],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Limit',\n\t\tname: 'limit',\n\t\ttype: 'number',\n\t\tdefault: 50,\n\t\tdescription: 'Max number of results to return',\n\t\ttypeOptions: {\n\t\t\tminValue: 1,\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\treturnAll: [false],\n\t\t\t},\n\t\t},\n\t},\n\twhereFixedCollection,\n\tcombineConditionsCollection,\n\tsortFixedCollection,\n\toptionsCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['database'],\n\t\toperation: ['select'],\n\t},\n\thide: {\n\t\ttable: [''],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\trunQueries: QueriesRunner,\n\titems: INodeExecutionData[],\n\tnodeOptions: PostgresNodeOptions,\n\t_db?: PgpDatabase,\n): Promise<INodeExecutionData[]> {\n\titems = replaceEmptyStringsByNulls(items, nodeOptions.replaceEmptyStrings as boolean);\n\n\tconst queries: QueryWithValues[] = [];\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst schema = this.getNodeParameter('schema', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst table = this.getNodeParameter('table', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tlet values: QueryValues = [schema, table];\n\n\t\tconst outputColumns = this.getNodeParameter('options.outputColumns', i, ['*']) as string[];\n\n\t\tlet query = '';\n\n\t\tif (outputColumns.includes('*')) {\n\t\t\tquery = 'SELECT * FROM $1:name.$2:name';\n\t\t} else {\n\t\t\tvalues.push(outputColumns);\n\t\t\tquery = `SELECT $${values.length}:name FROM $1:name.$2:name`;\n\t\t}\n\n\t\tconst whereClauses =\n\t\t\t((this.getNodeParameter('where', i, []) as IDataObject).values as WhereClause[]) || [];\n\n\t\tconst combineConditions = this.getNodeParameter('combineConditions', i, 'AND') as string;\n\n\t\t[query, values] = addWhereClauses(\n\t\t\tthis.getNode(),\n\t\t\ti,\n\t\t\tquery,\n\t\t\twhereClauses,\n\t\t\tvalues,\n\t\t\tcombineConditions,\n\t\t);\n\n\t\tconst sortRules =\n\t\t\t((this.getNodeParameter('sort', i, []) as IDataObject).values as SortRule[]) || [];\n\n\t\t[query, values] = addSortRules(query, sortRules, values);\n\n\t\tconst returnAll = this.getNodeParameter('returnAll', i, false);\n\t\tif (!returnAll) {\n\t\t\tconst limit = this.getNodeParameter('limit', i, 50);\n\t\t\tquery += ` LIMIT ${limit}`;\n\t\t}\n\n\t\tconst queryWithValues = { query, values };\n\t\tqueries.push(queryWithValues);\n\t}\n\n\treturn await runQueries(queries, items, nodeOptions);\n}\n"
          },
          {
            "file": "actions/database/update.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '@utils/utilities';\n\nimport type {\n\tPgpDatabase,\n\tPostgresNodeOptions,\n\tQueriesRunner,\n\tQueryValues,\n\tQueryWithValues,\n} from '../../helpers/interfaces';\nimport {\n\taddReturning,\n\tcheckItemAgainstSchema,\n\tconfigureTableSchemaUpdater,\n\tdoesRowExist,\n\tgetTableSchema,\n\tprepareItem,\n\tconvertArraysToPostgresFormat,\n\treplaceEmptyStringsByNulls,\n} from '../../helpers/utils';\nimport { optionsCollection } from '../common.descriptions';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Data Mode',\n\t\tname: 'dataMode',\n\t\ttype: 'options',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Auto-Map Input Data to Columns',\n\t\t\t\tvalue: 'autoMapInputData',\n\t\t\t\tdescription: 'Use when node input properties names exactly match the table column names',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Map Each Column Manually',\n\t\t\t\tvalue: 'defineBelow',\n\t\t\t\tdescription: 'Set the value for each destination column manually',\n\t\t\t},\n\t\t],\n\t\tdefault: 'autoMapInputData',\n\t\tdescription:\n\t\t\t'Whether to map node input properties and the table data automatically or manually',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: `\n\t\tIn this mode, make sure incoming data fields are named the same as the columns in your table. If needed, use an 'Edit Fields' node before this node to change the field names.\n\t\t`,\n\t\tname: 'notice',\n\t\ttype: 'notice',\n\t\tdefault: '',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['autoMapInputData'],\n\t\t\t\t'@version': [2],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\tdisplayName: 'Column to Match On',\n\t\tname: 'columnToMatchOn',\n\t\ttype: 'options',\n\t\trequired: true,\n\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\tdescription:\n\t\t\t'The column to compare when finding the rows to update. Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>.',\n\t\ttypeOptions: {\n\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t},\n\t\tdefault: '',\n\t\thint: 'The column to use when matching rows in Postgres to the input items of this node. Usually an ID.',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Value of Column to Match On',\n\t\tname: 'valueToMatchOn',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription:\n\t\t\t'Rows with a value in the specified \"Column to Match On\" that corresponds to the value in this field will be updated',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['defineBelow'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Values to Send',\n\t\tname: 'valuesToSend',\n\t\tplaceholder: 'Add Value',\n\t\ttype: 'fixedCollection',\n\t\ttypeOptions: {\n\t\t\tmultipleValueButtonText: 'Add Value',\n\t\t\tmultipleValues: true,\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['defineBelow'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Values',\n\t\t\t\tname: 'values',\n\t\t\t\tvalues: [\n\t\t\t\t\t{\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\t\tname: 'column',\n\t\t\t\t\t\ttype: 'options',\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\t\tloadOptionsMethod: 'getColumnsWithoutColumnToMatchOn',\n\t\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdefault: [],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\t\tname: 'value',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tdisplayName: 'Columns',\n\t\tname: 'columns',\n\t\ttype: 'resourceMapper',\n\t\tnoDataExpression: true,\n\t\tdefault: {\n\t\t\tmappingMode: 'defineBelow',\n\t\t\tvalue: null,\n\t\t},\n\t\trequired: true,\n\t\ttypeOptions: {\n\t\t\tloadOptionsDependsOn: ['table.value', 'operation'],\n\t\t\tresourceMapper: {\n\t\t\t\tresourceMapperMethod: 'getMappingColumns',\n\t\t\t\tmode: 'update',\n\t\t\t\tfieldWords: {\n\t\t\t\t\tsingular: 'column',\n\t\t\t\t\tplural: 'columns',\n\t\t\t\t},\n\t\t\t\taddAllFields: true,\n\t\t\t\tmultiKeyMatch: true,\n\t\t\t},\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [{ _cnd: { gte: 2.2 } }],\n\t\t\t},\n\t\t},\n\t},\n\toptionsCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['database'],\n\t\toperation: ['update'],\n\t},\n\thide: {\n\t\ttable: [''],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\trunQueries: QueriesRunner,\n\titems: INodeExecutionData[],\n\tnodeOptions: PostgresNodeOptions,\n\tdb: PgpDatabase,\n): Promise<INodeExecutionData[]> {\n\titems = replaceEmptyStringsByNulls(items, nodeOptions.replaceEmptyStrings as boolean);\n\tconst nodeVersion = nodeOptions.nodeVersion as number;\n\n\tlet schema = this.getNodeParameter('schema', 0, undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tlet table = this.getNodeParameter('table', 0, undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst updateTableSchema = configureTableSchemaUpdater(schema, table);\n\n\tlet tableSchema = await getTableSchema(db, schema, table);\n\n\tconst queries: QueryWithValues[] = [];\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tschema = this.getNodeParameter('schema', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\ttable = this.getNodeParameter('table', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst columnsToMatchOn: string[] =\n\t\t\tnodeVersion < 2.2\n\t\t\t\t? [this.getNodeParameter('columnToMatchOn', i) as string]\n\t\t\t\t: (this.getNodeParameter('columns.matchingColumns', i) as string[]);\n\n\t\tconst dataMode =\n\t\t\tnodeVersion < 2.2\n\t\t\t\t? (this.getNodeParameter('dataMode', i) as string)\n\t\t\t\t: (this.getNodeParameter('columns.mappingMode', i) as string);\n\n\t\tlet item: IDataObject = {};\n\t\tlet valueToMatchOn: string | IDataObject = '';\n\t\tif (nodeVersion < 2.2) {\n\t\t\tvalueToMatchOn = this.getNodeParameter('valueToMatchOn', i) as string;\n\t\t}\n\n\t\tif (dataMode === 'autoMapInputData') {\n\t\t\titem = items[i].json;\n\t\t\tif (nodeVersion < 2.2) {\n\t\t\t\tvalueToMatchOn = item[columnsToMatchOn[0]] as string;\n\t\t\t}\n\t\t}\n\n\t\tif (dataMode === 'defineBelow') {\n\t\t\tconst valuesToSend =\n\t\t\t\tnodeVersion < 2.2\n\t\t\t\t\t? ((this.getNodeParameter('valuesToSend', i, []) as IDataObject).values as IDataObject[])\n\t\t\t\t\t: ((this.getNodeParameter('columns.values', i, []) as IDataObject)\n\t\t\t\t\t\t\t.values as IDataObject[]);\n\n\t\t\tif (nodeVersion < 2.2) {\n\t\t\t\titem = prepareItem(valuesToSend);\n\t\t\t\titem[columnsToMatchOn[0]] = this.getNodeParameter('valueToMatchOn', i) as string;\n\t\t\t} else {\n\t\t\t\titem = this.getNodeParameter('columns.value', i) as IDataObject;\n\t\t\t}\n\t\t}\n\n\t\tconst matchValues: string[] = [];\n\t\tif (nodeVersion < 2.2) {\n\t\t\tif (!item[columnsToMatchOn[0]] && dataMode === 'autoMapInputData') {\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t\"Column to match on not found in input item. Add a column to match on or set the 'Data Mode' to 'Define Below' to define the value to match on.\",\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchValues.push(valueToMatchOn);\n\t\t\tmatchValues.push(columnsToMatchOn[0]);\n\t\t} else {\n\t\t\tcolumnsToMatchOn.forEach((column) => {\n\t\t\t\tmatchValues.push(column);\n\t\t\t\tmatchValues.push(item[column] as string);\n\t\t\t});\n\t\t\tconst rowExists = await doesRowExist(db, schema, table, matchValues);\n\t\t\tif (!rowExists) {\n\t\t\t\tconst descriptionValues: string[] = [];\n\t\t\t\tmatchValues.forEach((_, index) => {\n\t\t\t\t\tif (index % 2 === 0) {\n\t\t\t\t\t\tdescriptionValues.push(`${matchValues[index]}=${matchValues[index + 1]}`);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t\"The row you are trying to update doesn't exist\",\n\t\t\t\t\t{\n\t\t\t\t\t\tdescription: `No rows matching the provided values (${descriptionValues.join(\n\t\t\t\t\t\t\t', ',\n\t\t\t\t\t\t)}) were found in the table \"${table}\".`,\n\t\t\t\t\t\titemIndex: i,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\ttableSchema = await updateTableSchema(db, tableSchema, schema, table);\n\n\t\tif (nodeVersion >= 2.4) {\n\t\t\tconvertArraysToPostgresFormat(item, tableSchema, this.getNode(), i);\n\t\t}\n\n\t\titem = checkItemAgainstSchema(this.getNode(), item, tableSchema, i);\n\n\t\tlet values: QueryValues = [schema, table];\n\n\t\tlet valuesLength = values.length + 1;\n\n\t\tlet condition = '';\n\t\tif (nodeVersion < 2.2) {\n\t\t\tcondition = `$${valuesLength}:name = $${valuesLength + 1}`;\n\t\t\tvaluesLength = valuesLength + 2;\n\t\t\tvalues.push(columnsToMatchOn[0], valueToMatchOn);\n\t\t} else {\n\t\t\tconst conditions: string[] = [];\n\t\t\tfor (const column of columnsToMatchOn) {\n\t\t\t\tconditions.push(`$${valuesLength}:name = $${valuesLength + 1}`);\n\t\t\t\tvaluesLength = valuesLength + 2;\n\t\t\t\tvalues.push(column, item[column] as string);\n\t\t\t}\n\t\t\tcondition = conditions.join(' AND ');\n\t\t}\n\n\t\tconst updateColumns = Object.keys(item).filter((column) => !columnsToMatchOn.includes(column));\n\n\t\tif (!Object.keys(updateColumns).length) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t\"Add values to update to the input item or set the 'Data Mode' to 'Define Below' to define the values to update.\",\n\t\t\t);\n\t\t}\n\n\t\tconst updates: string[] = [];\n\n\t\tfor (const column of updateColumns) {\n\t\t\tupdates.push(`$${valuesLength}:name = $${valuesLength + 1}`);\n\t\t\tvaluesLength = valuesLength + 2;\n\t\t\tvalues.push(column, item[column] as string);\n\t\t}\n\n\t\tlet query = `UPDATE $1:name.$2:name SET ${updates.join(', ')} WHERE ${condition}`;\n\n\t\tconst outputColumns = this.getNodeParameter('options.outputColumns', i, ['*']) as string[];\n\n\t\t[query, values] = addReturning(query, outputColumns, values);\n\n\t\tqueries.push({ query, values });\n\t}\n\n\tconst results = await runQueries(queries, items, nodeOptions);\n\treturn results;\n}\n"
          },
          {
            "file": "actions/database/upsert.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '@utils/utilities';\n\nimport type {\n\tPgpDatabase,\n\tPostgresNodeOptions,\n\tQueriesRunner,\n\tQueryValues,\n\tQueryWithValues,\n} from '../../helpers/interfaces';\nimport {\n\taddReturning,\n\tcheckItemAgainstSchema,\n\tgetTableSchema,\n\tprepareItem,\n\treplaceEmptyStringsByNulls,\n\tconfigureTableSchemaUpdater,\n\tconvertArraysToPostgresFormat,\n} from '../../helpers/utils';\nimport { optionsCollection } from '../common.descriptions';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Data Mode',\n\t\tname: 'dataMode',\n\t\ttype: 'options',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Auto-Map Input Data to Columns',\n\t\t\t\tvalue: 'autoMapInputData',\n\t\t\t\tdescription: 'Use when node input properties names exactly match the table column names',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Map Each Column Manually',\n\t\t\t\tvalue: 'defineBelow',\n\t\t\t\tdescription: 'Set the value for each destination column manually',\n\t\t\t},\n\t\t],\n\t\tdefault: 'autoMapInputData',\n\t\tdescription:\n\t\t\t'Whether to map node input properties and the table data automatically or manually',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: `\n\t\tIn this mode, make sure incoming data fields are named the same as the columns in your table. If needed, use an 'Edit Fields' node before this node to change the field names.\n\t\t`,\n\t\tname: 'notice',\n\t\ttype: 'notice',\n\t\tdefault: '',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['autoMapInputData'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\tdisplayName: 'Unique Column',\n\t\tname: 'columnToMatchOn',\n\t\ttype: 'options',\n\t\trequired: true,\n\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\tdescription:\n\t\t\t'The column to compare when finding the rows to update. Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>.',\n\t\ttypeOptions: {\n\t\t\tloadOptionsMethod: 'getColumns',\n\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t},\n\t\tdefault: '',\n\t\thint: \"Used to find the correct row(s) to update. Doesn't get changed. Has to be unique.\",\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Value of Unique Column',\n\t\tname: 'valueToMatchOn',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription:\n\t\t\t'Rows with a value in the specified \"Column to Match On\" that corresponds to the value in this field will be updated. New rows will be created for non-matching items.',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['defineBelow'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Values to Send',\n\t\tname: 'valuesToSend',\n\t\tplaceholder: 'Add Value',\n\t\ttype: 'fixedCollection',\n\t\ttypeOptions: {\n\t\t\tmultipleValueButtonText: 'Add Value',\n\t\t\tmultipleValues: true,\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tdataMode: ['defineBelow'],\n\t\t\t\t'@version': [2, 2.1],\n\t\t\t},\n\t\t},\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Values',\n\t\t\t\tname: 'values',\n\t\t\t\tvalues: [\n\t\t\t\t\t{\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options\n\t\t\t\t\t\tdisplayName: 'Column',\n\t\t\t\t\t\tname: 'column',\n\t\t\t\t\t\ttype: 'options',\n\t\t\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-options\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'Choose from the list, or specify an ID using an <a href=\"https://docs.n8n.io/code/expressions/\" target=\"_blank\">expression</a>',\n\t\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\t\tloadOptionsMethod: 'getColumnsWithoutColumnToMatchOn',\n\t\t\t\t\t\t\tloadOptionsDependsOn: ['schema.value', 'table.value'],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdefault: [],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\t\tname: 'value',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tdisplayName: 'Columns',\n\t\tname: 'columns',\n\t\ttype: 'resourceMapper',\n\t\tnoDataExpression: true,\n\t\tdefault: {\n\t\t\tmappingMode: 'defineBelow',\n\t\t\tvalue: null,\n\t\t},\n\t\trequired: true,\n\t\ttypeOptions: {\n\t\t\tloadOptionsDependsOn: ['table.value', 'operation'],\n\t\t\tresourceMapper: {\n\t\t\t\tresourceMapperMethod: 'getMappingColumns',\n\t\t\t\tmode: 'upsert',\n\t\t\t\tfieldWords: {\n\t\t\t\t\tsingular: 'column',\n\t\t\t\t\tplural: 'columns',\n\t\t\t\t},\n\t\t\t\taddAllFields: true,\n\t\t\t\tmultiKeyMatch: true,\n\t\t\t},\n\t\t},\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\t'@version': [{ _cnd: { gte: 2.2 } }],\n\t\t\t},\n\t\t},\n\t},\n\toptionsCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['database'],\n\t\toperation: ['upsert'],\n\t},\n\thide: {\n\t\ttable: [''],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\trunQueries: QueriesRunner,\n\titems: INodeExecutionData[],\n\tnodeOptions: PostgresNodeOptions,\n\tdb: PgpDatabase,\n): Promise<INodeExecutionData[]> {\n\titems = replaceEmptyStringsByNulls(items, nodeOptions.replaceEmptyStrings as boolean);\n\tconst nodeVersion = nodeOptions.nodeVersion as number;\n\n\tlet schema = this.getNodeParameter('schema', 0, undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tlet table = this.getNodeParameter('table', 0, undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst updateTableSchema = configureTableSchemaUpdater(schema, table);\n\n\tlet tableSchema = await getTableSchema(db, schema, table);\n\n\tconst queries: QueryWithValues[] = [];\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tschema = this.getNodeParameter('schema', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\ttable = this.getNodeParameter('table', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst columnsToMatchOn: string[] =\n\t\t\tnodeVersion < 2.2\n\t\t\t\t? [this.getNodeParameter('columnToMatchOn', i) as string]\n\t\t\t\t: (this.getNodeParameter('columns.matchingColumns', i) as string[]);\n\n\t\tconst dataMode =\n\t\t\tnodeVersion < 2.2\n\t\t\t\t? (this.getNodeParameter('dataMode', i) as string)\n\t\t\t\t: (this.getNodeParameter('columns.mappingMode', i) as string);\n\n\t\tlet item: IDataObject = {};\n\n\t\tif (dataMode === 'autoMapInputData') {\n\t\t\titem = items[i].json;\n\t\t}\n\n\t\tif (dataMode === 'defineBelow') {\n\t\t\tconst valuesToSend =\n\t\t\t\tnodeVersion < 2.2\n\t\t\t\t\t? ((this.getNodeParameter('valuesToSend', i, []) as IDataObject).values as IDataObject[])\n\t\t\t\t\t: ((this.getNodeParameter('columns.values', i, []) as IDataObject)\n\t\t\t\t\t\t\t.values as IDataObject[]);\n\n\t\t\tif (nodeVersion < 2.2) {\n\t\t\t\titem = prepareItem(valuesToSend);\n\t\t\t\titem[columnsToMatchOn[0]] = this.getNodeParameter('valueToMatchOn', i) as string;\n\t\t\t} else {\n\t\t\t\titem = this.getNodeParameter('columns.value', i) as IDataObject;\n\t\t\t}\n\t\t}\n\n\t\tif (!item[columnsToMatchOn[0]]) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t\"Column to match on not found in input item. Add a column to match on or set the 'Data Mode' to 'Define Below' to define the value to match on.\",\n\t\t\t);\n\t\t}\n\n\t\tif (item[columnsToMatchOn[0]] && Object.keys(item).length === 1) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t\"Add values to update or insert to the input item or set the 'Data Mode' to 'Define Below' to define the values to insert or update.\",\n\t\t\t);\n\t\t}\n\n\t\ttableSchema = await updateTableSchema(db, tableSchema, schema, table);\n\n\t\tif (nodeVersion >= 2.4) {\n\t\t\tconvertArraysToPostgresFormat(item, tableSchema, this.getNode(), i);\n\t\t}\n\n\t\titem = checkItemAgainstSchema(this.getNode(), item, tableSchema, i);\n\n\t\tlet values: QueryValues = [schema, table];\n\n\t\tlet valuesLength = values.length + 1;\n\t\tconst conflictColumns: string[] = [];\n\t\tcolumnsToMatchOn.forEach((column) => {\n\t\t\tconflictColumns.push(`$${valuesLength}:name`);\n\t\t\tvaluesLength = valuesLength + 1;\n\t\t\tvalues.push(column);\n\t\t});\n\t\tconst onConflict = ` ON CONFLICT (${conflictColumns.join(',')})`;\n\n\t\tconst insertQuery = `INSERT INTO $1:name.$2:name($${valuesLength}:name) VALUES($${valuesLength}:csv)${onConflict}`;\n\t\tvaluesLength = valuesLength + 1;\n\t\tvalues.push(item);\n\n\t\tconst updateColumns = Object.keys(item).filter((column) => !columnsToMatchOn.includes(column));\n\t\tconst updates: string[] = [];\n\n\t\tfor (const column of updateColumns) {\n\t\t\tupdates.push(`$${valuesLength}:name = $${valuesLength + 1}`);\n\t\t\tvaluesLength = valuesLength + 2;\n\t\t\tvalues.push(column, item[column] as string);\n\t\t}\n\n\t\tconst updateQuery =\n\t\t\tupdates?.length > 0 ? ` DO UPDATE  SET ${updates.join(', ')}` : ' DO NOTHING ';\n\t\tlet query = `${insertQuery}${updateQuery}`;\n\n\t\tconst outputColumns = this.getNodeParameter('options.outputColumns', i, ['*']) as string[];\n\n\t\t[query, values] = addReturning(query, outputColumns, values);\n\n\t\tqueries.push({ query, values });\n\t}\n\n\treturn await runQueries(queries, items, nodeOptions);\n}\n"
          },
          {
            "file": "actions/node.type.ts",
            "content": "import type { AllEntities, Entity } from 'n8n-workflow';\n\ntype PostgresMap = {\n\tdatabase: 'deleteTable' | 'executeQuery' | 'insert' | 'select' | 'update' | 'upsert';\n};\n\nexport type PostgresType = AllEntities<PostgresMap>;\n\nexport type PostgresDatabaseType = Entity<PostgresMap, 'database'>;\n"
          },
          {
            "file": "actions/router.ts",
            "content": "import type { IExecuteFunctions, INodeExecutionData } from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport * as database from './database/Database.resource';\nimport type { PostgresType } from './node.type';\nimport { addExecutionHints } from '../../../../utils/utilities';\nimport { configurePostgres } from '../../transport';\nimport type { PostgresNodeCredentials, PostgresNodeOptions } from '../helpers/interfaces';\nimport { configureQueryRunner } from '../helpers/utils';\n\nexport async function router(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {\n\tlet returnData: INodeExecutionData[] = [];\n\n\tconst items = this.getInputData();\n\tconst resource = this.getNodeParameter<PostgresType>('resource', 0);\n\tconst operation = this.getNodeParameter('operation', 0);\n\n\tconst credentials = await this.getCredentials<PostgresNodeCredentials>('postgres');\n\tconst options = this.getNodeParameter('options', 0, {}) as PostgresNodeOptions;\n\tconst node = this.getNode();\n\toptions.nodeVersion = node.typeVersion;\n\toptions.operation = operation;\n\n\tconst { db, pgp } = await configurePostgres.call(this, credentials, options);\n\n\tconst runQueries = configureQueryRunner.call(\n\t\tthis,\n\t\tthis.getNode(),\n\t\tthis.continueOnFail(),\n\t\tpgp,\n\t\tdb,\n\t);\n\n\tconst postgresNodeData = {\n\t\tresource,\n\t\toperation,\n\t} as PostgresType;\n\n\tswitch (postgresNodeData.resource) {\n\t\tcase 'database':\n\t\t\treturnData = await database[postgresNodeData.operation].execute.call(\n\t\t\t\tthis,\n\t\t\t\trunQueries,\n\t\t\t\titems,\n\t\t\t\toptions,\n\t\t\t\tdb,\n\t\t\t\tpgp,\n\t\t\t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t`The operation \"${operation}\" is not supported!`,\n\t\t\t);\n\t}\n\n\taddExecutionHints(this, node, items, operation, node.executeOnce);\n\n\treturn [returnData];\n}\n"
          },
          {
            "file": "actions/versionDescription.ts",
            "content": "/* eslint-disable n8n-nodes-base/node-filename-against-convention */\nimport { NodeConnectionTypes, type INodeTypeDescription } from 'n8n-workflow';\n\nimport * as database from './database/Database.resource';\n\nexport const versionDescription: INodeTypeDescription = {\n\tdisplayName: 'Postgres',\n\tname: 'postgres',\n\ticon: 'file:postgres.svg',\n\tgroup: ['input'],\n\tversion: [2, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6],\n\tsubtitle: '={{ $parameter[\"operation\"] }}',\n\tdescription: 'Get, add and update data in Postgres',\n\tdefaults: {\n\t\tname: 'Postgres',\n\t},\n\tinputs: [NodeConnectionTypes.Main],\n\toutputs: [NodeConnectionTypes.Main],\n\tusableAsTool: true,\n\tcredentials: [\n\t\t{\n\t\t\tname: 'postgres',\n\t\t\trequired: true,\n\t\t\ttestedBy: 'postgresConnectionTest',\n\t\t},\n\t],\n\tproperties: [\n\t\t{\n\t\t\tdisplayName: 'Resource',\n\t\t\tname: 'resource',\n\t\t\ttype: 'hidden',\n\t\t\tnoDataExpression: true,\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Database',\n\t\t\t\t\tvalue: 'database',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'database',\n\t\t},\n\t\t...database.description,\n\t],\n};\n"
          },
          {
            "file": "helpers/interfaces.ts",
            "content": "import type { IDataObject, INodeExecutionData, SSHCredentials } from 'n8n-workflow';\nimport type pgPromise from 'pg-promise';\nimport { type IFormattingOptions } from 'pg-promise';\nimport type pg from 'pg-promise/typescript/pg-subset';\n\nexport type QueryMode = 'single' | 'transaction' | 'independently';\n\nexport type QueryValue = string | number | IDataObject | string[];\nexport type QueryValues = QueryValue[];\nexport type QueryWithValues = { query: string; values?: QueryValues; options?: IFormattingOptions };\n\nexport type WhereClause = { column: string; condition: string; value: string | number };\nexport type SortRule = { column: string; direction: string };\nexport type ColumnInfo = {\n\tcolumn_name: string;\n\tdata_type: string;\n\tis_nullable: string;\n\tudt_name?: string;\n\tcolumn_default?: string | null;\n\tis_generated?: 'ALWAYS' | 'NEVER';\n\tidentity_generation?: 'ALWAYS' | 'NEVER';\n};\nexport type EnumInfo = {\n\ttypname: string;\n\tenumlabel: string;\n};\n\nexport type PgpClient = pgPromise.IMain<{}, pg.IClient>;\nexport type PgpDatabase = pgPromise.IDatabase<{}, pg.IClient>;\nexport type PgpConnectionParameters = pg.IConnectionParameters<pg.IClient>;\nexport type PgpConnection = pgPromise.IConnected<{}, pg.IClient>;\nexport type ConnectionsData = { db: PgpDatabase; pgp: PgpClient };\n\nexport type QueriesRunner = (\n\tqueries: QueryWithValues[],\n\titems: INodeExecutionData[],\n\toptions: IDataObject,\n) => Promise<INodeExecutionData[]>;\n\nexport type PostgresNodeOptions = {\n\tnodeVersion?: number;\n\toperation?: string;\n\tcascade?: boolean;\n\tconnectionTimeout?: number;\n\tdelayClosingIdleConnection?: number;\n\tqueryBatching?: QueryMode;\n\tqueryReplacement?: string;\n\toutputColumns?: string[];\n\tlargeNumbersOutput?: 'numbers' | 'text';\n\tskipOnConflict?: boolean;\n\treplaceEmptyStrings?: boolean;\n\ttreatQueryParametersInSingleQuotesAsText?: boolean;\n};\n\nexport type PostgresNodeCredentials = {\n\thost: string;\n\tport: number;\n\tdatabase: string;\n\tuser: string;\n\tpassword: string;\n\tmaxConnections: number;\n\tallowUnauthorizedCerts?: boolean;\n\tssl?: 'disable' | 'allow' | 'require' | 'verify' | 'verify-full';\n} & (\n\t| { sshTunnel: false }\n\t| ({\n\t\t\tsshTunnel: true;\n\t  } & SSHCredentials)\n);\n"
          },
          {
            "file": "helpers/utils.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINode,\n\tINodeExecutionData,\n\tINodePropertyOptions,\n\tNodeParameterValueType,\n} from 'n8n-workflow';\nimport { NodeOperationError, jsonParse } from 'n8n-workflow';\n\nimport type {\n\tColumnInfo,\n\tEnumInfo,\n\tPgpClient,\n\tPgpDatabase,\n\tQueryMode,\n\tQueryValues,\n\tQueryWithValues,\n\tSortRule,\n\tWhereClause,\n} from './interfaces';\nimport { generatePairedItemData } from '../../../../utils/utilities';\n\nexport function isJSON(str: string) {\n\ttry {\n\t\tJSON.parse(str.trim());\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport function evaluateExpression(expression: NodeParameterValueType) {\n\tif (expression === undefined) {\n\t\treturn '';\n\t} else if (expression === null) {\n\t\treturn 'null';\n\t} else {\n\t\treturn typeof expression === 'object' ? JSON.stringify(expression) : expression.toString();\n\t}\n}\n\nexport function stringToArray(str: NodeParameterValueType | undefined) {\n\tif (str === undefined) return [];\n\treturn String(str)\n\t\t.split(',')\n\t\t.filter((entry) => entry)\n\t\t.map((entry) => entry.trim());\n}\n\nexport function wrapData(data: IDataObject | IDataObject[]): INodeExecutionData[] {\n\tif (!Array.isArray(data)) {\n\t\treturn [{ json: data }];\n\t}\n\treturn data.map((item) => ({\n\t\tjson: item,\n\t}));\n}\n\nexport function prepareErrorItem(\n\titems: INodeExecutionData[],\n\terror: IDataObject | NodeOperationError | Error,\n\tindex: number,\n) {\n\treturn {\n\t\tjson: { message: error.message, item: { ...items[index].json }, error: { ...error } },\n\t\tpairedItem: { item: index },\n\t} as INodeExecutionData;\n}\n\nexport function parsePostgresError(\n\tnode: INode,\n\terror: any,\n\tqueries: QueryWithValues[],\n\titemIndex?: number,\n) {\n\tif (error.message.includes('syntax error at or near') && queries.length) {\n\t\ttry {\n\t\t\tconst snippet = error.message.match(/syntax error at or near \"(.*)\"/)[1] as string;\n\t\t\tconst failedQureryIndex = queries.findIndex((query) => query.query.includes(snippet));\n\n\t\t\tif (failedQureryIndex !== -1) {\n\t\t\t\tif (!itemIndex) {\n\t\t\t\t\titemIndex = failedQureryIndex;\n\t\t\t\t}\n\t\t\t\tconst failedQuery = queries[failedQureryIndex].query;\n\t\t\t\tconst lines = failedQuery.split('\\n');\n\t\t\t\tconst lineIndex = lines.findIndex((line) => line.includes(snippet));\n\t\t\t\tconst errorMessage = `Syntax error at line ${lineIndex + 1} near \"${snippet}\"`;\n\t\t\t\terror.message = errorMessage;\n\t\t\t}\n\t\t} catch {}\n\t}\n\n\tlet message = error.message;\n\tconst errorDescription = error.description ? error.description : error.detail || error.hint;\n\tlet description = errorDescription;\n\n\tif (!description && queries[itemIndex || 0]?.query) {\n\t\tdescription = `Failed query: ${queries[itemIndex || 0].query}`;\n\t}\n\n\tif (error.message.includes('ECONNREFUSED')) {\n\t\tmessage = 'Connection refused';\n\t\ttry {\n\t\t\tdescription = error.message.split('ECONNREFUSED ')[1].trim();\n\t\t} catch (e) {}\n\t}\n\n\tif (error.message.includes('ENOTFOUND')) {\n\t\tmessage = 'Host not found';\n\t\ttry {\n\t\t\tdescription = error.message.split('ENOTFOUND ')[1].trim();\n\t\t} catch (e) {}\n\t}\n\n\tif (error.message.includes('ETIMEDOUT')) {\n\t\tmessage = 'Connection timed out';\n\t\ttry {\n\t\t\tdescription = error.message.split('ETIMEDOUT ')[1].trim();\n\t\t} catch (e) {}\n\t}\n\n\treturn new NodeOperationError(node, error as Error, {\n\t\tmessage,\n\t\tdescription,\n\t\titemIndex,\n\t});\n}\n\nexport function addWhereClauses(\n\tnode: INode,\n\titemIndex: number,\n\tquery: string,\n\tclauses: WhereClause[],\n\treplacements: QueryValues,\n\tcombineConditions: string,\n): [string, QueryValues] {\n\tif (clauses.length === 0) return [query, replacements];\n\n\tlet combineWith = 'AND';\n\n\tif (combineConditions === 'OR') {\n\t\tcombineWith = 'OR';\n\t}\n\n\tlet replacementIndex = replacements.length + 1;\n\n\tlet whereQuery = ' WHERE';\n\tconst values: QueryValues = [];\n\n\tclauses.forEach((clause, index) => {\n\t\tif (clause.condition === 'equal') {\n\t\t\tclause.condition = '=';\n\t\t}\n\t\tif (['>', '<', '>=', '<='].includes(clause.condition)) {\n\t\t\tconst value = Number(clause.value);\n\n\t\t\tif (Number.isNaN(value)) {\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tnode,\n\t\t\t\t\t`Operator in entry ${index + 1} of 'Select Rows' works with numbers, but value ${\n\t\t\t\t\t\tclause.value\n\t\t\t\t\t} is not a number`,\n\t\t\t\t\t{\n\t\t\t\t\t\titemIndex,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tclause.value = value;\n\t\t}\n\t\tconst columnReplacement = `$${replacementIndex}:name`;\n\t\tvalues.push(clause.column);\n\t\treplacementIndex = replacementIndex + 1;\n\n\t\tlet valueReplacement = '';\n\t\tif (clause.condition !== 'IS NULL' && clause.condition !== 'IS NOT NULL') {\n\t\t\tvalueReplacement = ` $${replacementIndex}`;\n\t\t\tvalues.push(clause.value);\n\t\t\treplacementIndex = replacementIndex + 1;\n\t\t}\n\n\t\tconst operator = index === clauses.length - 1 ? '' : ` ${combineWith}`;\n\n\t\twhereQuery += ` ${columnReplacement} ${clause.condition}${valueReplacement}${operator}`;\n\t});\n\n\treturn [`${query}${whereQuery}`, replacements.concat(...values)];\n}\n\nexport function addSortRules(\n\tquery: string,\n\trules: SortRule[],\n\treplacements: QueryValues,\n): [string, QueryValues] {\n\tif (rules.length === 0) return [query, replacements];\n\n\tlet replacementIndex = replacements.length + 1;\n\n\tlet orderByQuery = ' ORDER BY';\n\tconst values: string[] = [];\n\n\trules.forEach((rule, index) => {\n\t\tconst columnReplacement = `$${replacementIndex}:name`;\n\t\tvalues.push(rule.column);\n\t\treplacementIndex = replacementIndex + 1;\n\n\t\tconst endWith = index === rules.length - 1 ? '' : ',';\n\n\t\tconst sortDirection = rule.direction === 'DESC' ? 'DESC' : 'ASC';\n\n\t\torderByQuery += ` ${columnReplacement} ${sortDirection}${endWith}`;\n\t});\n\n\treturn [`${query}${orderByQuery}`, replacements.concat(...values)];\n}\n\nexport function addReturning(\n\tquery: string,\n\toutputColumns: string[],\n\treplacements: QueryValues,\n): [string, QueryValues] {\n\tif (outputColumns.includes('*')) return [`${query} RETURNING *`, replacements];\n\n\tconst replacementIndex = replacements.length + 1;\n\n\treturn [`${query} RETURNING $${replacementIndex}:name`, [...replacements, outputColumns]];\n}\n\nconst isSelectQuery = (query: string) => {\n\treturn query\n\t\t.replace(/\\/\\*.*?\\*\\//g, '') // remove multiline comments\n\t\t.replace(/\\n/g, '')\n\t\t.split(';')\n\t\t.filter((statement) => statement && !statement.startsWith('--')) // remove comments and empty statements\n\t\t.every((statement) => statement.trim().toLowerCase().startsWith('select'));\n};\n\nexport function configureQueryRunner(\n\tthis: IExecuteFunctions,\n\tnode: INode,\n\tcontinueOnFail: boolean,\n\tpgp: PgpClient,\n\tdb: PgpDatabase,\n) {\n\treturn async (queries: QueryWithValues[], items: INodeExecutionData[], options: IDataObject) => {\n\t\tlet returnData: INodeExecutionData[] = [];\n\t\tconst emptyReturnData: INodeExecutionData[] =\n\t\t\toptions.operation === 'select' ? [] : [{ json: { success: true } }];\n\n\t\tconst queryBatching = (options.queryBatching as QueryMode) || 'single';\n\n\t\tif (queryBatching === 'single') {\n\t\t\ttry {\n\t\t\t\treturnData = (await db.multi(pgp.helpers.concat(queries)))\n\t\t\t\t\t.map((result, i) => {\n\t\t\t\t\t\treturn this.helpers.constructExecutionMetaData(wrapData(result as IDataObject[]), {\n\t\t\t\t\t\t\titemData: { item: i },\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t\t.flat();\n\n\t\t\t\tif (!returnData.length) {\n\t\t\t\t\tconst pairedItem = generatePairedItemData(queries.length);\n\n\t\t\t\t\tif ((options?.nodeVersion as number) < 2.3) {\n\t\t\t\t\t\tif (emptyReturnData.length) {\n\t\t\t\t\t\t\temptyReturnData[0].pairedItem = pairedItem;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturnData = emptyReturnData;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturnData = queries.every((query) => isSelectQuery(query.query))\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: [{ json: { success: true }, pairedItem }];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tconst error = parsePostgresError(node, err, queries);\n\t\t\t\tif (!continueOnFail) throw error;\n\n\t\t\t\treturn [\n\t\t\t\t\t{\n\t\t\t\t\t\tjson: {\n\t\t\t\t\t\t\tmessage: error.message,\n\t\t\t\t\t\t\terror: { ...error },\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tif (queryBatching === 'transaction') {\n\t\t\treturnData = await db.tx(async (transaction) => {\n\t\t\t\tconst result: INodeExecutionData[] = [];\n\t\t\t\tfor (let i = 0; i < queries.length; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst query = queries[i].query;\n\t\t\t\t\t\tconst values = queries[i].values;\n\n\t\t\t\t\t\tlet transactionResults;\n\t\t\t\t\t\tif ((options?.nodeVersion as number) < 2.3) {\n\t\t\t\t\t\t\ttransactionResults = await transaction.any(query, values);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttransactionResults = (await transaction.multi(query, values)).flat();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!transactionResults.length) {\n\t\t\t\t\t\t\tif ((options?.nodeVersion as number) < 2.3) {\n\t\t\t\t\t\t\t\ttransactionResults = emptyReturnData;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransactionResults = isSelectQuery(query) ? [] : [{ success: true }];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\t\t\t\twrapData(transactionResults),\n\t\t\t\t\t\t\t{ itemData: { item: i } },\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tresult.push(...executionData);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconst error = parsePostgresError(node, err, queries, i);\n\t\t\t\t\t\tif (!continueOnFail) throw error;\n\t\t\t\t\t\tresult.push(prepareErrorItem(items, error, i));\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t});\n\t\t}\n\n\t\tif (queryBatching === 'independently') {\n\t\t\treturnData = await db.task(async (task) => {\n\t\t\t\tconst result: INodeExecutionData[] = [];\n\t\t\t\tfor (let i = 0; i < queries.length; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst query = queries[i].query;\n\t\t\t\t\t\tconst values = queries[i].values;\n\n\t\t\t\t\t\tlet transactionResults;\n\t\t\t\t\t\tif ((options?.nodeVersion as number) < 2.3) {\n\t\t\t\t\t\t\ttransactionResults = await task.any(query, values);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttransactionResults = (await task.multi(query, values)).flat();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!transactionResults.length) {\n\t\t\t\t\t\t\tif ((options?.nodeVersion as number) < 2.3) {\n\t\t\t\t\t\t\t\ttransactionResults = emptyReturnData;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransactionResults = isSelectQuery(query) ? [] : [{ success: true }];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\t\t\t\twrapData(transactionResults),\n\t\t\t\t\t\t\t{ itemData: { item: i } },\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tresult.push(...executionData);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconst error = parsePostgresError(node, err, queries, i);\n\t\t\t\t\t\tif (!continueOnFail) throw error;\n\t\t\t\t\t\tresult.push(prepareErrorItem(items, error, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t});\n\t\t}\n\n\t\treturn returnData;\n\t};\n}\n\nexport function replaceEmptyStringsByNulls(\n\titems: INodeExecutionData[],\n\treplace?: boolean,\n): INodeExecutionData[] {\n\tif (!replace) return items;\n\n\tconst returnData: INodeExecutionData[] = items.map((item) => {\n\t\tconst newItem = { ...item };\n\t\tconst keys = Object.keys(newItem.json);\n\n\t\tfor (const key of keys) {\n\t\t\tif (newItem.json[key] === '') {\n\t\t\t\tnewItem.json[key] = null;\n\t\t\t}\n\t\t}\n\n\t\treturn newItem;\n\t});\n\n\treturn returnData;\n}\n\nexport function prepareItem(values: IDataObject[]) {\n\tconst item = values.reduce((acc, { column, value }) => {\n\t\tacc[column as string] = value;\n\t\treturn acc;\n\t}, {} as IDataObject);\n\n\treturn item;\n}\n\nexport function hasJsonDataTypeInSchema(schema: ColumnInfo[]) {\n\treturn schema.some(({ data_type }) => data_type === 'json');\n}\n\nexport function convertValuesToJsonWithPgp(\n\tpgp: PgpClient,\n\tschema: ColumnInfo[],\n\tvalues: IDataObject,\n) {\n\tschema\n\t\t.filter(\n\t\t\t({ data_type, column_name }) =>\n\t\t\t\tdata_type === 'json' && values[column_name] !== null && values[column_name] !== undefined,\n\t\t)\n\t\t.forEach(({ column_name }) => {\n\t\t\tvalues[column_name] = pgp.as.json(values[column_name], true);\n\t\t});\n\n\treturn values;\n}\n\nexport async function columnFeatureSupport(\n\tdb: PgpDatabase,\n): Promise<{ identity_generation: boolean; is_generated: boolean }> {\n\tconst result = await db.any(\n\t\t`SELECT EXISTS (\n\t\t\tSELECT 1 FROM information_schema.columns WHERE table_name = 'columns' AND table_schema = 'information_schema' AND column_name = 'is_generated'\n\t\t) as is_generated,\n\t\tEXISTS (\n\t\t\tSELECT 1 FROM information_schema.columns WHERE table_name = 'columns' AND table_schema = 'information_schema' AND column_name = 'identity_generation'\n\t\t) as identity_generation;`,\n\t);\n\n\treturn result[0];\n}\n\nexport async function getTableSchema(\n\tdb: PgpDatabase,\n\tschema: string,\n\ttable: string,\n\toptions?: { getColumnsForResourceMapper?: boolean },\n): Promise<ColumnInfo[]> {\n\tconst select = ['column_name', 'data_type', 'is_nullable', 'udt_name', 'column_default'];\n\n\tif (options?.getColumnsForResourceMapper) {\n\t\t// Check if columns exist before querying (identity_generation was added in v10, is_generated in v12)\n\t\tconst supported = await columnFeatureSupport(db);\n\n\t\tif (supported.identity_generation) {\n\t\t\tselect.push('identity_generation');\n\t\t}\n\n\t\tif (supported.is_generated) {\n\t\t\tselect.push('is_generated');\n\t\t}\n\t}\n\n\tconst selectString = select.join(', ');\n\tconst columns = await db.any(\n\t\t`SELECT ${selectString} FROM information_schema.columns WHERE table_schema = $1 AND table_name = $2`,\n\t\t[schema, table],\n\t);\n\n\treturn columns;\n}\n\nexport async function uniqueColumns(db: PgpDatabase, table: string, schema = 'public') {\n\t// Using the modified query from https://wiki.postgresql.org/wiki/Retrieve_primary_key_columns\n\t// `quote_ident` - properly quote and escape an identifier\n\t// `::regclass` - cast a string to a regclass (internal type for object names)\n\tconst unique = await db.any(\n\t\t`\n\t\tSELECT DISTINCT a.attname\n\t\t\tFROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)\n\t\tWHERE i.indrelid = (quote_ident($1) || '.' || quote_ident($2))::regclass\n\t\t\tAND (i.indisprimary OR i.indisunique);\n\t\t`,\n\t\t[schema, table],\n\t);\n\treturn unique as IDataObject[];\n}\n\nexport async function getEnums(db: PgpDatabase): Promise<EnumInfo[]> {\n\tconst enumsData = await db.any(\n\t\t'SELECT pg_type.typname, pg_enum.enumlabel FROM pg_type JOIN pg_enum ON pg_enum.enumtypid = pg_type.oid;',\n\t);\n\treturn enumsData as EnumInfo[];\n}\n\nexport function getEnumValues(enumInfo: EnumInfo[], enumName: string): INodePropertyOptions[] {\n\treturn enumInfo.reduce((acc, current) => {\n\t\tif (current.typname === enumName) {\n\t\t\tacc.push({ name: current.enumlabel, value: current.enumlabel });\n\t\t}\n\t\treturn acc;\n\t}, [] as INodePropertyOptions[]);\n}\n\nexport async function doesRowExist(\n\tdb: PgpDatabase,\n\tschema: string,\n\ttable: string,\n\tvalues: string[],\n): Promise<boolean> {\n\tconst where = [];\n\tfor (let i = 3; i < 3 + values.length; i += 2) {\n\t\twhere.push(`$${i}:name=$${i + 1}`);\n\t}\n\tconst exists = await db.any(\n\t\t`SELECT EXISTS(SELECT 1 FROM $1:name.$2:name WHERE ${where.join(' AND ')})`,\n\t\t[schema, table, ...values],\n\t);\n\treturn exists[0].exists;\n}\n\nexport function checkItemAgainstSchema(\n\tnode: INode,\n\titem: IDataObject,\n\tcolumnsInfo: ColumnInfo[],\n\tindex: number,\n) {\n\tif (columnsInfo.length === 0) return item;\n\tconst schema = columnsInfo.reduce((acc, { column_name, data_type, is_nullable }) => {\n\t\tacc[column_name] = { type: data_type.toUpperCase(), nullable: is_nullable === 'YES' };\n\t\treturn acc;\n\t}, {} as IDataObject);\n\n\tfor (const key of Object.keys(item)) {\n\t\tif (schema[key] === undefined) {\n\t\t\tthrow new NodeOperationError(node, `Column '${key}' does not exist in selected table`, {\n\t\t\t\titemIndex: index,\n\t\t\t});\n\t\t}\n\t\tif (item[key] === null && !(schema[key] as IDataObject)?.nullable) {\n\t\t\tthrow new NodeOperationError(node, `Column '${key}' is not nullable`, {\n\t\t\t\titemIndex: index,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn item;\n}\n\nexport const configureTableSchemaUpdater = (initialSchema: string, initialTable: string) => {\n\tlet currentSchema = initialSchema;\n\tlet currentTable = initialTable;\n\treturn async (db: PgpDatabase, tableSchema: ColumnInfo[], schema: string, table: string) => {\n\t\tif (currentSchema !== schema || currentTable !== table) {\n\t\t\tcurrentSchema = schema;\n\t\t\tcurrentTable = table;\n\t\t\ttableSchema = await getTableSchema(db, schema, table);\n\t\t}\n\t\treturn tableSchema;\n\t};\n};\n\n/**\n * If postgress column type is array we need to convert it to fornmat that postgres understands, original object data would be modified\n * @param data the object with keys representing column names and values\n * @param schema table schema\n * @param node INode\n * @param itemIndex the index of the current item\n */\nexport const convertArraysToPostgresFormat = (\n\tdata: IDataObject,\n\tschema: ColumnInfo[],\n\tnode: INode,\n\titemIndex = 0,\n) => {\n\tfor (const columnInfo of schema) {\n\t\t//in case column type is array we need to convert it to fornmat that postgres understands\n\t\tif (columnInfo.data_type.toUpperCase() === 'ARRAY') {\n\t\t\tlet columnValue = data[columnInfo.column_name];\n\n\t\t\tif (typeof columnValue === 'string') {\n\t\t\t\tcolumnValue = jsonParse(columnValue);\n\t\t\t}\n\n\t\t\tif (Array.isArray(columnValue)) {\n\t\t\t\tconst arrayEntries = columnValue.map((entry) => {\n\t\t\t\t\tif (typeof entry === 'number') {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof entry === 'boolean') {\n\t\t\t\t\t\tentry = String(entry);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof entry === 'object') {\n\t\t\t\t\t\tentry = JSON.stringify(entry);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof entry === 'string') {\n\t\t\t\t\t\treturn `\"${entry.replace(/\"/g, '\\\\\"')}\"`; //escape double quotes\n\t\t\t\t\t}\n\n\t\t\t\t\treturn entry;\n\t\t\t\t});\n\n\t\t\t\t//wrap in {} instead of [] as postgres does and join with ,\n\t\t\t\tdata[columnInfo.column_name] = `{${arrayEntries.join(',')}}`;\n\t\t\t} else {\n\t\t\t\tif (columnInfo.is_nullable === 'NO') {\n\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\t`Column '${columnInfo.column_name}' has to be an array`,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n"
          },
          {
            "file": "methods/credentialTest.ts",
            "content": "import type {\n\tICredentialsDecrypted,\n\tICredentialTestFunctions,\n\tINodeCredentialTestResult,\n} from 'n8n-workflow';\n\nimport { configurePostgres } from '../../transport';\nimport type { PgpConnection, PostgresNodeCredentials } from '../helpers/interfaces';\n\nexport async function postgresConnectionTest(\n\tthis: ICredentialTestFunctions,\n\tcredential: ICredentialsDecrypted,\n): Promise<INodeCredentialTestResult> {\n\tconst credentials = credential.data as PostgresNodeCredentials;\n\n\tlet connection: PgpConnection | undefined;\n\n\ttry {\n\t\tconst { db } = await configurePostgres.call(this, credentials, {});\n\n\t\tconnection = await db.connect();\n\t} catch (error) {\n\t\tlet message = error.message as string;\n\n\t\tif (error.message.includes('ECONNREFUSED')) {\n\t\t\tmessage = 'Connection refused';\n\t\t}\n\n\t\tif (error.message.includes('ENOTFOUND')) {\n\t\t\tmessage = 'Host not found, please check your host name';\n\t\t}\n\n\t\tif (error.message.includes('ETIMEDOUT')) {\n\t\t\tmessage = 'Connection timed out';\n\t\t}\n\n\t\treturn {\n\t\t\tstatus: 'Error',\n\t\t\tmessage,\n\t\t};\n\t} finally {\n\t\tif (connection) {\n\t\t\tawait connection.done();\n\t\t}\n\t}\n\treturn {\n\t\tstatus: 'OK',\n\t\tmessage: 'Connection successful!',\n\t};\n}\n"
          },
          {
            "file": "methods/index.ts",
            "content": "export * as credentialTest from './credentialTest';\nexport * as listSearch from './listSearch';\nexport * as loadOptions from './loadOptions';\nexport * as resourceMapping from './resourceMapping';\n"
          },
          {
            "file": "methods/listSearch.ts",
            "content": "import type { ILoadOptionsFunctions, INodeListSearchResult } from 'n8n-workflow';\n\nimport { configurePostgres } from '../../transport';\nimport type { PostgresNodeCredentials } from '../helpers/interfaces';\n\nexport async function schemaSearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst credentials = await this.getCredentials<PostgresNodeCredentials>('postgres');\n\tconst options = { nodeVersion: this.getNode().typeVersion };\n\n\tconst { db } = await configurePostgres.call(this, credentials, options);\n\n\tconst response = await db.any('SELECT schema_name FROM information_schema.schemata');\n\n\treturn {\n\t\tresults: response.map((schema) => ({\n\t\t\tname: schema.schema_name as string,\n\t\t\tvalue: schema.schema_name as string,\n\t\t})),\n\t};\n}\nexport async function tableSearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst credentials = await this.getCredentials<PostgresNodeCredentials>('postgres');\n\tconst options = { nodeVersion: this.getNode().typeVersion };\n\n\tconst { db } = await configurePostgres.call(this, credentials, options);\n\n\tconst schema = this.getNodeParameter('schema', 0, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst response = await db.any(\n\t\t'SELECT table_name FROM information_schema.tables WHERE table_schema=$1',\n\t\t[schema],\n\t);\n\n\treturn {\n\t\tresults: response.map((table) => ({\n\t\t\tname: table.table_name as string,\n\t\t\tvalue: table.table_name as string,\n\t\t})),\n\t};\n}\n"
          },
          {
            "file": "methods/loadOptions.ts",
            "content": "import type { ILoadOptionsFunctions, INodePropertyOptions } from 'n8n-workflow';\n\nimport { configurePostgres } from '../../transport';\nimport type { PostgresNodeCredentials } from '../helpers/interfaces';\nimport { getTableSchema } from '../helpers/utils';\n\nexport async function getColumns(this: ILoadOptionsFunctions): Promise<INodePropertyOptions[]> {\n\tconst credentials = await this.getCredentials<PostgresNodeCredentials>('postgres');\n\tconst options = { nodeVersion: this.getNode().typeVersion };\n\n\tconst { db } = await configurePostgres.call(this, credentials, options);\n\n\tconst schema = this.getNodeParameter('schema', 0, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst table = this.getNodeParameter('table', 0, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst columns = await getTableSchema(db, schema, table);\n\n\treturn columns.map((column) => ({\n\t\tname: column.column_name,\n\t\tvalue: column.column_name,\n\t\tdescription: `Type: ${column.data_type.toUpperCase()}, Nullable: ${column.is_nullable}`,\n\t}));\n}\n\nexport async function getColumnsMultiOptions(\n\tthis: ILoadOptionsFunctions,\n): Promise<INodePropertyOptions[]> {\n\tconst returnData = await getColumns.call(this);\n\tconst returnAll = { name: '*', value: '*', description: 'All columns' };\n\treturn [returnAll, ...returnData];\n}\n\nexport async function getColumnsWithoutColumnToMatchOn(\n\tthis: ILoadOptionsFunctions,\n): Promise<INodePropertyOptions[]> {\n\tconst columnToMatchOn = this.getNodeParameter('columnToMatchOn') as string;\n\tconst returnData = await getColumns.call(this);\n\treturn returnData.filter((column) => column.value !== columnToMatchOn);\n}\n"
          },
          {
            "file": "methods/resourceMapping.ts",
            "content": "import type { ILoadOptionsFunctions, ResourceMapperFields, FieldType } from 'n8n-workflow';\n\nimport { configurePostgres } from '../../transport';\nimport type { PostgresNodeCredentials } from '../helpers/interfaces';\nimport { getEnumValues, getEnums, getTableSchema, uniqueColumns } from '../helpers/utils';\n\nconst fieldTypeMapping: Partial<Record<FieldType, string[]>> = {\n\tstring: ['text', 'varchar', 'character varying', 'character', 'char'],\n\tnumber: [\n\t\t'integer',\n\t\t'smallint',\n\t\t'bigint',\n\t\t'decimal',\n\t\t'numeric',\n\t\t'real',\n\t\t'double precision',\n\t\t'smallserial',\n\t\t'serial',\n\t\t'bigserial',\n\t],\n\tboolean: ['boolean'],\n\tdateTime: [\n\t\t'timestamp',\n\t\t'date',\n\t\t'timestampz',\n\t\t'timestamp without time zone',\n\t\t'timestamp with time zone',\n\t],\n\ttime: ['time', 'time without time zone', 'time with time zone'],\n\tobject: ['json', 'jsonb'],\n\toptions: ['enum', 'USER-DEFINED'],\n\tarray: ['ARRAY'],\n};\n\nfunction mapPostgresType(postgresType: string): FieldType {\n\tlet mappedType: FieldType = 'string';\n\n\tfor (const t of Object.keys(fieldTypeMapping)) {\n\t\tconst postgresTypes = fieldTypeMapping[t as FieldType];\n\t\tif (postgresTypes?.includes(postgresType)) {\n\t\t\tmappedType = t as FieldType;\n\t\t}\n\t}\n\treturn mappedType;\n}\n\nexport async function getMappingColumns(\n\tthis: ILoadOptionsFunctions,\n): Promise<ResourceMapperFields> {\n\tconst credentials = await this.getCredentials<PostgresNodeCredentials>('postgres');\n\n\tconst { db } = await configurePostgres.call(this, credentials);\n\n\tconst schema = this.getNodeParameter('schema', 0, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst table = this.getNodeParameter('table', 0, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst operation = this.getNodeParameter('operation', 0, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst columns = await getTableSchema(db, schema, table, { getColumnsForResourceMapper: true });\n\tconst unique = operation === 'upsert' ? await uniqueColumns(db, table, schema) : [];\n\tconst enumInfo = await getEnums(db);\n\tconst fields = await Promise.all(\n\t\tcolumns.map(async (col) => {\n\t\t\tconst canBeUsedToMatch =\n\t\t\t\toperation === 'upsert' ? unique.some((u) => u.attname === col.column_name) : true;\n\t\t\tconst type = mapPostgresType(col.data_type);\n\t\t\tconst options =\n\t\t\t\ttype === 'options' ? getEnumValues(enumInfo, col.udt_name as string) : undefined;\n\t\t\tconst hasDefault = Boolean(col.column_default);\n\t\t\tconst isGenerated =\n\t\t\t\tcol.is_generated === 'ALWAYS' ||\n\t\t\t\t['ALWAYS', 'BY DEFAULT'].includes(col.identity_generation ?? '');\n\t\t\tconst nullable = col.is_nullable === 'YES';\n\t\t\treturn {\n\t\t\t\tid: col.column_name,\n\t\t\t\tdisplayName: col.column_name,\n\t\t\t\trequired: !nullable && !hasDefault && !isGenerated,\n\t\t\t\tdefaultMatch: (col.column_name === 'id' && canBeUsedToMatch) || false,\n\t\t\t\tdisplay: true,\n\t\t\t\ttype,\n\t\t\t\tcanBeUsedToMatch,\n\t\t\t\toptions,\n\t\t\t};\n\t\t}),\n\t);\n\treturn { fields };\n}\n"
          }
        ]
      },
      "metadata": {
        "fetch_time": "2026-01-07T08:26:09.401936+00:00",
        "source_type": "TYPE1",
        "source_path": "input_sources/postgres",
        "file_count": 19,
        "content_hash": "578404df52143536"
      },
      "artifacts": {
        "raw_source": "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/raw_source.txt",
        "parsed_source": "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/parsed_source.json",
        "source_bundle": "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/source_bundle"
      }
    },
    "infer-schema": {
      "inferred_schema": {
        "type": "postgres",
        "version": 1,
        "description": {
          "displayName": "Postgres",
          "name": "postgres",
          "inputs": [
            {
              "name": "main",
              "type": "main"
            }
          ],
          "outputs": [
            {
              "name": "main",
              "type": "main"
            }
          ]
        },
        "properties": {
          "parameters": [
            {
              "name": "resource",
              "display_name": "Resource",
              "type": "OPTIONS",
              "options": [
                {
                  "name": "Database",
                  "value": "database"
                }
              ],
              "default": "database",
              "description": "The resource to operate on"
            }
          ],
          "credentials": [
            {
              "name": "postgres",
              "required": true
            }
          ]
        },
        "operations": [
          {
            "name": "execute",
            "description": "Default operation"
          }
        ],
        "resources": [
          {
            "name": "Database",
            "value": "database"
          }
        ],
        "credentials": [
          {
            "name": "postgres",
            "required": true
          }
        ]
      },
      "trace_map": {
        "correlation_id": "node-postgres-fix32-test",
        "node_type": "postgres",
        "trace_entries": [
          {
            "field_path": "resources[0]",
            "source": "SOURCE_CODE",
            "evidence": "Resource 'database' defined in actions/versionDescription.ts",
            "confidence": "high",
            "source_file": "actions/versionDescription.ts"
          },
          {
            "field_path": "credentials[0]",
            "source": "SOURCE_CODE",
            "evidence": "Credential 'postgres' (required=True) in actions/versionDescription.ts",
            "confidence": "high",
            "source_file": "actions/versionDescription.ts"
          },
          {
            "field_path": "operations[0]",
            "source": "ASSUMPTION",
            "evidence": "No operations found in source; defaulting to single 'execute' operation",
            "confidence": "low",
            "assumption_rationale": "Source may be incomplete or use different patterns"
          }
        ],
        "generated_at": "2026-01-07T08:26:09.660192",
        "skill_version": "1.0.0",
        "_hybrid_metadata": {
          "source_type": "TYPE1",
          "extraction_confidence": 0.7,
          "advisor_used": false,
          "assumption_ratio": 0.3333333333333333,
          "deterministic_operations": 2,
          "assumption_operations": 1
        }
      },
      "schema": {
        "type": "postgres",
        "version": 1,
        "description": {
          "displayName": "Postgres",
          "name": "postgres",
          "inputs": [
            {
              "name": "main",
              "type": "main"
            }
          ],
          "outputs": [
            {
              "name": "main",
              "type": "main"
            }
          ]
        },
        "properties": {
          "parameters": [
            {
              "name": "resource",
              "display_name": "Resource",
              "type": "OPTIONS",
              "options": [
                {
                  "name": "Database",
                  "value": "database"
                }
              ],
              "default": "database",
              "description": "The resource to operate on"
            }
          ],
          "credentials": [
            {
              "name": "postgres",
              "required": true
            }
          ]
        },
        "operations": [
          {
            "name": "execute",
            "description": "Default operation"
          }
        ],
        "resources": [
          {
            "name": "Database",
            "value": "database"
          }
        ],
        "credentials": [
          {
            "name": "postgres",
            "required": true
          }
        ]
      },
      "assumptions": [
        "Default 'execute' operation assumed - verify against actual API",
        "WARNING: High assumption ratio (33.3%) exceeds 30% threshold"
      ],
      "artifacts_written": [
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/schema/inferred_schema.json",
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/schema/trace_map.json"
      ],
      "extraction_confidence": 0.7,
      "advisor_used": false
    },
    "scaffold": {
      "files_created": [
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/generated_node/postgres.py",
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/generated_node/__init__.py"
      ],
      "allowlist": {
        "node_name": "postgres",
        "patterns": [
          "nodes/postgres*",
          "nodes/postgres*",
          "tests/*postgres*",
          "tests/*postgres*",
          "credentials/*postgres*",
          "credentials/*postgres*"
        ]
      }
    },
    "ground": {
      "repo_facts_path": "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/repo_facts.json",
      "repo_facts": {
        "basenode_contract_path": "contracts/BASENODE_CONTRACT.md",
        "node_loader_paths": [
          "runtime/kb/loader.py"
        ],
        "golden_node_paths": [
          "nodepacks/core/nodes.py",
          "src/node_sdk/basenode.py"
        ],
        "test_command": "pytest tests/"
      },
      "target_repo_layout_path": "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/target_repo_layout.json",
      "target_repo_layout": {
        "target_repo_root": "/home/toni/agent-skills",
        "node_output_base_dir": "nodes",
        "registry_file": "nodes/__init__.py",
        "registry_strategy": "dict_import",
        "registry_dict_name": "node_definitions",
        "base_class_file": "nodes/base.py",
        "base_class_name": "BaseNode",
        "tests_dir": "tests",
        "python_version": null,
        "venv_path": ".venv",
        "extra_allowlist_patterns": []
      }
    },
    "convert": {
      "files_modified": [
        "nodes/postgres.py"
      ],
      "all_target_files": [
        "nodes/postgres.py",
        "nodes/__init__.py"
      ],
      "artifact_paths": [
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/converted/postgres.py",
        "/home/toni/agent-skills/artifacts/node-postgres-fix32-test/converted/__init__.py"
      ],
      "conversion_notes": [
        "Selected PostgresV2.node.ts as main node (name match)",
        "Found main node class for Postgres",
        "Found 0 operation handlers",
        "Using 1 parameters from inferred schema",
        "No GenericFunctions.ts found, generating default helpers"
      ],
      "generated_code": {
        "postgres.py": "#!/usr/bin/env python3\n\"\"\"\nPostgres Node\n\nConverted from TypeScript by agent-skills/code-convert\nCorrelation ID: node-postgres-fix32-test\nGenerated: 2026-01-07T08:26:09.993986\n\nSYNC-CELERY SAFE: All methods are synchronous with timeouts.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List\n\nimport requests\n\nfrom .base import BaseNode, NodeParameterType, NodeExecutionData\n\nlogger = logging.getLogger(__name__)\n\n\nclass PostgresNode(BaseNode):\n    \"\"\"\n    Postgres node.\n    \n    \n    \"\"\"\n\n    type = \"postgres\"\n    version = 1\n    \n    description = {\n        \"displayName\": \"Postgres\",\n        \"name\": \"postgres\",\n        \"icon\": \"file:postgres.svg\",\n        \"group\": ['output'],\n        \"description\": \"\",\n        \"inputs\": [{\"name\": \"main\", \"type\": \"main\", \"required\": True}],\n        \"outputs\": [{\"name\": \"main\", \"type\": \"main\", \"required\": True}],\n    }\n    \n    properties = {\n        \"parameters\": [\n            {\"name\": \"resource\", \"type\": NodeParameterType.OPTIONS, \"display_name\": \"Resource\", \"options\": [\n                {\"name\": \"Database\", \"value\": \"database\"}\n            ], \"default\": \"database\", \"description\": \"The resource to operate on\"}\n        ],\n        \"credentials\": [\n            {\"name\": \"postgres\", \"required\": True}\n        ]\n    }\n    \n    icon = \"postgres.svg\"\n\n    def execute(self) -> List[List[NodeExecutionData]]:\n        \"\"\"\n        Execute the node operations.\n        \n        SYNC-CELERY SAFE: All HTTP calls use timeout parameter.\n        \n        Returns:\n            List[List[NodeExecutionData]]: Nested list where outer list is output branches,\n            inner list is items in that branch.\n        \"\"\"\n        # Get input data from previous node\n        input_data = self.get_input_data()\n        \n        # Handle empty input\n        if not input_data:\n            return [[]]\n        \n        return_items: List[NodeExecutionData] = []\n\n        for i, item in enumerate(input_data):\n            try:\n                resource = self.get_node_parameter(\"resource\", i)\n                operation = self.get_node_parameter(\"operation\", i)\n                item_data = item.json_data if hasattr(item, 'json_data') else item.get('json', {})\n                \n                pass\n                else:\n                    raise ValueError(f\"Unknown resource/operation: {resource}/{operation}\")\n                \n                # Handle array results\n                if isinstance(result, list):\n                    for r in result:\n                        return_items.append(NodeExecutionData(json_data=r))\n                else:\n                    return_items.append(NodeExecutionData(json_data=result))\n                \n            except Exception as e:\n                logger.error(f\"Error in {resource}/{operation}: {e}\")\n                if self.node_data.continue_on_fail:\n                    return_items.append(NodeExecutionData(json_data={\"error\": str(e)}))\n                else:\n                    raise\n        \n        return [return_items]\n\"\"\"\nPostgreSQL connection helpers\n\"\"\"\n\nimport logging\nfrom typing import Any, Dict, List, Union\n\nlogger = logging.getLogger(__name__)\n\ndef _get_connection(self) -> Any:\n    \"\"\"\n    Get PostgreSQL database connection\n    \n    Returns:\n        Database connection object\n        \n    Raises:\n        ValueError: If credentials are missing or invalid\n    \"\"\"\n    credentials = self.get_credentials(\"postgres\")\n    if not credentials:\n        raise ValueError(\"PostgreSQL credentials not found\")\n    \n    # Extract connection parameters\n    host = credentials.get(\"host\", \"localhost\")\n    port = credentials.get(\"port\", {\"postgres\": 5432, \"mysql\": 3306, \"mongodb\": 27017}.get(\"postgres\", 5432))\n    database = credentials.get(\"database\", \"\")\n    user = credentials.get(\"user\", \"\")\n    password = credentials.get(\"password\", \"\")\n    ssl = credentials.get(\"ssl\", False)\n    timeout = credentials.get(\"connectionTimeout\", 30)\n    \n    if not database or not user:\n        raise ValueError(\"Database name and user are required\")\n    \n    try:\n        import psycopg\n        from psycopg.rows import dict_row\n        \n        # Build connection string\n        conn_parts = [\n            f\"host={{host}}\",\n            f\"port={{port}}\",\n            f\"dbname={{database}}\",\n            f\"user={{user}}\",\n            f\"password={{password}}\",\n            f\"connect_timeout={{timeout}}\"\n        ]\n        \n        if ssl:\n            conn_parts.append(\"sslmode=require\")\n        else:\n            conn_parts.append(\"sslmode=prefer\")\n        \n        conn_string = \" \".join(conn_parts)\n        \n        # Create connection with dict_row factory for easy JSON conversion\n        conn = psycopg.connect(conn_string, row_factory=dict_row)\n        return conn\n    except Exception as e:\n        logger.error(f\"Failed to connect to database: {str(e)}\")\n        raise ValueError(f\"Failed to connect to database: {str(e)}\")\n\n\n",
        "__init__.py": "\"\"\"\nPostgres Node Package\nConverted from TypeScript by agent-skills/code-convert\n\"\"\"\n\nfrom .postgres import PostgresNode\n\n__all__ = [\"PostgresNode\"]\n"
      }
    },
    "generate-tests": {
      "stub": true,
      "message": "Skill test-generate has no implementation registered"
    },
    "validate": {}
  },
  "artifacts_dir": "/home/toni/agent-skills/artifacts/node-postgres-fix32-test",
  "errors": [
    "Step 'infer-schema' blocked by gate",
    "Step 'convert' blocked by gate"
  ]
}