{
  "pipeline_name": "convert_node_v1",
  "correlation_id": "node-discord-v2test3",
  "status": "blocked",
  "started_at": "2026-01-06T04:37:51.903811",
  "completed_at": "2026-01-06T04:37:53.329513",
  "duration_ms": 1425,
  "steps": [
    {
      "step_name": "normalize",
      "skill_name": "node-normalize",
      "status": "completed",
      "started_at": "2026-01-06T04:37:51.904054",
      "completed_at": "2026-01-06T04:37:51.909379",
      "duration_ms": 5,
      "outputs": {
        "correlation_id": "node-discord-4057cfab",
        "normalized_name": "discord",
        "snapshot": {
          "version": "1.0",
          "created_at": "2026-01-06T04:37:51.909084+00:00",
          "correlation_id": "node-discord-4057cfab",
          "request": {
            "raw_node_name": "Discord",
            "normalized_name": "discord",
            "source_refs": {}
          },
          "checksum": "2ebed21a8a45bf96"
        },
        "artifacts": {
          "request_snapshot": "artifacts/node-discord-4057cfab/request_snapshot.json"
        }
      },
      "artifacts_produced": [],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "classify",
      "skill_name": "source-classify",
      "status": "completed",
      "started_at": "2026-01-06T04:37:51.909421",
      "completed_at": "2026-01-06T04:37:51.915864",
      "duration_ms": 6,
      "outputs": {
        "source_type": "TYPE1",
        "confidence": 1.0,
        "evidence": [
          {
            "type": "ts_file",
            "path_or_url": "input_sources/discord/Discord.node.ts",
            "verified": true,
            "description": "Found node file: Discord.node.ts"
          },
          {
            "type": "ts_file",
            "path_or_url": "input_sources/discord/v2/DiscordV2.node.ts",
            "verified": true,
            "description": "Found node file: DiscordV2.node.ts"
          },
          {
            "type": "ts_file",
            "path_or_url": "input_sources/discord/v1/DiscordV1.node.ts",
            "verified": true,
            "description": "Found node file: DiscordV1.node.ts"
          },
          {
            "type": "v2_router",
            "path_or_url": "input_sources/discord",
            "verified": true,
            "description": "Found router.ts - indicates v2 node structure"
          },
          {
            "type": "v2_structure",
            "path_or_url": "input_sources/discord",
            "verified": true,
            "description": "Found v2 directory structure with actions"
          },
          {
            "type": "file_count",
            "path_or_url": "input_sources/discord",
            "verified": true,
            "description": "Found 50 TypeScript files in source directory"
          }
        ],
        "artifacts": {
          "classification": "artifacts/node-discord-v2test3/classification.json"
        }
      },
      "artifacts_produced": [
        "artifacts/node-discord-v2test3/classification.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "ground",
      "skill_name": "repo-ground",
      "status": "completed",
      "started_at": "2026-01-06T04:37:51.915880",
      "completed_at": "2026-01-06T04:37:52.639864",
      "duration_ms": 723,
      "outputs": {
        "repo_facts_path": "artifacts/node-discord-v2test3/repo_facts.json",
        "repo_facts": {
          "basenode_contract_path": "nodes/base.py",
          "node_loader_paths": [
            "venv/lib/python3.12/site-packages/yaml/loader.py"
          ],
          "golden_node_paths": [
            "nodes/http_request.py",
            "venv/lib/python3.12/site-packages/langchain_community/chat_loaders/slack.py",
            "venv/lib/python3.12/site-packages/tqdm/contrib/slack.py",
            "venv/lib/python3.12/site-packages/langchain/chat_loaders/slack.py",
            "nodes/slack.py"
          ],
          "test_command": "pytest"
        },
        "target_repo_layout_path": "artifacts/node-discord-v2test3/target_repo_layout.json",
        "target_repo_layout": {
          "target_repo_root": "/home/toni/n8n/back",
          "node_output_base_dir": "nodes",
          "registry_file": "nodes/__init__.py",
          "registry_strategy": "dict_import",
          "registry_dict_name": "node_definitions",
          "base_class_file": "nodes/base.py",
          "base_class_name": "BaseNode",
          "tests_dir": "tests",
          "python_version": "3.10",
          "venv_path": ".venv",
          "extra_allowlist_patterns": []
        }
      },
      "artifacts_produced": [
        "artifacts/node-discord-v2test3/repo_facts.json",
        "artifacts/node-discord-v2test3/target_repo_layout.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "ingest",
      "skill_name": "source-ingest",
      "status": "completed",
      "started_at": "2026-01-06T04:37:52.639889",
      "completed_at": "2026-01-06T04:37:52.655991",
      "duration_ms": 16,
      "outputs": {
        "raw_content": "// === File: Discord.node.ts ===\nimport type { INodeTypeBaseDescription, IVersionedNodeType } from 'n8n-workflow';\nimport { VersionedNodeType } from 'n8n-workflow';\n\nimport { DiscordV1 } from './v1/DiscordV1.node';\nimport { DiscordV2 } from './v2/DiscordV2.node';\n\nexport class Discord extends VersionedNodeType {\n\tconstructor() {\n\t\tconst baseDescription: INodeTypeBaseDescription = {\n\t\t\tdisplayName: 'Discord',\n\t\t\tname: 'discord',\n\t\t\ticon: 'file:discord.svg',\n\t\t\tgroup: ['output'],\n\t\t\tdefaultVersion: 2,\n\t\t\tdescription: 'Sends data to Discord',\n\t\t};\n\n\t\tconst nodeVersions: IVersionedNodeType['nodeVersions'] = {\n\t\t\t1: new DiscordV1(baseDescription),\n\t\t\t2: new DiscordV2(baseDescription),\n\t\t};\n\n\t\tsuper(nodeVersions, baseDescription);\n\t}\n}\n\n\n// === File: test/v2/node/channel/create.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => create', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.post('/guilds/1168516062791340136/channels', { name: 'third', type: '0' })\n\t\t.reply(200, {\n\t\t\tid: '1168528323006181417',\n\t\t\ttype: 0,\n\t\t\tlast_message_id: null,\n\t\t\tflags: 0,\n\t\t\tguild_id: '1168516062791340136',\n\t\t\tname: 'third',\n\t\t\tparent_id: null,\n\t\t\trate_limit_per_user: 0,\n\t\t\ttopic: null,\n\t\t\tposition: 3,\n\t\t\tpermission_overwrites: [],\n\t\t\tnsfw: false,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['create.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/channel/deleteChannel.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => deleteChannel', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.delete('/channels/1168528323006181417')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['deleteChannel.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/channel/get.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => get', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.persist()\n\t\t.get('/users/@me/guilds')\n\t\t.reply(200, [{ id: '1168516062791340136' }])\n\t\t.get('/channels/1168516240332034067')\n\t\t.reply(200, {\n\t\t\tid: '1168516240332034067',\n\t\t\ttype: 0,\n\t\t\tlast_message_id: null,\n\t\t\tflags: 0,\n\t\t\tguild_id: '1168516062791340136',\n\t\t\tname: 'first',\n\t\t\tparent_id: '1168516063340789831',\n\t\t\trate_limit_per_user: 0,\n\t\t\ttopic: null,\n\t\t\tposition: 1,\n\t\t\tpermission_overwrites: [],\n\t\t\tnsfw: false,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['get.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/channel/getAll.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/guilds/1168516062791340136/channels')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tid: '1168516063340789831',\n\t\t\t\ttype: 4,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'Text Channels',\n\t\t\t\tparent_id: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789832',\n\t\t\t\ttype: 4,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'Voice Channels',\n\t\t\t\tparent_id: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789833',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: '1168518371239792720',\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'general',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\ttopic: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t\ticon_emoji: {\n\t\t\t\t\tid: null,\n\t\t\t\t\tname: 'ðŸ‘‹',\n\t\t\t\t},\n\t\t\t\ttheme_color: null,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789834',\n\t\t\t\ttype: 2,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'General',\n\t\t\t\tparent_id: '1168516063340789832',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\tbitrate: 64000,\n\t\t\t\tuser_limit: 0,\n\t\t\t\trtc_region: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t\ticon_emoji: {\n\t\t\t\t\tid: null,\n\t\t\t\t\tname: 'ðŸŽ™ï¸',\n\t\t\t\t},\n\t\t\t\ttheme_color: null,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516240332034067',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'first-channel',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 30,\n\t\t\t\ttopic: 'This is channel topic',\n\t\t\t\tposition: 3,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516269079793766',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'second',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\ttopic: null,\n\t\t\t\tposition: 2,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/channel/update.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => update', () => {\n\tnock('https://discord.com/api/v10').patch('/channels/1168516240332034067').reply(200, {\n\t\tid: '1168516240332034067',\n\t\ttype: 0,\n\t\tlast_message_id: null,\n\t\tflags: 0,\n\t\tguild_id: '1168516062791340136',\n\t\tname: 'first-channel',\n\t\tparent_id: '1168516063340789831',\n\t\trate_limit_per_user: 30,\n\t\ttopic: 'This is channel topic',\n\t\tposition: 3,\n\t\tpermission_overwrites: [],\n\t\tnsfw: true,\n\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['update.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/member/getAll.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/guilds/1168516062791340136/members?limit=2')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tuser: {\n\t\t\t\t\tid: '470936827994570762',\n\t\t\t\t\tusername: 'michael',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '0',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: 'Michael',\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\troles: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: {\n\t\t\t\t\tid: '1070667629972430879',\n\t\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '1037',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbot: true,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: null,\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\troles: ['1168518368526077992'],\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/member/roleAdd.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => roleAdd', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.put('/guilds/1168516062791340136/members/470936827994570762/roles/1168772374540320890')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['roleAdd.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/member/roleRemove.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => roleRemove', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.persist()\n\t\t.delete(/\\/guilds\\/1168516062791340136\\/members\\/470936827994570762\\/roles\\/\\d+/)\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['roleRemove.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/message/deleteMessage.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => deleteMessage', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.delete('/channels/1168516240332034067/messages/1168776343194972210')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['deleteMessage.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/message/get.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => get', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/channels/1168516240332034067/messages/1168777380144369718')\n\t\t.reply(200, {\n\t\t\tid: '1168777380144369718',\n\t\t\tchannel_id: '1168516240332034067',\n\t\t\tauthor: {\n\t\t\t\tid: '1070667629972430879',\n\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\tavatar: null,\n\t\t\t\tdiscriminator: '1037',\n\t\t\t\tpublic_flags: 0,\n\t\t\t\tpremium_type: 0,\n\t\t\t\tflags: 0,\n\t\t\t\tbot: true,\n\t\t\t\tbanner: null,\n\t\t\t\taccent_color: null,\n\t\t\t\tglobal_name: null,\n\t\t\t\tavatar_decoration_data: null,\n\t\t\t\tbanner_color: null,\n\t\t\t},\n\t\t\tcontent: 'msg 3',\n\t\t\ttimestamp: '2023-10-31T05:04:02.260000+00:00',\n\t\t\ttype: 0,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['get.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/message/getAll.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/channels/1168516240332034067/messages?limit=1')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tid: '1168784010269433998',\n\t\t\t\ttype: 0,\n\t\t\t\tcontent: 'msg 4',\n\t\t\t\tchannel_id: '1168516240332034067',\n\t\t\t\tauthor: {\n\t\t\t\t\tid: '1070667629972430879',\n\t\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '1037',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbot: true,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: null,\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\tattachments: [],\n\t\t\t\tembeds: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'rich',\n\t\t\t\t\t\ttitle: 'Some Title',\n\t\t\t\t\t\tdescription: 'description',\n\t\t\t\t\t\tcolor: 2112935,\n\t\t\t\t\t\ttimestamp: '2023-10-30T22:00:00+00:00',\n\t\t\t\t\t\tauthor: {\n\t\t\t\t\t\t\tname: 'Me',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tmentions: [],\n\t\t\t\tmention_roles: [],\n\t\t\t\tpinned: false,\n",
        "parsed_sections": {
          "class_name": "DiscordV1",
          "node_type": "discord",
          "version": 1.0,
          "description": null,
          "properties": [],
          "methods": [
            "function",
            "execute"
          ],
          "credentials": [
            "discordBotApi",
            "discordOAuth2Api",
            "discordWebhookApi"
          ],
          "resources": [
            "channel",
            "member",
            "message"
          ],
          "has_router": true,
          "files": [
            "Discord.node.ts",
            "test/v2/node/channel/create.test.ts",
            "test/v2/node/channel/deleteChannel.test.ts",
            "test/v2/node/channel/get.test.ts",
            "test/v2/node/channel/getAll.test.ts",
            "test/v2/node/channel/update.test.ts",
            "test/v2/node/member/getAll.test.ts",
            "test/v2/node/member/roleAdd.test.ts",
            "test/v2/node/member/roleRemove.test.ts",
            "test/v2/node/message/deleteMessage.test.ts",
            "test/v2/node/message/get.test.ts",
            "test/v2/node/message/getAll.test.ts",
            "test/v2/node/message/react.test.ts",
            "test/v2/node/message/send.test.ts",
            "test/v2/node/message/sendAndWait.test.ts",
            "test/v2/node/webhook/sendLegacy.test.ts",
            "test/v2/utils.test.ts",
            "v1/DiscordV1.node.ts",
            "v1/Interfaces.ts",
            "v2/DiscordV2.node.ts",
            "v2/actions/channel/create.operation.ts",
            "v2/actions/channel/deleteChannel.operation.ts",
            "v2/actions/channel/get.operation.ts",
            "v2/actions/channel/getAll.operation.ts",
            "v2/actions/channel/index.ts",
            "v2/actions/channel/update.operation.ts",
            "v2/actions/common.description.ts",
            "v2/actions/member/getAll.operation.ts",
            "v2/actions/member/index.ts",
            "v2/actions/member/roleAdd.operation.ts",
            "v2/actions/member/roleRemove.operation.ts",
            "v2/actions/message/deleteMessage.operation.ts",
            "v2/actions/message/get.operation.ts",
            "v2/actions/message/getAll.operation.ts",
            "v2/actions/message/index.ts",
            "v2/actions/message/react.operation.ts",
            "v2/actions/message/send.operation.ts",
            "v2/actions/message/sendAndWait.operation.ts",
            "v2/actions/node.type.ts",
            "v2/actions/router.ts",
            "v2/actions/versionDescription.ts",
            "v2/actions/webhook/index.ts",
            "v2/actions/webhook/sendLegacy.operation.ts",
            "v2/helpers/utils.ts",
            "v2/methods/index.ts",
            "v2/methods/listSearch.ts",
            "v2/methods/loadOptions.ts",
            "v2/transport/discord.api.ts",
            "v2/transport/helpers.ts",
            "v2/transport/index.ts"
          ],
          "code": [
            {
              "file": "Discord.node.ts",
              "content": "import type { INodeTypeBaseDescription, IVersionedNodeType } from 'n8n-workflow';\nimport { VersionedNodeType } from 'n8n-workflow';\n\nimport { DiscordV1 } from './v1/DiscordV1.node';\nimport { DiscordV2 } from './v2/DiscordV2.node';\n\nexport class Discord extends VersionedNodeType {\n\tconstructor() {\n\t\tconst baseDescription: INodeTypeBaseDescription = {\n\t\t\tdisplayName: 'Discord',\n\t\t\tname: 'discord',\n\t\t\ticon: 'file:discord.svg',\n\t\t\tgroup: ['output'],\n\t\t\tdefaultVersion: 2,\n\t\t\tdescription: 'Sends data to Discord',\n\t\t};\n\n\t\tconst nodeVersions: IVersionedNodeType['nodeVersions'] = {\n\t\t\t1: new DiscordV1(baseDescription),\n\t\t\t2: new DiscordV2(baseDescription),\n\t\t};\n\n\t\tsuper(nodeVersions, baseDescription);\n\t}\n}\n"
            },
            {
              "file": "test/v2/node/channel/create.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => create', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.post('/guilds/1168516062791340136/channels', { name: 'third', type: '0' })\n\t\t.reply(200, {\n\t\t\tid: '1168528323006181417',\n\t\t\ttype: 0,\n\t\t\tlast_message_id: null,\n\t\t\tflags: 0,\n\t\t\tguild_id: '1168516062791340136',\n\t\t\tname: 'third',\n\t\t\tparent_id: null,\n\t\t\trate_limit_per_user: 0,\n\t\t\ttopic: null,\n\t\t\tposition: 3,\n\t\t\tpermission_overwrites: [],\n\t\t\tnsfw: false,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['create.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/channel/deleteChannel.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => deleteChannel', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.delete('/channels/1168528323006181417')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['deleteChannel.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/channel/get.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => get', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.persist()\n\t\t.get('/users/@me/guilds')\n\t\t.reply(200, [{ id: '1168516062791340136' }])\n\t\t.get('/channels/1168516240332034067')\n\t\t.reply(200, {\n\t\t\tid: '1168516240332034067',\n\t\t\ttype: 0,\n\t\t\tlast_message_id: null,\n\t\t\tflags: 0,\n\t\t\tguild_id: '1168516062791340136',\n\t\t\tname: 'first',\n\t\t\tparent_id: '1168516063340789831',\n\t\t\trate_limit_per_user: 0,\n\t\t\ttopic: null,\n\t\t\tposition: 1,\n\t\t\tpermission_overwrites: [],\n\t\t\tnsfw: false,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['get.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/channel/getAll.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/guilds/1168516062791340136/channels')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tid: '1168516063340789831',\n\t\t\t\ttype: 4,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'Text Channels',\n\t\t\t\tparent_id: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789832',\n\t\t\t\ttype: 4,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'Voice Channels',\n\t\t\t\tparent_id: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789833',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: '1168518371239792720',\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'general',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\ttopic: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t\ticon_emoji: {\n\t\t\t\t\tid: null,\n\t\t\t\t\tname: 'ðŸ‘‹',\n\t\t\t\t},\n\t\t\t\ttheme_color: null,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789834',\n\t\t\t\ttype: 2,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'General',\n\t\t\t\tparent_id: '1168516063340789832',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\tbitrate: 64000,\n\t\t\t\tuser_limit: 0,\n\t\t\t\trtc_region: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t\ticon_emoji: {\n\t\t\t\t\tid: null,\n\t\t\t\t\tname: 'ðŸŽ™ï¸',\n\t\t\t\t},\n\t\t\t\ttheme_color: null,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516240332034067',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'first-channel',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 30,\n\t\t\t\ttopic: 'This is channel topic',\n\t\t\t\tposition: 3,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516269079793766',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'second',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\ttopic: null,\n\t\t\t\tposition: 2,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/channel/update.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => update', () => {\n\tnock('https://discord.com/api/v10').patch('/channels/1168516240332034067').reply(200, {\n\t\tid: '1168516240332034067',\n\t\ttype: 0,\n\t\tlast_message_id: null,\n\t\tflags: 0,\n\t\tguild_id: '1168516062791340136',\n\t\tname: 'first-channel',\n\t\tparent_id: '1168516063340789831',\n\t\trate_limit_per_user: 30,\n\t\ttopic: 'This is channel topic',\n\t\tposition: 3,\n\t\tpermission_overwrites: [],\n\t\tnsfw: true,\n\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['update.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/member/getAll.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/guilds/1168516062791340136/members?limit=2')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tuser: {\n\t\t\t\t\tid: '470936827994570762',\n\t\t\t\t\tusername: 'michael',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '0',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: 'Michael',\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\troles: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: {\n\t\t\t\t\tid: '1070667629972430879',\n\t\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '1037',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbot: true,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: null,\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\troles: ['1168518368526077992'],\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/member/roleAdd.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => roleAdd', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.put('/guilds/1168516062791340136/members/470936827994570762/roles/1168772374540320890')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['roleAdd.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/member/roleRemove.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => roleRemove', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.persist()\n\t\t.delete(/\\/guilds\\/1168516062791340136\\/members\\/470936827994570762\\/roles\\/\\d+/)\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['roleRemove.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/message/deleteMessage.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => deleteMessage', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.delete('/channels/1168516240332034067/messages/1168776343194972210')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['deleteMessage.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/message/get.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => get', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/channels/1168516240332034067/messages/1168777380144369718')\n\t\t.reply(200, {\n\t\t\tid: '1168777380144369718',\n\t\t\tchannel_id: '1168516240332034067',\n\t\t\tauthor: {\n\t\t\t\tid: '1070667629972430879',\n\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\tavatar: null,\n\t\t\t\tdiscriminator: '1037',\n\t\t\t\tpublic_flags: 0,\n\t\t\t\tpremium_type: 0,\n\t\t\t\tflags: 0,\n\t\t\t\tbot: true,\n\t\t\t\tbanner: null,\n\t\t\t\taccent_color: null,\n\t\t\t\tglobal_name: null,\n\t\t\t\tavatar_decoration_data: null,\n\t\t\t\tbanner_color: null,\n\t\t\t},\n\t\t\tcontent: 'msg 3',\n\t\t\ttimestamp: '2023-10-31T05:04:02.260000+00:00',\n\t\t\ttype: 0,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['get.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/message/getAll.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/channels/1168516240332034067/messages?limit=1')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tid: '1168784010269433998',\n\t\t\t\ttype: 0,\n\t\t\t\tcontent: 'msg 4',\n\t\t\t\tchannel_id: '1168516240332034067',\n\t\t\t\tauthor: {\n\t\t\t\t\tid: '1070667629972430879',\n\t\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '1037',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbot: true,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: null,\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\tattachments: [],\n\t\t\t\tembeds: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'rich',\n\t\t\t\t\t\ttitle: 'Some Title',\n\t\t\t\t\t\tdescription: 'description',\n\t\t\t\t\t\tcolor: 2112935,\n\t\t\t\t\t\ttimestamp: '2023-10-30T22:00:00+00:00',\n\t\t\t\t\t\tauthor: {\n\t\t\t\t\t\t\tname: 'Me',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tmentions: [],\n\t\t\t\tmention_roles: [],\n\t\t\t\tpinned: false,\n\t\t\t\tmention_everyone: false,\n\t\t\t\ttts: false,\n\t\t\t\ttimestamp: '2023-10-31T05:30:23.005000+00:00',\n\t\t\t\tedited_timestamp: null,\n\t\t\t\tflags: 0,\n\t\t\t\tcomponents: [],\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/message/react.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => react', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.put('/channels/1168516240332034067/messages/1168777380144369718/reactions/%F0%9F%98%80/@me')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['react.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/message/send.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => send', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.post('/channels/1168516240332034067/messages', {\n\t\t\tcontent: 'msg 4',\n\t\t\tembeds: [\n\t\t\t\t{\n\t\t\t\t\tauthor: { name: 'Me' },\n\t\t\t\t\tcolor: 2112935,\n\t\t\t\t\tdescription: 'description',\n\t\t\t\t\ttimestamp: '2023-10-30T22:00:00.000Z',\n\t\t\t\t\ttitle: 'Some Title',\n\t\t\t\t},\n\t\t\t],\n\t\t})\n\t\t.reply(200, {\n\t\t\tid: '1168784010269433998',\n\t\t\ttype: 0,\n\t\t\tcontent: 'msg 4',\n\t\t\tchannel_id: '1168516240332034067',\n\t\t\tauthor: {\n\t\t\t\tid: '1070667629972430879',\n\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\tavatar: null,\n\t\t\t\tdiscriminator: '1037',\n\t\t\t\tpublic_flags: 0,\n\t\t\t\tpremium_type: 0,\n\t\t\t\tflags: 0,\n\t\t\t\tbot: true,\n\t\t\t\tbanner: null,\n\t\t\t\taccent_color: null,\n\t\t\t\tglobal_name: null,\n\t\t\t\tavatar_decoration_data: null,\n\t\t\t\tbanner_color: null,\n\t\t\t},\n\t\t\tattachments: [],\n\t\t\tembeds: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'rich',\n\t\t\t\t\ttitle: 'Some Title',\n\t\t\t\t\tdescription: 'description',\n\t\t\t\t\tcolor: 2112935,\n\t\t\t\t\ttimestamp: '2023-10-30T22:00:00+00:00',\n\t\t\t\t\tauthor: {\n\t\t\t\t\t\tname: 'Me',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tmentions: [],\n\t\t\tmention_roles: [],\n\t\t\tpinned: false,\n\t\t\tmention_everyone: false,\n\t\t\ttts: false,\n\t\t\ttimestamp: '2023-10-31T05:30:23.005000+00:00',\n\t\t\tedited_timestamp: null,\n\t\t\tflags: 0,\n\t\t\tcomponents: [],\n\t\t\treferenced_message: null,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['send.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/message/sendAndWait.test.ts",
              "content": "import type { MockProxy } from 'jest-mock-extended';\nimport { mock } from 'jest-mock-extended';\nimport { SEND_AND_WAIT_OPERATION, type IExecuteFunctions } from 'n8n-workflow';\n\nimport { versionDescription } from '../../../../v2/actions/versionDescription';\nimport { DiscordV2 } from '../../../../v2/DiscordV2.node';\nimport * as transport from '../../../../v2/transport/discord.api';\n\njest.mock('../../../../v2/transport/discord.api', () => {\n\tconst originalModule = jest.requireActual('../../../../v2/transport/discord.api');\n\treturn {\n\t\t...originalModule,\n\t\tdiscordApiRequest: jest.fn(async function (method: string) {\n\t\t\tif (method === 'POST') {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}),\n\t};\n});\n\ndescribe('Test DiscordV2, message => sendAndWait', () => {\n\tlet discord: DiscordV2;\n\tlet mockExecuteFunctions: MockProxy<IExecuteFunctions>;\n\n\tbeforeEach(() => {\n\t\tdiscord = new DiscordV2(versionDescription);\n\t\tmockExecuteFunctions = mock<IExecuteFunctions>();\n\t\tmockExecuteFunctions.helpers = {\n\t\t\tconstructExecutionMetaData: jest.fn(() => []),\n\t\t\treturnJsonArray: jest.fn(() => []),\n\t\t} as any;\n\t});\n\n\tafterEach(() => {\n\t\tjest.clearAllMocks();\n\t});\n\n\tit('should send message and put execution to wait', async () => {\n\t\tconst items = [{ json: { data: 'test' } }];\n\t\tmockExecuteFunctions.getNodeParameter.mockImplementation((key: string) => {\n\t\t\tif (key === 'operation') return SEND_AND_WAIT_OPERATION;\n\t\t\tif (key === 'resource') return 'message';\n\t\t\tif (key === 'authentication') return 'botToken';\n\t\t\tif (key === 'message') return 'my message';\n\t\t\tif (key === 'subject') return '';\n\t\t\tif (key === 'approvalOptions.values') return {};\n\t\t\tif (key === 'responseType') return 'approval';\n\t\t\tif (key === 'sendTo') return 'channel';\n\t\t\tif (key === 'channelId') return 'channelID';\n\t\t\tif (key === 'options.limitWaitTime.values') return {};\n\t\t});\n\n\t\tmockExecuteFunctions.putExecutionToWait.mockImplementation();\n\t\tmockExecuteFunctions.getInputData.mockReturnValue(items);\n\t\tmockExecuteFunctions.getInstanceId.mockReturnValue('instanceId');\n\n\t\tmockExecuteFunctions.evaluateExpression.mockReturnValueOnce('http://localhost/waiting-webhook');\n\t\tmockExecuteFunctions.evaluateExpression.mockReturnValueOnce('nodeID');\n\n\t\tmockExecuteFunctions.getSignedResumeUrl.mockReturnValue(\n\t\t\t'http://localhost/waiting-webhook/nodeID?approved=true&token=abc',\n\t\t);\n\n\t\tconst result = await discord.execute.call(mockExecuteFunctions);\n\n\t\texpect(result).toEqual([items]);\n\t\texpect(transport.discordApiRequest).toHaveBeenCalledTimes(1);\n\t\texpect(mockExecuteFunctions.putExecutionToWait).toHaveBeenCalledTimes(1);\n\n\t\texpect(transport.discordApiRequest).toHaveBeenCalledWith(\n\t\t\t'POST',\n\t\t\t'/channels/channelID/messages',\n\t\t\t{\n\t\t\t\tcomponents: [\n\t\t\t\t\t{\n\t\t\t\t\t\tcomponents: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlabel: 'Approve',\n\t\t\t\t\t\t\t\tstyle: 5,\n\t\t\t\t\t\t\t\ttype: 2,\n\t\t\t\t\t\t\t\turl: 'http://localhost/waiting-webhook/nodeID?approved=true&token=abc',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\ttype: 1,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tembeds: [\n\t\t\t\t\t{\n\t\t\t\t\t\tcolor: 5814783,\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'my message\\n\\n_This message was sent automatically with _[n8n](https://n8n.io/?utm_source=n8n-internal&utm_medium=powered_by&utm_campaign=n8n-nodes-base.discord_instanceId)',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t);\n\t});\n});\n"
            },
            {
              "file": "test/v2/node/webhook/sendLegacy.test.ts",
              "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, webhook => sendLegacy', () => {\n\tconst credentials = {\n\t\tdiscordWebhookApi: {\n\t\t\twebhookUri: 'https://discord.com/webhook',\n\t\t},\n\t};\n\n\tnock(credentials.discordWebhookApi.webhookUri)\n\t\t.post('?wait=true')\n\t\t.reply(200, {\n\t\t\tid: '1168768986385747999',\n\t\t\ttype: 0,\n\t\t\tcontent: 'TEST Message',\n\t\t\tchannel_id: '1074646335082479626',\n\t\t\tauthor: {\n\t\t\t\tid: '1153265494955135077',\n\t\t\t\tusername: 'TEST_USER',\n\t\t\t\tavatar: null,\n\t\t\t\tdiscriminator: '0000',\n\t\t\t\tpublic_flags: 0,\n\t\t\t\tflags: 0,\n\t\t\t\tbot: true,\n\t\t\t\tglobal_name: null,\n\t\t\t},\n\t\t\tattachments: [],\n\t\t\tembeds: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'rich',\n\t\t\t\t\tdescription: 'some description',\n\t\t\t\t\tcolor: 10930459,\n\t\t\t\t\ttimestamp: '2023-10-17T21:00:00+00:00',\n\t\t\t\t\tauthor: {\n\t\t\t\t\t\tname: 'Michael',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tmentions: [],\n\t\t\tmention_roles: [],\n\t\t\tpinned: false,\n\t\t\tmention_everyone: false,\n\t\t\ttts: true,\n\t\t\ttimestamp: '2023-10-31T04:30:41.032000+00:00',\n\t\t\tedited_timestamp: null,\n\t\t\tflags: 4096,\n\t\t\tcomponents: [],\n\t\t\twebhook_id: '1153265494955135077',\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tcredentials,\n\t\tworkflowFiles: ['sendLegacy.workflow.json'],\n\t});\n});\n"
            },
            {
              "file": "test/v2/utils.test.ts",
              "content": "import type { IExecuteFunctions, INode } from 'n8n-workflow';\n\nimport * as transport from '../../v2//transport/discord.api';\nimport {\n\tcreateSimplifyFunction,\n\tprepareOptions,\n\tprepareEmbeds,\n\tcheckAccessToGuild,\n\tsetupChannelGetter,\n} from '../../v2/helpers/utils';\n\nconst node: INode = {\n\tid: '1',\n\tname: 'Discord node',\n\ttypeVersion: 2,\n\ttype: 'n8n-nodes-base.discord',\n\tposition: [60, 760],\n\tparameters: {\n\t\tresource: 'channel',\n\t\toperation: 'get',\n\t},\n};\n\ndescribe('Test Discord > createSimplifyFunction', () => {\n\tit('should create function', () => {\n\t\tconst result = createSimplifyFunction(['message_reference']);\n\t\texpect(result).toBeDefined();\n\t\texpect(typeof result).toBe('function');\n\t});\n\n\tit('should return object containing only specified fields', () => {\n\t\tconst simplify = createSimplifyFunction(['id', 'name']);\n\t\tconst data = {\n\t\t\tid: '123',\n\t\t\tname: 'test',\n\t\t\ttype: 'test',\n\t\t\trandomField: 'test',\n\t\t};\n\t\tconst result = simplify(data);\n\t\texpect(result).toEqual({\n\t\t\tid: '123',\n\t\t\tname: 'test',\n\t\t});\n\t});\n});\n\ndescribe('Test Discord > prepareOptions', () => {\n\tit('should return correct flag value', () => {\n\t\tconst result = prepareOptions({\n\t\t\tflags: ['SUPPRESS_EMBEDS', 'SUPPRESS_NOTIFICATIONS'],\n\t\t});\n\t\texpect(result.flags).toBe((1 << 2) + (1 << 12));\n\t});\n\n\tit('should convert message_reference', () => {\n\t\tconst result = prepareOptions(\n\t\t\t{\n\t\t\t\tmessage_reference: '123456',\n\t\t\t},\n\t\t\t'789000',\n\t\t);\n\t\texpect(result.message_reference).toEqual({\n\t\t\tmessage_id: '123456',\n\t\t\tguild_id: '789000',\n\t\t});\n\t});\n});\n\ndescribe('Test Discord > prepareEmbeds', () => {\n\tit('should return return empty object removing empty strings', () => {\n\t\tconst embeds = [\n\t\t\t{\n\t\t\t\ttest1: 'test',\n\t\t\t\ttest2: 'test',\n\t\t\t\tdescription: 'test',\n\t\t\t},\n\t\t];\n\n\t\tconst executeFunction = {};\n\n\t\tconst result = prepareEmbeds.call(executeFunction as unknown as IExecuteFunctions, embeds);\n\n\t\texpect(result).toEqual(embeds);\n\t});\n});\n\ndescribe('Test Discord > checkAccessToGuild', () => {\n\tit('should throw error', () => {\n\t\tconst guildId = '123456';\n\t\tconst guilds = [\n\t\t\t{\n\t\t\t\tid: '789000',\n\t\t\t},\n\t\t];\n\n\t\texpect(() => {\n\t\t\tcheckAccessToGuild(node, guildId, guilds);\n\t\t}).toThrow('You do not have access to the guild with the id 123456');\n\t});\n\n\tit('should pass', () => {\n\t\tconst guildId = '123456';\n\t\tconst guilds = [\n\t\t\t{\n\t\t\t\tid: '123456',\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '789000',\n\t\t\t},\n\t\t];\n\n\t\texpect(() => {\n\t\t\tcheckAccessToGuild(node, guildId, guilds);\n\t\t}).not.toThrow();\n\t});\n});\n\ndescribe('Test Discord > setupChannelGetter & checkAccessToChannel', () => {\n\tconst discordApiRequestSpy = jest.spyOn(transport, 'discordApiRequest');\n\tdiscordApiRequestSpy.mockImplementation(async (method: string) => {\n\t\tif (method === 'GET') {\n\t\t\treturn {\n\t\t\t\tguild_id: '123456',\n\t\t\t};\n\t\t}\n\t});\n\n\tit('should setup channel getter and get channel id', async () => {\n\t\tconst fakeExecuteFunction = (auth: string) => {\n\t\t\treturn {\n\t\t\t\tgetNodeParameter: (parameter: string) => {\n\t\t\t\t\tif (parameter === 'authentication') return auth;\n\t\t\t\t\tif (parameter === 'channelId') return '42';\n\t\t\t\t},\n\t\t\t\tgetNode: () => node,\n\t\t\t} as unknown as IExecuteFunctions;\n\t\t};\n\n\t\tconst userGuilds = [\n\t\t\t{\n\t\t\t\tid: '789000',\n\t\t\t},\n\t\t];\n\n\t\ttry {\n\t\t\tconst getChannel = await setupChannelGetter.call(fakeExecuteFunction('oAuth2'), userGuilds);\n\t\t\tawait getChannel(0);\n\t\t} catch (error) {\n\t\t\texpect(error.message).toBe('You do not have access to the guild with the id 123456');\n\t\t}\n\n\t\tconst getChannel = await setupChannelGetter.call(fakeExecuteFunction('botToken'), userGuilds);\n\t\tconst channelId = await getChannel(0);\n\t\texpect(channelId).toBe('42');\n\t});\n});\n"
            },
            {
              "file": "v1/DiscordV1.node.ts",
              "content": "import type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n\tIRequestOptions,\n} from 'n8n-workflow';\nimport {\n\tjsonParse,\n\tNodeApiError,\n\tNodeConnectionTypes,\n\tNodeOperationError,\n\tsleep,\n} from 'n8n-workflow';\n\nimport type { DiscordAttachment, DiscordWebhook } from './Interfaces';\nimport { oldVersionNotice } from '../../../utils/descriptions';\n\nconst versionDescription: INodeTypeDescription = {\n\tdisplayName: 'Discord',\n\tname: 'discord',\n\ticon: 'file:discord.svg',\n\tgroup: ['output'],\n\tversion: 1,\n\tdescription: 'Sends data to Discord',\n\tdefaults: {\n\t\tname: 'Discord',\n\t},\n\tinputs: [NodeConnectionTypes.Main],\n\toutputs: [NodeConnectionTypes.Main],\n\tproperties: [\n\t\toldVersionNotice,\n\t\t{\n\t\t\tdisplayName: 'Webhook URL',\n\t\t\tname: 'webhookUri',\n\t\t\ttype: 'string',\n\t\t\trequired: true,\n\t\t\tdefault: '',\n\t\t\tplaceholder: 'https://discord.com/api/webhooks/ID/TOKEN',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Content',\n\t\t\tname: 'text',\n\t\t\ttype: 'string',\n\t\t\ttypeOptions: {\n\t\t\t\tmaxValue: 2000,\n\t\t\t},\n\t\t\tdefault: '',\n\t\t\tplaceholder: 'Hello World!',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Additional Fields',\n\t\t\tname: 'options',\n\t\t\ttype: 'collection',\n\t\t\tplaceholder: 'Add option',\n\t\t\tdefault: {},\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Allowed Mentions',\n\t\t\t\t\tname: 'allowedMentions',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Attachments',\n\t\t\t\t\tname: 'attachments',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Avatar URL',\n\t\t\t\t\tname: 'avatarUrl',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Components',\n\t\t\t\t\tname: 'components',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Embeds',\n\t\t\t\t\tname: 'embeds',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Flags',\n\t\t\t\t\tname: 'flags',\n\t\t\t\t\ttype: 'number',\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'JSON Payload',\n\t\t\t\t\tname: 'payloadJson',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Username',\n\t\t\t\t\tname: 'username',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\tplaceholder: 'User',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'TTS',\n\t\t\t\t\tname: 'tts',\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tdefault: false,\n\t\t\t\t\tdescription: 'Whether this message be sent as a Text To Speech message',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport class DiscordV1 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t};\n\t}\n\n\tasync execute(this: IExecuteFunctions) {\n\t\tconst returnData: INodeExecutionData[] = [];\n\n\t\tconst webhookUri = this.getNodeParameter('webhookUri', 0, '') as string;\n\n\t\tif (!webhookUri) throw new NodeOperationError(this.getNode(), 'Webhook uri is required.');\n\n\t\tconst items = this.getInputData();\n\t\tconst length = items.length;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst body: DiscordWebhook = {};\n\n\t\t\tconst iterationWebhookUri = this.getNodeParameter('webhookUri', i) as string;\n\t\t\tbody.content = this.getNodeParameter('text', i) as string;\n\t\t\tconst options = this.getNodeParameter('options', i);\n\n\t\t\tif (!body.content && !options.embeds) {\n\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Either content or embeds must be set.', {\n\t\t\t\t\titemIndex: i,\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (options.embeds) {\n\t\t\t\ttry {\n\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\tbody.embeds = JSON.parse(options.embeds);\n\t\t\t\t\tif (!Array.isArray(body.embeds)) {\n\t\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Embeds must be an array of embeds.', {\n\t\t\t\t\t\t\titemIndex: i,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Embeds must be valid JSON.', {\n\t\t\t\t\t\titemIndex: i,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.username) {\n\t\t\t\tbody.username = options.username as string;\n\t\t\t}\n\n\t\t\tif (options.components) {\n\t\t\t\ttry {\n\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\tbody.components = JSON.parse(options.components);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Components must be valid JSON.', {\n\t\t\t\t\t\titemIndex: i,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (options.allowed_mentions) {\n\t\t\t\t//@ts-expect-error\n\t\t\t\tbody.allowed_mentions = jsonParse(options.allowed_mentions);\n\t\t\t}\n\n\t\t\tif (options.avatarUrl) {\n\t\t\t\tbody.avatar_url = options.avatarUrl as string;\n\t\t\t}\n\n\t\t\tif (options.flags) {\n\t\t\t\tbody.flags = options.flags as number;\n\t\t\t}\n\n\t\t\tif (options.tts) {\n\t\t\t\tbody.tts = options.tts as boolean;\n\t\t\t}\n\n\t\t\tif (options.payloadJson) {\n\t\t\t\t//@ts-expect-error\n\t\t\t\tbody.payload_json = jsonParse(options.payloadJson);\n\t\t\t}\n\n\t\t\tif (options.attachments) {\n\t\t\t\t//@ts-expect-error\n\t\t\t\tbody.attachments = jsonParse(options.attachments as DiscordAttachment[]);\n\t\t\t}\n\n\t\t\t//* Not used props, delete them from the payload as Discord won't need them :^\n\t\t\tif (!body.content) delete body.content;\n\t\t\tif (!body.username) delete body.username;\n\t\t\tif (!body.avatar_url) delete body.avatar_url;\n\t\t\tif (!body.embeds) delete body.embeds;\n\t\t\tif (!body.allowed_mentions) delete body.allowed_mentions;\n\t\t\tif (!body.flags) delete body.flags;\n\t\t\tif (!body.components) delete body.components;\n\t\t\tif (!body.payload_json) delete body.payload_json;\n\t\t\tif (!body.attachments) delete body.attachments;\n\n\t\t\tlet requestOptions: IRequestOptions;\n\n\t\t\tif (!body.payload_json) {\n\t\t\t\trequestOptions = {\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\tbody,\n\t\t\t\t\turi: iterationWebhookUri,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json; charset=utf-8',\n\t\t\t\t\t},\n\t\t\t\t\tjson: true,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\trequestOptions = {\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\tbody,\n\t\t\t\t\turi: iterationWebhookUri,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'multipart/form-data; charset=utf-8',\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t\tlet maxTries = 5;\n\t\t\tlet response;\n\n\t\t\tdo {\n\t\t\t\ttry {\n\t\t\t\t\tresponse = await this.helpers.request(requestOptions);\n\t\t\t\t\tconst resetAfter = response.headers['x-ratelimit-reset-after'] * 1000;\n\t\t\t\t\tconst remainingRatelimit = response.headers['x-ratelimit-remaining'];\n\n\t\t\t\t\t// remaining requests 0\n\t\t\t\t\t// https://discord.com/developers/docs/topics/rate-limits\n\t\t\t\t\tif (!+remainingRatelimit) {\n\t\t\t\t\t\tawait sleep(resetAfter ?? 1000);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// HTTP/1.1 429 TOO MANY REQUESTS\n\t\t\t\t\t// Await when the current rate limit will reset\n\t\t\t\t\t// https://discord.com/developers/docs/topics/rate-limits\n\t\t\t\t\tif (error.statusCode === 429) {\n\t\t\t\t\t\tconst retryAfter = error.response?.headers['retry-after'] || 1000;\n\n\t\t\t\t\t\tawait sleep(+retryAfter);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t} while (--maxTries);\n\n\t\t\tif (maxTries <= 0) {\n\t\t\t\tthrow new NodeApiError(this.getNode(), {\n\t\t\t\t\terror: 'Could not send Webhook message. Max amount of rate-limit retries reached.',\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\t\t\treturnData.push(...executionData);\n\t\t}\n\n\t\treturn [returnData];\n\t}\n}\n"
            },
            {
              "file": "v1/Interfaces.ts",
              "content": "export interface DiscordWebhook {\n\tcontent?: string;\n\tusername?: string;\n\tavatar_url?: string;\n\ttts?: boolean;\n\tfile?: Buffer;\n\tembeds?: any[];\n\tallowed_mentions?: {\n\t\tparse: Array<'roles' | 'users' | 'everyone'>;\n\t\troles: string[];\n\t\tusers: string[];\n\t\treplied_user: boolean;\n\t};\n\tflags?: number;\n\tattachments?: DiscordAttachment[];\n\tcomponents?: any[];\n\tpayload_json?: any;\n}\n\nexport interface DiscordAttachment {\n\tid?: string;\n\tfilename?: string;\n\tsize?: number;\n\tdescription?: string;\n\tcontent_type?: string;\n\turl?: string;\n\tproxy_url?: string;\n\theight?: number;\n\twidth?: number;\n\tephemeral?: boolean;\n}\n"
            },
            {
              "file": "v2/DiscordV2.node.ts",
              "content": "import type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\n\nimport { router } from './actions/router';\nimport { versionDescription } from './actions/versionDescription';\nimport { listSearch, loadOptions } from './methods';\nimport { sendAndWaitWebhook } from '../../../utils/sendAndWait/utils';\n\nexport class DiscordV2 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t\tusableAsTool: true,\n\t\t};\n\t}\n\n\tmethods = {\n\t\tlistSearch,\n\t\tloadOptions,\n\t};\n\n\twebhook = sendAndWaitWebhook;\n\n\tasync execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {\n\t\treturn await router.call(this);\n\t}\n}\n"
            },
            {
              "file": "v2/actions/channel/create.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { categoryRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Name',\n\t\tname: 'name',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\trequired: true,\n\t\tdescription: 'The name of the channel',\n\t\tplaceholder: 'e.g. new-channel',\n\t},\n\t{\n\t\tdisplayName: 'Type',\n\t\tname: 'type',\n\t\ttype: 'options',\n\t\tdefault: '0',\n\t\trequired: true,\n\t\tdescription: 'The type of channel to create',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Guild Text',\n\t\t\t\tvalue: '0',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Guild Voice',\n\t\t\t\tvalue: '2',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Guild Category',\n\t\t\t\tvalue: '4',\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Age-Restricted (NSFW)',\n\t\t\t\tname: 'nsfw',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether the content of the channel might be nsfw (not safe for work)',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\thide: {\n\t\t\t\t\t\t'/type': ['4'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Bitrate',\n\t\t\t\tname: 'bitrate',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 8000,\n\t\t\t\tplaceholder: 'e.g. 8000',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 8000,\n\t\t\t\t\tmaxValue: 96000,\n\t\t\t\t},\n\t\t\t\tdescription: 'The bitrate (in bits) of the voice channel',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\t'/type': ['2'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\t...categoryRLC,\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\thide: {\n\t\t\t\t\t\t'/type': ['4'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Position',\n\t\t\t\tname: 'position',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Rate Limit Per User',\n\t\t\t\tname: 'rate_limit_per_user',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 0,\n\t\t\t\tdescription: 'Amount of seconds a user has to wait before sending another message',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\thide: {\n\t\t\t\t\t\t'/type': ['4'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Topic',\n\t\t\t\tname: 'topic',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\trows: 2,\n\t\t\t\t},\n\t\t\t\tdescription: 'The channel topic description (0-1024 characters)',\n\t\t\t\tplaceholder: 'e.g. This channel is aboutâ€¦',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\thide: {\n\t\t\t\t\t\t'/type': ['4'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'User Limit',\n\t\t\t\tname: 'user_limit',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 0,\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 0,\n\t\t\t\t\tmaxValue: 99,\n\t\t\t\t},\n\t\t\t\tplaceholder: 'e.g. 20',\n\t\t\t\tdescription:\n\t\t\t\t\t'The limit for the number of members that can be in the channel (0 refers to no limit)',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\t'/type': ['2'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['create'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst name = this.getNodeParameter('name', i) as string;\n\t\t\tconst type = this.getNodeParameter('type', i) as string;\n\t\t\tconst options = this.getNodeParameter('options', i);\n\n\t\t\tif (options.categoryId) {\n\t\t\t\toptions.parent_id = (options.categoryId as IDataObject).value;\n\t\t\t\tdelete options.categoryId;\n\t\t\t}\n\n\t\t\tconst body: IDataObject = {\n\t\t\t\tname,\n\t\t\t\ttype,\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst response = await discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'POST',\n\t\t\t\t`/guilds/${guildId}/channels`,\n\t\t\t\tbody,\n\t\t\t);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/channel/deleteChannel.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [channelRLC];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['deleteChannel'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst response = await discordApiRequest.call(this, 'DELETE', `/channels/${channelId}`);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/channel/get.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [channelRLC];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['get'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst response = await discordApiRequest.call(this, 'GET', `/channels/${channelId}`);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/channel/getAll.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { returnAllOrLimit } from '../../../../../utils/descriptions';\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\n\nconst properties: INodeProperties[] = [\n\t...returnAllOrLimit,\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Filter by Type',\n\t\t\t\tname: 'filter',\n\t\t\t\ttype: 'multiOptions',\n\t\t\t\tdefault: [],\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Guild Text',\n\t\t\t\t\t\tvalue: 0,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Guild Voice',\n\t\t\t\t\t\tvalue: 2,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Guild Category',\n\t\t\t\t\t\tvalue: 4,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['getAll'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\n\ttry {\n\t\tconst returnAll = this.getNodeParameter('returnAll', 0, false);\n\t\tlet response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/channels`);\n\n\t\tif (!returnAll) {\n\t\t\tconst limit = this.getNodeParameter('limit', 0);\n\t\t\tresponse = (response as IDataObject[]).slice(0, limit);\n\t\t}\n\n\t\tconst options = this.getNodeParameter('options', 0, {});\n\n\t\tif (options.filter) {\n\t\t\tconst filter = options.filter as number[];\n\t\t\tresponse = (response as IDataObject[]).filter((item) => filter.includes(item.type as number));\n\t\t}\n\n\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t{ itemData: { item: 0 } },\n\t\t);\n\n\t\treturnData.push(...executionData);\n\t} catch (error) {\n\t\tconst err = parseDiscordError.call(this, error);\n\n\t\tif (this.continueOnFail()) {\n\t\t\treturnData.push(...prepareErrorData.call(this, err, 0));\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/channel/index.ts",
              "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport * as create from './create.operation';\nimport * as deleteChannel from './deleteChannel.operation';\nimport * as get from './get.operation';\nimport * as getAll from './getAll.operation';\nimport * as update from './update.operation';\nimport { guildRLC } from '../common.description';\n\nexport { create, get, getAll, update, deleteChannel };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['channel'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Create',\n\t\t\t\tvalue: 'create',\n\t\t\t\tdescription: 'Create a new channel',\n\t\t\t\taction: 'Create a channel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Delete',\n\t\t\t\tvalue: 'deleteChannel',\n\t\t\t\tdescription: 'Delete a channel',\n\t\t\t\taction: 'Delete a channel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Get',\n\t\t\t\tvalue: 'get',\n\t\t\t\tdescription: 'Get a channel',\n\t\t\t\taction: 'Get a channel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Get Many',\n\t\t\t\tvalue: 'getAll',\n\t\t\t\tdescription: 'Retrieve the channels of a server',\n\t\t\t\taction: 'Get many channels',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Update',\n\t\t\t\tvalue: 'update',\n\t\t\t\tdescription: 'Update a channel',\n\t\t\t\taction: 'Update a channel',\n\t\t\t},\n\t\t],\n\t\tdefault: 'create',\n\t},\n\t{\n\t\t...guildRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['channel'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t},\n\t...create.description,\n\t...deleteChannel.description,\n\t...get.description,\n\t...getAll.description,\n\t...update.description,\n];\n"
            },
            {
              "file": "v2/actions/channel/update.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { categoryRLC, channelRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\tchannelRLC,\n\t{\n\t\tdisplayName: 'Name',\n\t\tname: 'name',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription:\n\t\t\t\"The new name of the channel. Fill this field only if you want to change the channel's name.\",\n\t\tplaceholder: 'e.g. new-channel-name',\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Age-Restricted (NSFW)',\n\t\t\t\tname: 'nsfw',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether the content of the channel might be nsfw (not safe for work)',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Bitrate',\n\t\t\t\tname: 'bitrate',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 8000,\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 8000,\n\t\t\t\t\tmaxValue: 96000,\n\t\t\t\t},\n\t\t\t\tdescription: 'The bitrate (in bits) of the voice channel',\n\t\t\t\thint: 'Only applicable to voice channels',\n\t\t\t},\n\t\t\tcategoryRLC,\n\t\t\t{\n\t\t\t\tdisplayName: 'Position',\n\t\t\t\tname: 'position',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 1,\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'Rate Limit Per User',\n\t\t\t\tname: 'rate_limit_per_user',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 0,\n\t\t\t\tdescription: 'Amount of seconds a user has to wait before sending another message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Topic',\n\t\t\t\tname: 'topic',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\trows: 2,\n\t\t\t\t},\n\t\t\t\tdescription: 'The channel topic description (0-1024 characters)',\n\t\t\t\tplaceholder: 'e.g. This channel is aboutâ€¦',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'User Limit',\n\t\t\t\tname: 'user_limit',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 0,\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 0,\n\t\t\t\t\tmaxValue: 99,\n\t\t\t\t},\n\t\t\t\tplaceholder: 'e.g. 20',\n\t\t\t\thint: 'Only applicable to voice channels',\n\t\t\t\tdescription:\n\t\t\t\t\t'The limit for the number of members that can be in the channel (0 refers to no limit)',\n\t\t\t},\n\t\t],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['update'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst name = this.getNodeParameter('name', i) as string;\n\t\t\tconst options = this.getNodeParameter('options', i);\n\n\t\t\tif (options.categoryId) {\n\t\t\t\toptions.parent_id = (options.categoryId as IDataObject).value;\n\t\t\t\tdelete options.categoryId;\n\t\t\t}\n\n\t\t\tconst body: IDataObject = {\n\t\t\t\tname,\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst response = await discordApiRequest.call(this, 'PATCH', `/channels/${channelId}`, body);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/common.description.ts",
              "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../utils/utilities';\n\nexport const guildRLC: INodeProperties = {\n\tdisplayName: 'Server',\n\tname: 'guildId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'Select the server (guild) that your bot is connected to',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. my-server',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'guildSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By URL',\n\t\t\tname: 'url',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. https://discord.com/channels/[guild-id]',\n\t\t\textractValue: {\n\t\t\t\ttype: 'regex',\n\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/([0-9]+)',\n\t\t\t},\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/([0-9]+)',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Server URL',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 896347036838936576',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Server ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const channelRLC: INodeProperties = {\n\tdisplayName: 'Channel',\n\tname: 'channelId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'Select the channel by name, URL, or ID',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. my-channel',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'channelSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By URL',\n\t\t\tname: 'url',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. https://discord.com/channels/[guild-id]/[channel-id]',\n\t\t\textractValue: {\n\t\t\t\ttype: 'regex',\n\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t},\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Channel URL',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 896347036838936576',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Channel ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const textChannelRLC: INodeProperties = {\n\tdisplayName: 'Channel',\n\tname: 'channelId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'Select the channel by name, URL, or ID',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. my-channel',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'textChannelSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By URL',\n\t\t\tname: 'url',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. https://discord.com/channels/[guild-id]/[channel-id]',\n\t\t\textractValue: {\n\t\t\t\ttype: 'regex',\n\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t},\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Channel URL',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 896347036838936576',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Channel ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const categoryRLC: INodeProperties = {\n\tdisplayName: 'Parent Category',\n\tname: 'categoryId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\tdescription: 'The parent category where you want the channel to appear',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. my-channel',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'categorySearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By URL',\n\t\t\tname: 'url',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. https://discord.com/channels/[guild-id]/[channel-id]',\n\t\t\textractValue: {\n\t\t\t\ttype: 'regex',\n\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t},\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Category URL',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 896347036838936576',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Category ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const userRLC: INodeProperties = {\n\tdisplayName: 'User',\n\tname: 'userId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\tdescription: 'Select the user you want to assign a role to',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. DiscordUser',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'userSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 786953432728469534',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid User ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const roleMultiOptions: INodeProperties = {\n\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-multi-options\n\tdisplayName: 'Role',\n\tname: 'role',\n\ttype: 'multiOptions',\n\ttypeOptions: {\n\t\tloadOptionsMethod: 'getRoles',\n\t\tloadOptionsDependsOn: ['userId.value', 'guildId.value', 'operation'],\n\t},\n\trequired: true,\n\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-multi-options\n\tdescription: 'Select the roles you want to add to the user',\n\tdefault: [],\n};\n\nexport const maxResultsNumber: INodeProperties = {\n\tdisplayName: 'Max Results',\n\tname: 'maxResults',\n\ttype: 'number',\n\ttypeOptions: {\n\t\tminValue: 1,\n\t},\n\tdefault: 50,\n\tdescription: 'Maximum number of results. Too many results may slow down the query.',\n};\n\nexport const messageIdString: INodeProperties = {\n\tdisplayName: 'Message ID',\n\tname: 'messageId',\n\ttype: 'string',\n\tdefault: '',\n\trequired: true,\n\tdescription: 'The ID of the message',\n\tplaceholder: 'e.g. 1057576506244726804',\n};\n\nexport const simplifyBoolean: INodeProperties = {\n\tdisplayName: 'Simplify',\n\tname: 'simplify',\n\ttype: 'boolean',\n\tdefault: true,\n\tdescription: 'Whether to return a simplified version of the response instead of the raw data',\n};\n\n// embeds -----------------------------------------------------------------------------------------\nconst embedFields: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Description',\n\t\tname: 'description',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The description of embed',\n\t\tplaceholder: 'e.g. My description',\n\t\ttypeOptions: {\n\t\t\trows: 2,\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Author',\n\t\tname: 'author',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The name of the author',\n\t\tplaceholder: 'e.g. John Doe',\n\t},\n\t{\n\t\tdisplayName: 'Color',\n\t\tname: 'color',\n\n\t\ttype: 'color',\n\t\tdefault: '',\n\t\tdescription: 'Color code of the embed',\n\t\tplaceholder: 'e.g. 12123432',\n\t},\n\t{\n\t\tdisplayName: 'Timestamp',\n\t\tname: 'timestamp',\n\t\ttype: 'dateTime',\n\t\tdefault: '',\n\t\tdescription: 'The time displayed at the bottom of the embed. Provide in ISO8601 format.',\n\t\tplaceholder: 'e.g. 2023-02-08 09:30:26',\n\t},\n\t{\n\t\tdisplayName: 'Title',\n\t\tname: 'title',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The title of embed',\n\t\tplaceholder: \"e.g. Embed's title\",\n\t},\n\t{\n\t\tdisplayName: 'URL',\n\t\tname: 'url',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The URL where you want to link the embed to',\n\t\tplaceholder: 'e.g. https://discord.com/',\n\t},\n\t{\n\t\tdisplayName: 'URL Image',\n\t\tname: 'image',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'Source URL of image (only supports http(s) and attachments)',\n\t\tplaceholder: 'e.g. https://example.com/image.png',\n\t},\n\t{\n\t\tdisplayName: 'URL Thumbnail',\n\t\tname: 'thumbnail',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'Source URL of thumbnail (only supports http(s) and attachments)',\n\t\tplaceholder: 'e.g. https://example.com/image.png',\n\t},\n\t{\n\t\tdisplayName: 'URL Video',\n\t\tname: 'video',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'Source URL of video',\n\t\tplaceholder: 'e.g. https://example.com/video.mp4',\n\t},\n];\n\nconst embedFieldsDescription = updateDisplayOptions(\n\t{\n\t\tshow: {\n\t\t\tinputMethod: ['fields'],\n\t\t},\n\t},\n\tembedFields,\n);\n\nexport const embedsFixedCollection: INodeProperties = {\n\tdisplayName: 'Embeds',\n\tname: 'embeds',\n\ttype: 'fixedCollection',\n\tplaceholder: 'Add Embeds',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tdefault: [],\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Input Method',\n\t\t\t\t\tname: 'inputMethod',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Enter Fields',\n\t\t\t\t\t\t\tvalue: 'fields',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Raw JSON',\n\t\t\t\t\t\t\tvalue: 'json',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'fields',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\tname: 'json',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\tdefault: '={}',\n\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\trows: 2,\n\t\t\t\t\t},\n\t\t\t\t\tdisplayOptions: {\n\t\t\t\t\t\tshow: {\n\t\t\t\t\t\t\tinputMethod: ['json'],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t...embedFieldsDescription,\n\t\t\t],\n\t\t},\n\t],\n};\n\n// -------------------------------------------------------------------------------------------\n\nexport const filesFixedCollection: INodeProperties = {\n\tdisplayName: 'Files',\n\tname: 'files',\n\ttype: 'fixedCollection',\n\tplaceholder: 'Add Files',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tdefault: [],\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Input Data Field Name',\n\t\t\t\t\tname: 'inputFieldName',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: 'data',\n\t\t\t\t\tdescription: 'The contents of the file being sent with the message',\n\t\t\t\t\tplaceholder: 'e.g. data',\n\t\t\t\t\thint: 'The name of the input field containing the binary file data to be sent',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const sendToProperties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Send To',\n\t\tname: 'sendTo',\n\t\ttype: 'options',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'User',\n\t\t\t\tvalue: 'user',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Channel',\n\t\t\t\tvalue: 'channel',\n\t\t\t},\n\t\t],\n\t\tdefault: 'channel',\n\t\tdescription: 'Send message to a channel or DM to a user',\n\t},\n\n\t{\n\t\t...userRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tsendTo: ['user'],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t...textChannelRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tsendTo: ['channel'],\n\t\t\t},\n\t\t},\n\t},\n];\n"
            },
            {
              "file": "v2/actions/member/getAll.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { returnAllOrLimit } from '../../../../../utils/descriptions';\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { createSimplifyFunction, parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { simplifyBoolean } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\t...returnAllOrLimit,\n\t{\n\t\tdisplayName: 'After',\n\t\tname: 'after',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tplaceholder: 'e.g. 786953432728469534',\n\t\tdescription: 'The ID of the user after which to return the members',\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [simplifyBoolean],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['member'],\n\t\toperation: ['getAll'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\n\tconst returnAll = this.getNodeParameter('returnAll', 0, false);\n\tconst after = this.getNodeParameter('after', 0);\n\n\tconst qs: IDataObject = {};\n\n\tif (!returnAll) {\n\t\tconst limit = this.getNodeParameter('limit', 0);\n\t\tqs.limit = limit;\n\t}\n\n\tif (after) {\n\t\tqs.after = after;\n\t}\n\n\tlet response: IDataObject[] = [];\n\n\ttry {\n\t\tif (!returnAll) {\n\t\t\tconst limit = this.getNodeParameter('limit', 0);\n\t\t\tqs.limit = limit;\n\t\t\tresponse = await discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'GET',\n\t\t\t\t`/guilds/${guildId}/members`,\n\t\t\t\tundefined,\n\t\t\t\tqs,\n\t\t\t);\n\t\t} else {\n\t\t\tlet responseData;\n\t\t\tqs.limit = 100;\n\n\t\t\tdo {\n\t\t\t\tresponseData = await discordApiRequest.call(\n\t\t\t\t\tthis,\n\t\t\t\t\t'GET',\n\t\t\t\t\t`/guilds/${guildId}/members`,\n\t\t\t\t\tundefined,\n\t\t\t\t\tqs,\n\t\t\t\t);\n\t\t\t\tif (!responseData?.length) break;\n\t\t\t\tqs.after = responseData[responseData.length - 1].user.id;\n\t\t\t\tresponse.push(...responseData);\n\t\t\t} while (responseData.length);\n\t\t}\n\n\t\tconst simplify = this.getNodeParameter('options.simplify', 0, false) as boolean;\n\n\t\tif (simplify) {\n\t\t\tconst simplifyResponse = createSimplifyFunction(['user', 'roles', 'permissions']);\n\n\t\t\tresponse = response.map(simplifyResponse);\n\t\t}\n\n\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t{ itemData: { item: 0 } },\n\t\t);\n\n\t\treturnData.push(...executionData);\n\t} catch (error) {\n\t\tconst err = parseDiscordError.call(this, error);\n\n\t\tif (this.continueOnFail()) {\n\t\t\treturnData.push(...prepareErrorData.call(this, err, 0));\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/member/index.ts",
              "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport * as getAll from './getAll.operation';\nimport * as roleAdd from './roleAdd.operation';\nimport * as roleRemove from './roleRemove.operation';\nimport { guildRLC } from '../common.description';\n\nexport { getAll, roleAdd, roleRemove };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['member'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Get Many',\n\t\t\t\tvalue: 'getAll',\n\t\t\t\tdescription: 'Retrieve the members of a server',\n\t\t\t\taction: 'Get many members',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Role Add',\n\t\t\t\tvalue: 'roleAdd',\n\t\t\t\tdescription: 'Add a role to a member',\n\t\t\t\taction: 'Add a role to a member',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Role Remove',\n\t\t\t\tvalue: 'roleRemove',\n\t\t\t\tdescription: 'Remove a role from a member',\n\t\t\t\taction: 'Remove a role from a member',\n\t\t\t},\n\t\t],\n\t\tdefault: 'getAll',\n\t},\n\t{\n\t\t...guildRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['member'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t},\n\t...getAll.description,\n\t...roleAdd.description,\n\t...roleRemove.description,\n];\n"
            },
            {
              "file": "v2/actions/member/roleAdd.operation.ts",
              "content": "import type { IExecuteFunctions, INodeExecutionData, INodeProperties } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { roleMultiOptions, userRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [userRLC, roleMultiOptions];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['member'],\n\t\toperation: ['roleAdd'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst userId = this.getNodeParameter('userId', i, undefined, {\n\t\t\t\textractValue: true,\n\t\t\t}) as string;\n\n\t\t\tconst roles = this.getNodeParameter('role', i, []) as string[];\n\n\t\t\tfor (const roleId of roles) {\n\t\t\t\tawait discordApiRequest.call(\n\t\t\t\t\tthis,\n\t\t\t\t\t'PUT',\n\t\t\t\t\t`/guilds/${guildId}/members/${userId}/roles/${roleId}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/member/roleRemove.operation.ts",
              "content": "import type { IExecuteFunctions, INodeExecutionData, INodeProperties } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { roleMultiOptions, userRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [userRLC, roleMultiOptions];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['member'],\n\t\toperation: ['roleRemove'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst userId = this.getNodeParameter('userId', i, undefined, {\n\t\t\t\textractValue: true,\n\t\t\t}) as string;\n\n\t\t\tconst roles = this.getNodeParameter('role', i, []) as string[];\n\n\t\t\tfor (const roleId of roles) {\n\t\t\t\tawait discordApiRequest.call(\n\t\t\t\t\tthis,\n\t\t\t\t\t'DELETE',\n\t\t\t\t\t`/guilds/${guildId}/members/${userId}/roles/${roleId}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/message/deleteMessage.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC, messageIdString } from '../common.description';\n\nconst properties: INodeProperties[] = [channelRLC, messageIdString];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['deleteMessage'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst messageId = this.getNodeParameter('messageId', i) as string;\n\n\t\t\tawait discordApiRequest.call(this, 'DELETE', `/channels/${channelId}/messages/${messageId}`);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/message/get.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport {\n\tcreateSimplifyFunction,\n\tparseDiscordError,\n\tprepareErrorData,\n\tsetupChannelGetter,\n} from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC, messageIdString, simplifyBoolean } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\tchannelRLC,\n\tmessageIdString,\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [simplifyBoolean],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['get'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\tconst simplifyResponse = createSimplifyFunction([\n\t\t'id',\n\t\t'channel_id',\n\t\t'author',\n\t\t'content',\n\t\t'timestamp',\n\t\t'type',\n\t]);\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst messageId = this.getNodeParameter('messageId', i) as string;\n\n\t\t\tlet response = await discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'GET',\n\t\t\t\t`/channels/${channelId}/messages/${messageId}`,\n\t\t\t);\n\n\t\t\tconst simplify = this.getNodeParameter('options.simplify', i, false) as boolean;\n\n\t\t\tif (simplify) {\n\t\t\t\tresponse = simplifyResponse(response);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/message/getAll.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { returnAllOrLimit } from '../../../../../utils/descriptions';\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport {\n\tcreateSimplifyFunction,\n\tparseDiscordError,\n\tprepareErrorData,\n\tsetupChannelGetter,\n} from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC, simplifyBoolean } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\tchannelRLC,\n\t...returnAllOrLimit,\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [simplifyBoolean],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['getAll'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\tconst simplifyResponse = createSimplifyFunction([\n\t\t'id',\n\t\t'channel_id',\n\t\t'author',\n\t\t'content',\n\t\t'timestamp',\n\t\t'type',\n\t]);\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst returnAll = this.getNodeParameter('returnAll', i, false);\n\n\t\t\tconst qs: IDataObject = {};\n\n\t\t\tlet response: IDataObject[] = [];\n\n\t\t\tif (!returnAll) {\n\t\t\t\tconst limit = this.getNodeParameter('limit', 0);\n\t\t\t\tqs.limit = limit;\n\t\t\t\tresponse = await discordApiRequest.call(\n\t\t\t\t\tthis,\n\t\t\t\t\t'GET',\n\t\t\t\t\t`/channels/${channelId}/messages`,\n\t\t\t\t\tundefined,\n\t\t\t\t\tqs,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tlet responseData;\n\t\t\t\tqs.limit = 100;\n\n\t\t\t\tdo {\n\t\t\t\t\tresponseData = await discordApiRequest.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\t'GET',\n\t\t\t\t\t\t`/channels/${channelId}/messages`,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tqs,\n\t\t\t\t\t);\n\t\t\t\t\tif (!responseData?.length) break;\n\t\t\t\t\tqs.before = responseData[responseData.length - 1].id;\n\t\t\t\t\tresponse.push(...responseData);\n\t\t\t\t} while (responseData.length);\n\t\t\t}\n\n\t\t\tconst simplify = this.getNodeParameter('options.simplify', i, false) as boolean;\n\n\t\t\tif (simplify) {\n\t\t\t\tresponse = response.map(simplifyResponse);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/message/index.ts",
              "content": "import { SEND_AND_WAIT_OPERATION, type INodeProperties } from 'n8n-workflow';\n\nimport * as deleteMessage from './deleteMessage.operation';\nimport * as get from './get.operation';\nimport * as getAll from './getAll.operation';\nimport * as react from './react.operation';\nimport * as send from './send.operation';\nimport * as sendAndWait from './sendAndWait.operation';\nimport { guildRLC } from '../common.description';\n\nexport { getAll, react, send, deleteMessage, get, sendAndWait };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['message'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Delete',\n\t\t\t\tvalue: 'deleteMessage',\n\t\t\t\tdescription: 'Delete a message in a channel',\n\t\t\t\taction: 'Delete a message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Get',\n\t\t\t\tvalue: 'get',\n\t\t\t\tdescription: 'Get a message in a channel',\n\t\t\t\taction: 'Get a message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Get Many',\n\t\t\t\tvalue: 'getAll',\n\t\t\t\tdescription: 'Retrieve the latest messages in a channel',\n\t\t\t\taction: 'Get many messages',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'React with Emoji',\n\t\t\t\tvalue: 'react',\n\t\t\t\tdescription: 'React to a message with an emoji',\n\t\t\t\taction: 'React with an emoji to a message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Send',\n\t\t\t\tvalue: 'send',\n\t\t\t\tdescription: 'Send a message to a channel, thread, or member',\n\t\t\t\taction: 'Send a message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Send and Wait for Response',\n\t\t\t\tvalue: SEND_AND_WAIT_OPERATION,\n\t\t\t\tdescription: 'Send a message and wait for response',\n\t\t\t\taction: 'Send message and wait for response',\n\t\t\t},\n\t\t],\n\t\tdefault: 'send',\n\t},\n\t{\n\t\t...guildRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['message'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t},\n\t...getAll.description,\n\t...react.description,\n\t...send.description,\n\t...deleteMessage.description,\n\t...get.description,\n\t...sendAndWait.description,\n];\n"
            },
            {
              "file": "v2/actions/message/react.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC, messageIdString } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\tchannelRLC,\n\tmessageIdString,\n\t{\n\t\tdisplayName: 'Emoji',\n\t\tname: 'emoji',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\trequired: true,\n\t\tdescription: 'The emoji you want to react with',\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['react'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst messageId = this.getNodeParameter('messageId', i) as string;\n\t\t\tconst emoji = this.getNodeParameter('emoji', i) as string;\n\n\t\t\tawait discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'PUT',\n\t\t\t\t`/channels/${channelId}/messages/${messageId}/reactions/${encodeURIComponent(emoji)}/@me`,\n\t\t\t);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/message/send.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport {\n\tparseDiscordError,\n\tprepareEmbeds,\n\tprepareErrorData,\n\tprepareOptions,\n\tsendDiscordMessage,\n} from '../../helpers/utils';\nimport {\n\tembedsFixedCollection,\n\tfilesFixedCollection,\n\tsendToProperties,\n} from '../common.description';\n\nconst properties: INodeProperties[] = [\n\t...sendToProperties,\n\t{\n\t\tdisplayName: 'Message',\n\t\tname: 'content',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The content of the message (up to 2000 characters)',\n\t\tplaceholder: 'e.g. My message',\n\t\ttypeOptions: {\n\t\t\trows: 2,\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Flags',\n\t\t\t\tname: 'flags',\n\t\t\t\ttype: 'multiOptions',\n\t\t\t\tdefault: [],\n\t\t\t\tdescription:\n\t\t\t\t\t'Message flags. <a href=\"https://discord.com/developers/docs/resources/channel#message-object-message-flags\" target=\"_blank\">More info</a>.â€.',\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Suppress Embeds',\n\t\t\t\t\t\tvalue: 'SUPPRESS_EMBEDS',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Suppress Notifications',\n\t\t\t\t\t\tvalue: 'SUPPRESS_NOTIFICATIONS',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-miscased\n\t\t\t\tdisplayName: 'Message to Reply to',\n\t\t\t\tname: 'message_reference',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'Fill this to make your message a reply. Add the message ID.',\n\t\t\t\tplaceholder: 'e.g. 1059467601836773386',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Text-to-Speech (TTS)',\n\t\t\t\tname: 'tts',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to have a bot reading the message directly in the channel',\n\t\t\t},\n\t\t],\n\t},\n\tembedsFixedCollection,\n\tfilesFixedCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['send'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst content = this.getNodeParameter('content', i) as string;\n\t\tconst options = prepareOptions(this.getNodeParameter('options', i, {}), guildId);\n\n\t\tconst embeds = (this.getNodeParameter('embeds', i, undefined) as IDataObject)\n\t\t\t?.values as IDataObject[];\n\t\tconst files = (this.getNodeParameter('files', i, undefined) as IDataObject)\n\t\t\t?.values as IDataObject[];\n\n\t\tconst body: IDataObject = {\n\t\t\tcontent,\n\t\t\t...options,\n\t\t};\n\n\t\tif (embeds) {\n\t\t\tbody.embeds = prepareEmbeds.call(this, embeds);\n\t\t}\n\n\t\ttry {\n\t\t\treturnData.push(\n\t\t\t\t...(await sendDiscordMessage.call(this, {\n\t\t\t\t\tguildId,\n\t\t\t\t\tuserGuilds,\n\t\t\t\t\tisOAuth2,\n\t\t\t\t\tbody,\n\t\t\t\t\titems,\n\t\t\t\t\tfiles,\n\t\t\t\t\titemIndex: i,\n\t\t\t\t})),\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/actions/message/sendAndWait.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { getSendAndWaitProperties } from '../../../../../utils/sendAndWait/utils';\nimport {\n\tcreateSendAndWaitMessageBody,\n\tparseDiscordError,\n\tprepareErrorData,\n\tsendDiscordMessage,\n} from '../../helpers/utils';\nimport { sendToProperties } from '../common.description';\n\nexport const description: INodeProperties[] = getSendAndWaitProperties(\n\tsendToProperties,\n\t'message',\n\tundefined,\n\t{\n\t\tnoButtonStyle: true,\n\t\tdefaultApproveLabel: 'âœ“ Approve',\n\t\tdefaultDisapproveLabel: 'âœ— Decline',\n\t},\n).filter((p) => p.name !== 'subject');\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst items = this.getInputData();\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';\n\n\ttry {\n\t\tawait sendDiscordMessage.call(this, {\n\t\t\tguildId,\n\t\t\tuserGuilds,\n\t\t\tisOAuth2,\n\t\t\tbody: createSendAndWaitMessageBody(this),\n\t\t\titems,\n\t\t});\n\t} catch (error) {\n\t\tconst err = parseDiscordError.call(this, error, 0);\n\n\t\tif (this.continueOnFail()) {\n\t\t\treturn prepareErrorData.call(this, err, 0);\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\treturn items;\n}\n"
            },
            {
              "file": "v2/actions/node.type.ts",
              "content": "import type { AllEntities } from 'n8n-workflow';\n\ntype NodeMap = {\n\tchannel: 'get' | 'getAll' | 'create' | 'update' | 'deleteChannel';\n\tmessage: 'deleteMessage' | 'getAll' | 'get' | 'react' | 'send' | 'sendAndWait';\n\tmember: 'getAll' | 'roleAdd' | 'roleRemove';\n\twebhook: 'sendLegacy';\n};\n\nexport type Discord = AllEntities<NodeMap>;\n"
            },
            {
              "file": "v2/actions/router.ts",
              "content": "import type { IDataObject, IExecuteFunctions, INodeExecutionData } from 'n8n-workflow';\nimport { NodeOperationError, SEND_AND_WAIT_OPERATION } from 'n8n-workflow';\n\nimport * as channel from './channel';\nimport * as member from './member';\nimport * as message from './message';\nimport type { Discord } from './node.type';\nimport * as webhook from './webhook';\nimport { configureWaitTillDate } from '../../../../utils/sendAndWait/configureWaitTillDate.util';\nimport { checkAccessToGuild } from '../helpers/utils';\nimport { discordApiRequest } from '../transport';\n\nexport async function router(this: IExecuteFunctions) {\n\tlet returnData: INodeExecutionData[] = [];\n\n\tlet resource = 'webhook';\n\t//resource parameter is hidden when authentication is set to webhook\n\t//prevent error when getting resource parameter\n\ttry {\n\t\tresource = this.getNodeParameter<Discord>('resource', 0);\n\t} catch (error) {}\n\tconst operation = this.getNodeParameter('operation', 0);\n\n\tlet guildId = '';\n\tlet userGuilds: IDataObject[] = [];\n\n\tif (resource !== 'webhook') {\n\t\tguildId = this.getNodeParameter('guildId', 0, '', {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst isOAuth2 = this.getNodeParameter('authentication', 0, '') === 'oAuth2';\n\n\t\tif (isOAuth2) {\n\t\t\tuserGuilds = (await discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'GET',\n\t\t\t\t'/users/@me/guilds',\n\t\t\t)) as IDataObject[];\n\n\t\t\tcheckAccessToGuild(this.getNode(), guildId, userGuilds);\n\t\t}\n\t}\n\n\tconst discord = {\n\t\tresource,\n\t\toperation,\n\t} as Discord;\n\n\tif (discord.resource === 'message' && discord.operation === SEND_AND_WAIT_OPERATION) {\n\t\treturnData = await message[discord.operation].execute.call(this, guildId, userGuilds);\n\n\t\tconst waitTill = configureWaitTillDate(this);\n\n\t\tawait this.putExecutionToWait(waitTill);\n\t\treturn [returnData];\n\t}\n\n\tswitch (discord.resource) {\n\t\tcase 'channel':\n\t\t\treturnData = await channel[discord.operation].execute.call(this, guildId, userGuilds);\n\t\t\tbreak;\n\t\tcase 'message':\n\t\t\treturnData = await message[discord.operation].execute.call(this, guildId, userGuilds);\n\t\t\tbreak;\n\t\tcase 'member':\n\t\t\treturnData = await member[discord.operation].execute.call(this, guildId);\n\t\t\tbreak;\n\t\tcase 'webhook':\n\t\t\treturnData = await webhook[discord.operation].execute.call(this);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new NodeOperationError(this.getNode(), `The resource \"${resource}\" is not known`);\n\t}\n\n\treturn [returnData];\n}\n"
            },
            {
              "file": "v2/actions/versionDescription.ts",
              "content": "/* eslint-disable n8n-nodes-base/node-filename-against-convention */\nimport { NodeConnectionTypes, type INodeTypeDescription } from 'n8n-workflow';\n\nimport * as channel from './channel';\nimport * as member from './member';\nimport * as message from './message';\nimport * as webhook from './webhook';\nimport { sendAndWaitWebhooksDescription } from '../../../../utils/sendAndWait/descriptions';\n\nexport const versionDescription: INodeTypeDescription = {\n\tdisplayName: 'Discord',\n\tname: 'discord',\n\ticon: 'file:discord.svg',\n\tgroup: ['output'],\n\tversion: 2,\n\tsubtitle: '={{ $parameter[\"operation\"] + \": \" + $parameter[\"resource\"] }}',\n\tdescription: 'Sends data to Discord',\n\tdefaults: {\n\t\tname: 'Discord',\n\t},\n\tinputs: [NodeConnectionTypes.Main],\n\toutputs: [NodeConnectionTypes.Main],\n\twebhooks: sendAndWaitWebhooksDescription,\n\tcredentials: [\n\t\t{\n\t\t\tname: 'discordBotApi',\n\t\t\trequired: true,\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tauthentication: ['botToken'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'discordOAuth2Api',\n\t\t\trequired: true,\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tauthentication: ['oAuth2'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'discordWebhookApi',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tauthentication: ['webhook'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t],\n\tproperties: [\n\t\t{\n\t\t\tdisplayName: 'Connection Type',\n\t\t\tname: 'authentication',\n\t\t\ttype: 'options',\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Bot Token',\n\t\t\t\t\tvalue: 'botToken',\n\t\t\t\t\tdescription: 'Manage messages, channels, and members on a server',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'OAuth2',\n\t\t\t\t\tvalue: 'oAuth2',\n\t\t\t\t\tdescription: \"Same features as 'Bot Token' with easier Bot installation\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Webhook',\n\t\t\t\t\tvalue: 'webhook',\n\t\t\t\t\tdescription: 'Send messages to a specific channel',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'botToken',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Resource',\n\t\t\tname: 'resource',\n\t\t\ttype: 'options',\n\t\t\tnoDataExpression: true,\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Channel',\n\t\t\t\t\tvalue: 'channel',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Message',\n\t\t\t\t\tvalue: 'message',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Member',\n\t\t\t\t\tvalue: 'member',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'channel',\n\t\t\tdisplayOptions: {\n\t\t\t\thide: {\n\t\t\t\t\tauthentication: ['webhook'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\t...message.description,\n\t\t...channel.description,\n\t\t...member.description,\n\t\t...webhook.description,\n\t],\n};\n"
            },
            {
              "file": "v2/actions/webhook/index.ts",
              "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport * as sendLegacy from './sendLegacy.operation';\n\nexport { sendLegacy };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tauthentication: ['webhook'],\n\t\t\t},\n\t\t},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Send a Message',\n\t\t\t\tvalue: 'sendLegacy',\n\t\t\t\tdescription: 'Send a message to a channel using the webhook',\n\t\t\t\taction: 'Send a message',\n\t\t\t},\n\t\t],\n\t\tdefault: 'sendLegacy',\n\t},\n\t...sendLegacy.description,\n];\n"
            },
            {
              "file": "v2/actions/webhook/sendLegacy.operation.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport {\n\tparseDiscordError,\n\tprepareEmbeds,\n\tprepareErrorData,\n\tprepareMultiPartForm,\n\tprepareOptions,\n} from '../../helpers/utils';\nimport { discordApiMultiPartRequest, discordApiRequest } from '../../transport';\nimport { embedsFixedCollection, filesFixedCollection } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Message',\n\t\tname: 'content',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The content of the message (up to 2000 characters)',\n\t\tplaceholder: 'e.g. My message',\n\t\ttypeOptions: {\n\t\t\trows: 2,\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Avatar URL',\n\t\t\t\tname: 'avatar_url',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'Override the default avatar of the webhook',\n\t\t\t\tplaceholder: 'e.g. https://example.com/image.png',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Flags',\n\t\t\t\tname: 'flags',\n\t\t\t\ttype: 'multiOptions',\n\t\t\t\tdefault: [],\n\t\t\t\tdescription:\n\t\t\t\t\t'Message flags. <a href=\"https://discord.com/developers/docs/resources/channel#message-object-message-flags\" target=\"_blank\">More info</a>.â€.',\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Suppress Embeds',\n\t\t\t\t\t\tvalue: 'SUPPRESS_EMBEDS',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Suppress Notifications',\n\t\t\t\t\t\tvalue: 'SUPPRESS_NOTIFICATIONS',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Text-to-Speech (TTS)',\n\t\t\t\tname: 'tts',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to have a bot reading the message directly in the channel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Username',\n\t\t\t\tname: 'username',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'Override the default username of the webhook',\n\t\t\t\tplaceholder: 'e.g. My Username',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Wait',\n\t\t\t\tname: 'wait',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether wait for the message to be created before returning its response',\n\t\t\t},\n\t\t],\n\t},\n\tembedsFixedCollection,\n\tfilesFixedCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\toperation: ['sendLegacy'],\n\t},\n\thide: {\n\t\tauthentication: ['botToken', 'oAuth2'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(this: IExecuteFunctions): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst content = this.getNodeParameter('content', i) as string;\n\t\tconst options = prepareOptions(this.getNodeParameter('options', i, {}));\n\n\t\tconst embeds = (this.getNodeParameter('embeds', i, undefined) as IDataObject)\n\t\t\t?.values as IDataObject[];\n\t\tconst files = (this.getNodeParameter('files', i, undefined) as IDataObject)\n\t\t\t?.values as IDataObject[];\n\n\t\tlet qs: IDataObject | undefined = undefined;\n\n\t\tif (options.wait) {\n\t\t\tqs = {\n\t\t\t\twait: options.wait,\n\t\t\t};\n\n\t\t\tdelete options.wait;\n\t\t}\n\n\t\tconst body: IDataObject = {\n\t\t\tcontent,\n\t\t\t...options,\n\t\t};\n\n\t\tif (embeds) {\n\t\t\tbody.embeds = prepareEmbeds.call(this, embeds);\n\t\t}\n\n\t\ttry {\n\t\t\tlet response: IDataObject[] = [];\n\n\t\t\tif (files?.length) {\n\t\t\t\tconst multiPartBody = await prepareMultiPartForm.call(this, items, files, body, i);\n\n\t\t\t\tresponse = await discordApiMultiPartRequest.call(this, 'POST', '', multiPartBody);\n\t\t\t} else {\n\t\t\t\tresponse = await discordApiRequest.call(this, 'POST', '', body, qs);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
            },
            {
              "file": "v2/helpers/utils.ts",
              "content": "import FormData from 'form-data';\nimport isEmpty from 'lodash/isEmpty';\nimport { extension } from 'mime-types';\nimport type {\n\tIBinaryKeyData,\n\tIDataObject,\n\tIExecuteFunctions,\n\tINode,\n\tINodeExecutionData,\n} from 'n8n-workflow';\nimport { jsonParse, NodeApiError, NodeOperationError } from 'n8n-workflow';\n\nimport { getSendAndWaitConfig } from '../../../../utils/sendAndWait/utils';\nimport { capitalize, createUtmCampaignLink } from '../../../../utils/utilities';\nimport { discordApiMultiPartRequest, discordApiRequest } from '../transport';\n\nexport const createSimplifyFunction =\n\t(includedFields: string[]) =>\n\t(item: IDataObject): IDataObject => {\n\t\tconst result: IDataObject = {};\n\n\t\tfor (const field of includedFields) {\n\t\t\tif (item[field] === undefined) continue;\n\n\t\t\tresult[field] = item[field];\n\t\t}\n\n\t\treturn result;\n\t};\n\nexport function parseDiscordError(this: IExecuteFunctions, error: any, itemIndex = 0) {\n\tlet errorData = error.cause.error;\n\tconst errorOptions: IDataObject = { itemIndex };\n\n\tif (!errorData && error.description) {\n\t\ttry {\n\t\t\tconst errorString = (error.description as string).split(' - ')[1];\n\t\t\tif (errorString) {\n\t\t\t\terrorData = jsonParse(errorString);\n\t\t\t}\n\t\t} catch (err) {}\n\t}\n\n\tif (errorData?.message) {\n\t\terrorOptions.message = errorData.message;\n\t}\n\n\tif ((error?.message as string)?.toLowerCase()?.includes('bad request') && errorData) {\n\t\tif (errorData?.message) {\n\t\t\terrorOptions.message = errorData.message;\n\t\t}\n\n\t\tif (errorData?.errors?.embeds) {\n\t\t\tconst embedErrors = errorData.errors.embeds?.[0];\n\t\t\tconst embedErrorsKeys = Object.keys(embedErrors).map((key) => capitalize(key));\n\n\t\t\tif (embedErrorsKeys.length) {\n\t\t\t\tconst message =\n\t\t\t\t\tembedErrorsKeys.length === 1\n\t\t\t\t\t\t? `The parameter ${embedErrorsKeys[0]} is not properly formatted`\n\t\t\t\t\t\t: `The parameters ${embedErrorsKeys.join(', ')} are not properly formatted`;\n\t\t\t\terrorOptions.message = message;\n\t\t\t\terrorOptions.description = 'Review the formatting or clear it';\n\t\t\t}\n\n\t\t\treturn new NodeOperationError(this.getNode(), errorData.errors, errorOptions);\n\t\t}\n\n\t\tif (errorData?.errors?.message_reference) {\n\t\t\terrorOptions.message = \"The message to reply to ID can't be found\";\n\t\t\terrorOptions.description =\n\t\t\t\t'Check the \"Message to Reply to\" parameter and remove it if you don\\'t want to reply to an existing message';\n\n\t\t\treturn new NodeOperationError(this.getNode(), errorData.errors, errorOptions);\n\t\t}\n\n\t\tif (errorOptions.message === 'Cannot send an empty message') {\n\t\t\terrorOptions.description =\n\t\t\t\t'Something has to be send to the channel whether it is a message, an embed or a file';\n\t\t}\n\t}\n\treturn new NodeOperationError(this.getNode(), errorData || error, errorOptions);\n}\n\nexport function prepareErrorData(this: IExecuteFunctions, error: any, i: number) {\n\tlet description = error.description;\n\n\ttry {\n\t\tdescription = JSON.parse(error.description as string);\n\t} catch (err) {}\n\n\treturn this.helpers.constructExecutionMetaData(\n\t\tthis.helpers.returnJsonArray({ error: error.message, description }),\n\t\t{ itemData: { item: i } },\n\t);\n}\n\nexport function prepareOptions(options: IDataObject, guildId?: string) {\n\tif (options.flags) {\n\t\tif ((options.flags as string[]).length === 2) {\n\t\t\toptions.flags = (1 << 2) + (1 << 12);\n\t\t} else if ((options.flags as string[]).includes('SUPPRESS_EMBEDS')) {\n\t\t\toptions.flags = 1 << 2;\n\t\t} else if ((options.flags as string[]).includes('SUPPRESS_NOTIFICATIONS')) {\n\t\t\toptions.flags = 1 << 12;\n\t\t}\n\t}\n\n\tif (options.message_reference) {\n\t\toptions.message_reference = {\n\t\t\tmessage_id: options.message_reference,\n\t\t\tguild_id: guildId,\n\t\t};\n\t}\n\n\treturn options;\n}\n\nexport function prepareEmbeds(this: IExecuteFunctions, embeds: IDataObject[]) {\n\treturn embeds\n\t\t.map((embed) => {\n\t\t\tlet embedReturnData: IDataObject = {};\n\n\t\t\tif (embed.inputMethod === 'json') {\n\t\t\t\tif (typeof embed.json === 'object') {\n\t\t\t\t\tembedReturnData = embed.json as IDataObject;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tembedReturnData = jsonParse(embed.json as string);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Not a valid JSON', error);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdelete embed.inputMethod;\n\n\t\t\t\tfor (const key of Object.keys(embed)) {\n\t\t\t\t\tif (embed[key] !== '') {\n\t\t\t\t\t\tembedReturnData[key] = embed[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (embedReturnData.author) {\n\t\t\t\tembedReturnData.author = {\n\t\t\t\t\tname: embedReturnData.author,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (embedReturnData.color && typeof embedReturnData.color === 'string') {\n\t\t\t\tembedReturnData.color = parseInt(embedReturnData.color.replace('#', ''), 16);\n\t\t\t}\n\t\t\tif (embedReturnData.video) {\n\t\t\t\tembedReturnData.video = {\n\t\t\t\t\turl: embedReturnData.video,\n\t\t\t\t\twidth: 1270,\n\t\t\t\t\theight: 720,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (embedReturnData.thumbnail) {\n\t\t\t\tembedReturnData.thumbnail = {\n\t\t\t\t\turl: embedReturnData.thumbnail,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (embedReturnData.image) {\n\t\t\t\tembedReturnData.image = {\n\t\t\t\t\turl: embedReturnData.image,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn embedReturnData;\n\t\t})\n\t\t.filter((embed) => !isEmpty(embed));\n}\n\nexport async function prepareMultiPartForm(\n\tthis: IExecuteFunctions,\n\titems: INodeExecutionData[],\n\tfiles: IDataObject[],\n\tjsonPayload: IDataObject,\n\ti: number,\n) {\n\tconst multiPartBody = new FormData();\n\tconst attachments: IDataObject[] = [];\n\tconst filesData: IDataObject[] = [];\n\n\tfor (const [index, file] of files.entries()) {\n\t\tconst binaryData = (items[i].binary as IBinaryKeyData)?.[file.inputFieldName as string];\n\n\t\tif (!binaryData) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t`Input item [${i}] does not contain binary data on property ${file.inputFieldName}`,\n\t\t\t);\n\t\t}\n\n\t\tlet filename = binaryData.fileName as string;\n\n\t\tif (!filename.includes('.')) {\n\t\t\tif (binaryData.fileExtension) {\n\t\t\t\tfilename += `.${binaryData.fileExtension}`;\n\t\t\t}\n\t\t\tif (binaryData.mimeType) {\n\t\t\t\tfilename += `.${extension(binaryData.mimeType)}`;\n\t\t\t}\n\t\t}\n\n\t\tattachments.push({\n\t\t\tid: index,\n\t\t\tfilename,\n\t\t});\n\n\t\tfilesData.push({\n\t\t\tdata: await this.helpers.getBinaryDataBuffer(i, file.inputFieldName as string),\n\t\t\tname: filename,\n\t\t\tmime: binaryData.mimeType,\n\t\t});\n\t}\n\n\tmultiPartBody.append('payload_json', JSON.stringify({ ...jsonPayload, attachments }), {\n\t\tcontentType: 'application/json',\n\t});\n\n\tfor (const [index, binaryData] of filesData.entries()) {\n\t\tmultiPartBody.append(`files[${index}]`, binaryData.data, {\n\t\t\tcontentType: binaryData.name as string,\n\t\t\tfilename: binaryData.mime as string,\n\t\t});\n\t}\n\n\treturn multiPartBody;\n}\n\nexport function checkAccessToGuild(\n\tnode: INode,\n\tguildId: string,\n\tuserGuilds: IDataObject[],\n\titemIndex = 0,\n) {\n\tif (!userGuilds.some((guild) => guild.id === guildId)) {\n\t\tthrow new NodeOperationError(\n\t\t\tnode,\n\t\t\t`You do not have access to the guild with the id ${guildId}`,\n\t\t\t{\n\t\t\t\titemIndex,\n\t\t\t\tlevel: 'warning',\n\t\t\t},\n\t\t);\n\t}\n}\n\nexport async function checkAccessToChannel(\n\tthis: IExecuteFunctions,\n\tchannelId: string,\n\tuserGuilds: IDataObject[],\n\titemIndex = 0,\n) {\n\tlet guildId = '';\n\n\ttry {\n\t\tconst channel = await discordApiRequest.call(this, 'GET', `/channels/${channelId}`);\n\t\tguildId = channel.guild_id;\n\t} catch (error) {}\n\n\tif (!guildId) {\n\t\tthrow new NodeOperationError(\n\t\t\tthis.getNode(),\n\t\t\t`Could not find server for channel with the id ${channelId}`,\n\t\t\t{\n\t\t\t\titemIndex,\n\t\t\t},\n\t\t);\n\t}\n\n\tcheckAccessToGuild(this.getNode(), guildId, userGuilds, itemIndex);\n}\n\nexport async function setupChannelGetter(this: IExecuteFunctions, userGuilds: IDataObject[]) {\n\tconst isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';\n\n\treturn async (i: number) => {\n\t\tconst channelId = this.getNodeParameter('channelId', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tif (isOAuth2) await checkAccessToChannel.call(this, channelId, userGuilds, i);\n\n\t\treturn channelId;\n\t};\n}\n\nexport async function sendDiscordMessage(\n\tthis: IExecuteFunctions,\n\t{\n\t\tguildId,\n\t\tuserGuilds,\n\t\tisOAuth2,\n\t\tbody,\n\t\titems,\n\t\tfiles = [],\n\t\titemIndex = 0,\n\t}: {\n\t\tguildId: string;\n\t\tuserGuilds: IDataObject[];\n\t\tisOAuth2: boolean;\n\t\tbody: IDataObject;\n\t\titems: INodeExecutionData[];\n\t\tfiles?: IDataObject[];\n\t\titemIndex?: number;\n\t},\n) {\n\tconst sendTo = this.getNodeParameter('sendTo', itemIndex) as string;\n\n\tlet channelId = '';\n\n\tif (sendTo === 'user') {\n\t\tconst userId = this.getNodeParameter('userId', itemIndex, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tif (isOAuth2) {\n\t\t\ttry {\n\t\t\t\tawait discordApiRequest.call(this, 'GET', `/guilds/${guildId}/members/${userId}`);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof NodeApiError && error.httpCode === '404') {\n\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t\t`User with the id ${userId} is not a member of the selected guild`,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthrow new NodeOperationError(this.getNode(), error, {\n\t\t\t\t\titemIndex,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tchannelId = (\n\t\t\t(await discordApiRequest.call(this, 'POST', '/users/@me/channels', {\n\t\t\t\trecipient_id: userId,\n\t\t\t})) as IDataObject\n\t\t).id as string;\n\n\t\tif (!channelId) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t'Could not create a channel to send direct message to',\n\t\t\t\t{ itemIndex },\n\t\t\t);\n\t\t}\n\t}\n\n\tif (sendTo === 'channel') {\n\t\tchannelId = this.getNodeParameter('channelId', itemIndex, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\t}\n\n\tif (isOAuth2 && sendTo !== 'user') {\n\t\tawait checkAccessToChannel.call(this, channelId, userGuilds, itemIndex);\n\t}\n\n\tif (!channelId) {\n\t\tthrow new NodeOperationError(this.getNode(), 'Channel ID is required', {\n\t\t\titemIndex,\n\t\t});\n\t}\n\n\tlet response: IDataObject[] = [];\n\n\tif (files?.length) {\n\t\tconst multiPartBody = await prepareMultiPartForm.call(this, items, files, body, itemIndex);\n\n\t\tresponse = await discordApiMultiPartRequest.call(\n\t\t\tthis,\n\t\t\t'POST',\n\t\t\t`/channels/${channelId}/messages`,\n\t\t\tmultiPartBody,\n\t\t);\n\t} else {\n\t\tresponse = await discordApiRequest.call(this, 'POST', `/channels/${channelId}/messages`, body);\n\t}\n\n\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\tthis.helpers.returnJsonArray(response),\n\t\t{ itemData: { item: itemIndex } },\n\t);\n\n\treturn executionData;\n}\n\nexport function createSendAndWaitMessageBody(context: IExecuteFunctions) {\n\tconst config = getSendAndWaitConfig(context);\n\tlet description = config.message;\n\tif (config.appendAttribution !== false) {\n\t\tconst instanceId = context.getInstanceId();\n\t\tconst attributionText = 'This message was sent automatically with ';\n\t\tconst link = createUtmCampaignLink('n8n-nodes-base.discord', instanceId);\n\t\tdescription = `${config.message}\\n\\n_${attributionText}_[n8n](${link})`;\n\t}\n\n\tconst body = {\n\t\tembeds: [\n\t\t\t{\n\t\t\t\tdescription,\n\t\t\t\tcolor: 5814783,\n\t\t\t},\n\t\t],\n\t\tcomponents: [\n\t\t\t{\n\t\t\t\ttype: 1,\n\t\t\t\tcomponents: config.options.map((option) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 2,\n\t\t\t\t\t\tstyle: 5,\n\t\t\t\t\t\tlabel: option.label,\n\t\t\t\t\t\turl: option.url,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t},\n\t\t],\n\t};\n\n\treturn body;\n}\n"
            },
            {
              "file": "v2/methods/index.ts",
              "content": "export * as listSearch from './listSearch';\nexport * as loadOptions from './loadOptions';\n"
            },
            {
              "file": "v2/methods/listSearch.ts",
              "content": "import {\n\ttype IDataObject,\n\ttype ILoadOptionsFunctions,\n\ttype INodeListSearchResult,\n} from 'n8n-workflow';\n\nimport { checkAccessToGuild } from '../helpers/utils';\nimport { discordApiRequest } from '../transport';\n\nasync function getGuildId(this: ILoadOptionsFunctions) {\n\tconst guildId = this.getNodeParameter('guildId', undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', '') === 'oAuth2';\n\n\tif (isOAuth2) {\n\t\tconst userGuilds = (await discordApiRequest.call(\n\t\t\tthis,\n\t\t\t'GET',\n\t\t\t'/users/@me/guilds',\n\t\t)) as IDataObject[];\n\n\t\tcheckAccessToGuild(this.getNode(), guildId, userGuilds);\n\t}\n\n\treturn guildId;\n}\n\nasync function checkBotAccessToGuild(this: ILoadOptionsFunctions, guildId: string, botId: string) {\n\ttry {\n\t\tconst members: Array<{ user: { id: string } }> = await discordApiRequest.call(\n\t\t\tthis,\n\t\t\t'GET',\n\t\t\t`/guilds/${guildId}/members`,\n\t\t\tundefined,\n\t\t\t{ limit: 1000 },\n\t\t);\n\n\t\treturn members.some((member) => member.user.id === botId);\n\t} catch (error) {}\n\n\treturn false;\n}\n\nexport async function guildSearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst response = (await discordApiRequest.call(\n\t\tthis,\n\t\t'GET',\n\t\t'/users/@me/guilds',\n\t)) as IDataObject[];\n\n\tlet guilds: IDataObject[] = [];\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';\n\n\tif (isOAuth2) {\n\t\tconst botId = (await discordApiRequest.call(this, 'GET', '/users/@me')).id as string;\n\n\t\tfor (const guild of response) {\n\t\t\tif (!(await checkBotAccessToGuild.call(this, guild.id as string, botId))) continue;\n\t\t\tguilds.push(guild);\n\t\t}\n\t} else {\n\t\tguilds = response;\n\t}\n\n\treturn {\n\t\tresults: guilds.map((guild) => ({\n\t\t\tname: guild.name as string,\n\t\t\tvalue: guild.id as string,\n\t\t\turl: `https://discord.com/channels/${guild.id}`,\n\t\t})),\n\t};\n}\n\nexport async function channelSearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst guildId = await getGuildId.call(this);\n\tconst response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/channels`);\n\n\treturn {\n\t\tresults: (response as IDataObject[])\n\t\t\t.filter((cannel) => cannel.type !== 4) // Filter out categories\n\t\t\t.map((channel) => ({\n\t\t\t\tname: channel.name as string,\n\t\t\t\tvalue: channel.id as string,\n\t\t\t\turl: `https://discord.com/channels/${guildId}/${channel.id}`,\n\t\t\t})),\n\t};\n}\n\nexport async function textChannelSearch(\n\tthis: ILoadOptionsFunctions,\n): Promise<INodeListSearchResult> {\n\tconst guildId = await getGuildId.call(this);\n\n\tconst response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/channels`);\n\n\treturn {\n\t\tresults: (response as IDataObject[])\n\t\t\t.filter((cannel) => ![2, 4].includes(cannel.type as number)) // Only text channels\n\t\t\t.map((channel) => ({\n\t\t\t\tname: channel.name as string,\n\t\t\t\tvalue: channel.id as string,\n\t\t\t\turl: `https://discord.com/channels/${guildId}/${channel.id}`,\n\t\t\t})),\n\t};\n}\n\nexport async function categorySearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst guildId = await getGuildId.call(this);\n\n\tconst response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/channels`);\n\n\treturn {\n\t\tresults: (response as IDataObject[])\n\t\t\t.filter((cannel) => cannel.type === 4) // Return only categories\n\t\t\t.map((channel) => ({\n\t\t\t\tname: channel.name as string,\n\t\t\t\tvalue: channel.id as string,\n\t\t\t\turl: `https://discord.com/channels/${guildId}/${channel.id}`,\n\t\t\t})),\n\t};\n}\n\nexport async function userSearch(\n\tthis: ILoadOptionsFunctions,\n\t_filter?: string,\n\tpaginationToken?: string,\n): Promise<INodeListSearchResult> {\n\tconst guildId = await getGuildId.call(this);\n\n\tconst limit = 100;\n\tconst qs = { limit, after: paginationToken };\n\n\tconst response = await discordApiRequest.call(\n\t\tthis,\n\t\t'GET',\n\t\t`/guilds/${guildId}/members`,\n\t\tundefined,\n\t\tqs,\n\t);\n\n\tif (response.length === 0) {\n\t\treturn {\n\t\t\tresults: [],\n\t\t\tpaginationToken: undefined,\n\t\t};\n\t}\n\n\tlet lastUserId;\n\n\t//less then limit means that there are no more users to return, so leave lastUserId undefined\n\tif (!(response.length < limit)) {\n\t\tlastUserId = response[response.length - 1].user.id as string;\n\t}\n\n\treturn {\n\t\tresults: (response as Array<{ user: IDataObject }>).map(({ user }) => ({\n\t\t\tname: user.username as string,\n\t\t\tvalue: user.id as string,\n\t\t})),\n\t\tpaginationToken: lastUserId,\n\t};\n}\n"
            },
            {
              "file": "v2/methods/loadOptions.ts",
              "content": "import type { IDataObject, ILoadOptionsFunctions, INodePropertyOptions } from 'n8n-workflow';\n\nimport { checkAccessToGuild } from '../helpers/utils';\nimport { discordApiRequest } from '../transport';\n\nexport async function getRoles(this: ILoadOptionsFunctions): Promise<INodePropertyOptions[]> {\n\tconst guildId = this.getNodeParameter('guildId', undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', '') === 'oAuth2';\n\n\tif (isOAuth2) {\n\t\tconst userGuilds = (await discordApiRequest.call(\n\t\t\tthis,\n\t\t\t'GET',\n\t\t\t'/users/@me/guilds',\n\t\t)) as IDataObject[];\n\n\t\tcheckAccessToGuild(this.getNode(), guildId, userGuilds);\n\t}\n\n\tlet response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/roles`);\n\n\tconst operations = this.getNodeParameter('operation') as string;\n\n\tif (operations === 'roleRemove') {\n\t\tconst userId = this.getNodeParameter('userId', undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst userRoles = ((\n\t\t\tawait discordApiRequest.call(this, 'GET', `/guilds/${guildId}/members/${userId}`)\n\t\t).roles || []) as string[];\n\n\t\tresponse = response.filter((role: IDataObject) => {\n\t\t\treturn userRoles.includes(role.id as string);\n\t\t});\n\t}\n\n\treturn response\n\t\t.filter((role: IDataObject) => role.name !== '@everyone' && !role.managed)\n\t\t.map((role: IDataObject) => ({\n\t\t\tname: role.name as string,\n\t\t\tvalue: role.id as string,\n\t\t}));\n}\n"
            },
            {
              "file": "v2/transport/discord.api.ts",
              "content": "import type FormData from 'form-data';\nimport type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tIExecuteSingleFunctions,\n\tIHookFunctions,\n\tIHttpRequestMethods,\n\tILoadOptionsFunctions,\n\tIRequestOptions,\n} from 'n8n-workflow';\nimport { sleep, NodeApiError, jsonParse } from 'n8n-workflow';\n\nimport { getCredentialsType, requestApi } from './helpers';\n\nexport async function discordApiRequest(\n\tthis: IHookFunctions | IExecuteFunctions | IExecuteSingleFunctions | ILoadOptionsFunctions,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tbody?: IDataObject,\n\tqs?: IDataObject,\n) {\n\tconst authentication = this.getNodeParameter('authentication', 0, 'webhook') as string;\n\tconst headers: IDataObject = {};\n\n\tconst credentialType = getCredentialsType(authentication);\n\n\tconst options: IRequestOptions = {\n\t\theaders,\n\t\tmethod,\n\t\tqs,\n\t\tbody,\n\t\turl: `https://discord.com/api/v10${endpoint}`,\n\t\tjson: true,\n\t};\n\n\tif (credentialType === 'discordWebhookApi') {\n\t\tconst credentials = await this.getCredentials('discordWebhookApi');\n\t\toptions.url = credentials.webhookUri as string;\n\t}\n\n\ttry {\n\t\tconst response = await requestApi.call(this, options, credentialType, endpoint);\n\n\t\tconst resetAfter = Number(response.headers['x-ratelimit-reset-after']);\n\t\tconst remaining = Number(response.headers['x-ratelimit-remaining']);\n\n\t\tif (remaining === 0) {\n\t\t\tawait sleep(resetAfter);\n\t\t} else {\n\t\t\tawait sleep(20); //prevent exceeding global rate limit of 50 requests per second\n\t\t}\n\n\t\treturn response.body || { success: true };\n\t} catch (error) {\n\t\tthrow new NodeApiError(this.getNode(), error);\n\t}\n}\n\nexport async function discordApiMultiPartRequest(\n\tthis: IHookFunctions | IExecuteFunctions | IExecuteSingleFunctions | ILoadOptionsFunctions,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tformData: FormData,\n) {\n\tconst headers: IDataObject = {\n\t\t'content-type': 'multipart/form-data; charset=utf-8',\n\t};\n\tconst authentication = this.getNodeParameter('authentication', 0, 'webhook') as string;\n\n\tconst credentialType = getCredentialsType(authentication);\n\n\tconst options: IRequestOptions = {\n\t\theaders,\n\t\tmethod,\n\t\tformData,\n\t\turl: `https://discord.com/api/v10${endpoint}`,\n\t};\n\n\tif (credentialType === 'discordWebhookApi') {\n\t\tconst credentials = await this.getCredentials('discordWebhookApi');\n\t\toptions.url = credentials.webhookUri as string;\n\t}\n\n\ttry {\n\t\tconst response = await requestApi.call(this, options, credentialType, endpoint);\n\n\t\tconst resetAfter = Number(response.headers['x-ratelimit-reset-after']);\n\t\tconst remaining = Number(response.headers['x-ratelimit-remaining']);\n\n\t\tif (remaining === 0) {\n\t\t\tawait sleep(resetAfter);\n\t\t} else {\n\t\t\tawait sleep(20); //prevent exceeding global rate limit of 50 requests per second\n\t\t}\n\n\t\treturn jsonParse<IDataObject[]>(response.body);\n\t} catch (error) {\n\t\tthrow new NodeApiError(this.getNode(), error);\n\t}\n}\n"
            },
            {
              "file": "v2/transport/helpers.ts",
              "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tIExecuteSingleFunctions,\n\tIHookFunctions,\n\tILoadOptionsFunctions,\n\tIRequestOptions,\n} from 'n8n-workflow';\n\nexport const getCredentialsType = (authentication: string) => {\n\tlet credentialType = '';\n\tswitch (authentication) {\n\t\tcase 'botToken':\n\t\t\tcredentialType = 'discordBotApi';\n\t\t\tbreak;\n\t\tcase 'oAuth2':\n\t\t\tcredentialType = 'discordOAuth2Api';\n\t\t\tbreak;\n\t\tcase 'webhook':\n\t\t\tcredentialType = 'discordWebhookApi';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcredentialType = 'discordBotApi';\n\t}\n\treturn credentialType;\n};\n\nexport async function requestApi(\n\tthis: IHookFunctions | IExecuteFunctions | IExecuteSingleFunctions | ILoadOptionsFunctions,\n\toptions: IRequestOptions,\n\tcredentialType: string,\n\tendpoint: string,\n) {\n\tlet response;\n\tif (credentialType === 'discordOAuth2Api' && endpoint !== '/users/@me/guilds') {\n\t\tconst credentials = await this.getCredentials('discordOAuth2Api');\n\t\t(options.headers as IDataObject).Authorization = `Bot ${credentials.botToken}`;\n\t\tresponse = await this.helpers.request({ ...options, resolveWithFullResponse: true });\n\t} else {\n\t\tresponse = await this.helpers.requestWithAuthentication.call(this, credentialType, {\n\t\t\t...options,\n\t\t\tresolveWithFullResponse: true,\n\t\t});\n\t}\n\treturn response;\n}\n"
            },
            {
              "file": "v2/transport/index.ts",
              "content": "export * from './discord.api';\nexport * from './helpers';\n"
            }
          ]
        },
        "metadata": {
          "fetch_time": "2026-01-06T04:37:52.645104+00:00",
          "source_type": "TYPE1",
          "source_path": "input_sources/discord",
          "file_count": 50,
          "content_hash": "a31752750c0ad872"
        },
        "artifacts": {
          "raw_source": "artifacts/node-discord-v2test3/raw_source.txt",
          "parsed_source": "artifacts/node-discord-v2test3/parsed_source.json",
          "source_bundle": "artifacts/node-discord-v2test3/source_bundle"
        }
      },
      "artifacts_produced": [
        "artifacts/node-discord-v2test3/raw_source.txt",
        "artifacts/node-discord-v2test3/parsed_source.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "infer-schema",
      "skill_name": "schema-infer",
      "status": "completed",
      "started_at": "2026-01-06T04:37:52.656013",
      "completed_at": "2026-01-06T04:37:53.247994",
      "duration_ms": 591,
      "outputs": {
        "inferred_schema": {
          "type": "node",
          "version": 1,
          "description": {
            "displayName": "Node",
            "name": "node",
            "inputs": [
              {
                "name": "main",
                "type": "main"
              }
            ],
            "outputs": [
              {
                "name": "main",
                "type": "main"
              }
            ]
          },
          "properties": {
            "parameters": [
              {
                "name": "operation",
                "type": "OPTIONS",
                "display_name": "Operation",
                "options": [
                  {
                    "name": "Send a Message",
                    "value": "sendLegacy",
                    "description": "Send a message to a channel using the webhook"
                  },
                  {
                    "name": "parseDiscordError",
                    "value": "parseDiscordError",
                    "description": "Operation: parseDiscordError"
                  },
                  {
                    "name": "prepareErrorData",
                    "value": "prepareErrorData",
                    "description": "Operation: prepareErrorData"
                  },
                  {
                    "name": "prepareOptions",
                    "value": "prepareOptions",
                    "description": "Operation: prepareOptions"
                  },
                  {
                    "name": "prepareEmbeds",
                    "value": "prepareEmbeds",
                    "description": "Operation: prepareEmbeds"
                  },
                  {
                    "name": "prepareMultiPartForm",
                    "value": "prepareMultiPartForm",
                    "description": "Operation: prepareMultiPartForm"
                  },
                  {
                    "name": "checkAccessToGuild",
                    "value": "checkAccessToGuild",
                    "description": "Operation: checkAccessToGuild"
                  },
                  {
                    "name": "checkAccessToChannel",
                    "value": "checkAccessToChannel",
                    "description": "Operation: checkAccessToChannel"
                  },
                  {
                    "name": "setupChannelGetter",
                    "value": "setupChannelGetter",
                    "description": "Operation: setupChannelGetter"
                  },
                  {
                    "name": "sendDiscordMessage",
                    "value": "sendDiscordMessage",
                    "description": "Operation: sendDiscordMessage"
                  },
                  {
                    "name": "createSendAndWaitMessageBody",
                    "value": "createSendAndWaitMessageBody",
                    "description": "Operation: createSendAndWaitMessageBody"
                  },
                  {
                    "name": "getGuildId",
                    "value": "getGuildId",
                    "description": "Operation: getGuildId"
                  },
                  {
                    "name": "checkBotAccessToGuild",
                    "value": "checkBotAccessToGuild",
                    "description": "Operation: checkBotAccessToGuild"
                  },
                  {
                    "name": "guildSearch",
                    "value": "guildSearch",
                    "description": "Operation: guildSearch"
                  },
                  {
                    "name": "channelSearch",
                    "value": "channelSearch",
                    "description": "Operation: channelSearch"
                  },
                  {
                    "name": "textChannelSearch",
                    "value": "textChannelSearch",
                    "description": "Operation: textChannelSearch"
                  },
                  {
                    "name": "categorySearch",
                    "value": "categorySearch",
                    "description": "Operation: categorySearch"
                  },
                  {
                    "name": "userSearch",
                    "value": "userSearch",
                    "description": "Operation: userSearch"
                  },
                  {
                    "name": "getRoles",
                    "value": "getRoles",
                    "description": "Operation: getRoles"
                  },
                  {
                    "name": "discordApiRequest",
                    "value": "discordApiRequest",
                    "description": "Operation: discordApiRequest"
                  },
                  {
                    "name": "discordApiMultiPartRequest",
                    "value": "discordApiMultiPartRequest",
                    "description": "Operation: discordApiMultiPartRequest"
                  },
                  {
                    "name": "requestApi",
                    "value": "requestApi",
                    "description": "Operation: requestApi"
                  }
                ],
                "default": "sendLegacy",
                "description": "Operation to perform"
              },
              {
                "name": "webhookUri",
                "display_name": "Webhook URL",
                "type": "STRING",
                "default": "",
                "required": true
              },
              {
                "name": "text",
                "display_name": "Content",
                "type": "STRING",
                "default": ""
              },
              {
                "name": "options",
                "display_name": "Additional Fields",
                "type": "COLLECTION",
                "default": "{",
                "description": "Whether this message be sent as a Text To Speech message"
              },
              {
                "name": "allowedMentions",
                "display_name": "Allowed Mentions",
                "type": "JSON",
                "default": ""
              },
              {
                "name": "attachments",
                "display_name": "Attachments",
                "type": "JSON",
                "default": ""
              },
              {
                "name": "avatarUrl",
                "display_name": "Avatar URL",
                "type": "STRING",
                "default": ""
              },
              {
                "name": "components",
                "display_name": "Components",
                "type": "JSON",
                "default": ""
              },
              {
                "name": "embeds",
                "display_name": "Embeds",
                "type": "JSON",
                "default": ""
              },
              {
                "name": "flags",
                "display_name": "Flags",
                "type": "NUMBER",
                "default": ""
              },
              {
                "name": "payloadJson",
                "display_name": "JSON Payload",
                "type": "JSON",
                "default": ""
              },
              {
                "name": "username",
                "display_name": "Username",
                "type": "STRING",
                "default": ""
              },
              {
                "name": "tts",
                "display_name": "TTS",
                "type": "BOOLEAN",
                "default": false,
                "description": "Whether this message be sent as a Text To Speech message"
              },
              {
                "name": "authentication",
                "display_name": "Connection Type",
                "type": "OPTIONS",
                "default": "botToken",
                "description": "Manage messages, channels, and members on a server",
                "options": [
                  {
                    "name": "Bot Token",
                    "value": "botToken"
                  },
                  {
                    "name": "OAuth2",
                    "value": "oAuth2"
                  },
                  {
                    "name": "Webhook",
                    "value": "webhook"
                  }
                ]
              },
              {
                "name": "OAuth2",
                "display_name": "Bot Token",
                "type": "OPTIONS",
                "description": "Manage messages, channels, and members on a server"
              }
            ],
            "credentials": [
              "oauth2"
            ]
          },
          "operations": [
            {
              "name": "sendLegacy",
              "display_name": "Send a Message",
              "description": "Send a message to a channel using the webhook"
            },
            {
              "name": "parseDiscordError",
              "description": "Operation: parseDiscordError"
            },
            {
              "name": "prepareErrorData",
              "description": "Operation: prepareErrorData"
            },
            {
              "name": "prepareOptions",
              "description": "Operation: prepareOptions"
            },
            {
              "name": "prepareEmbeds",
              "description": "Operation: prepareEmbeds"
            },
            {
              "name": "prepareMultiPartForm",
              "description": "Operation: prepareMultiPartForm"
            },
            {
              "name": "checkAccessToGuild",
              "description": "Operation: checkAccessToGuild"
            },
            {
              "name": "checkAccessToChannel",
              "description": "Operation: checkAccessToChannel"
            },
            {
              "name": "setupChannelGetter",
              "description": "Operation: setupChannelGetter"
            },
            {
              "name": "sendDiscordMessage",
              "description": "Operation: sendDiscordMessage"
            },
            {
              "name": "createSendAndWaitMessageBody",
              "description": "Operation: createSendAndWaitMessageBody"
            },
            {
              "name": "getGuildId",
              "description": "Operation: getGuildId"
            },
            {
              "name": "checkBotAccessToGuild",
              "description": "Operation: checkBotAccessToGuild"
            },
            {
              "name": "guildSearch",
              "description": "Operation: guildSearch"
            },
            {
              "name": "channelSearch",
              "description": "Operation: channelSearch"
            },
            {
              "name": "textChannelSearch",
              "description": "Operation: textChannelSearch"
            },
            {
              "name": "categorySearch",
              "description": "Operation: categorySearch"
            },
            {
              "name": "userSearch",
              "description": "Operation: userSearch"
            },
            {
              "name": "getRoles",
              "description": "Operation: getRoles"
            },
            {
              "name": "discordApiRequest",
              "description": "Operation: discordApiRequest"
            },
            {
              "name": "discordApiMultiPartRequest",
              "description": "Operation: discordApiMultiPartRequest"
            },
            {
              "name": "requestApi",
              "description": "Operation: requestApi"
            }
          ],
          "resources": [],
          "credentials": [
            "oauth2"
          ]
        },
        "trace_map": {
          "correlation_id": "node-discord-v2test3",
          "node_type": "node",
          "trace_entries": [
            {
              "field_path": "operations[6].name",
              "source": "SOURCE_CODE",
              "evidence": "n8n operation 'sendLegacy' (display: 'Send a Message') in v2/actions/webhook/index.ts",
              "confidence": "high",
              "source_file": "v2/actions/webhook/index.ts",
              "line_range": "L9",
              "excerpt_hash": "fd3cec6eea12"
            },
            {
              "field_path": "operations[1].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'parseDiscordError' defined in v2/helpers/utils.ts",
              "confidence": "high",
              "source_file": "v2/helpers/utils.ts",
              "line_range": "L31",
              "excerpt_hash": "42372fe2e01d"
            },
            {
              "field_path": "operations[2].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'prepareErrorData' defined in v2/helpers/utils.ts",
              "confidence": "high",
              "source_file": "v2/helpers/utils.ts",
              "line_range": "L85",
              "excerpt_hash": "b6633c8b90ae"
            },
            {
              "field_path": "operations[3].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'prepareOptions' defined in v2/helpers/utils.ts",
              "confidence": "high",
              "source_file": "v2/helpers/utils.ts",
              "line_range": "L98",
              "excerpt_hash": "da613906b237"
            },
            {
              "field_path": "operations[4].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'prepareEmbeds' defined in v2/helpers/utils.ts",
              "confidence": "high",
              "source_file": "v2/helpers/utils.ts",
              "line_range": "L119",
              "excerpt_hash": "e5f387c655c2"
            },
            {
              "field_path": "operations[5].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'prepareMultiPartForm' defined in v2/helpers/utils.ts",
              "confidence": "high",
              "source_file": "v2/helpers/utils.ts",
              "line_range": "L174",
              "excerpt_hash": "996c807696ed"
            },
            {
              "field_path": "operations[6].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'checkAccessToGuild' defined in v2/helpers/utils.ts",
              "confidence": "high",
              "source_file": "v2/helpers/utils.ts",
              "line_range": "L232",
              "excerpt_hash": "9701125899e2"
            },
            {
              "field_path": "operations[7].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'checkAccessToChannel' defined in v2/helpers/utils.ts",
              "confidence": "high",
              "source_file": "v2/helpers/utils.ts",
              "line_range": "L250",
              "excerpt_hash": "5e594774dff5"
            },
            {
              "field_path": "operations[8].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'setupChannelGetter' defined in v2/helpers/utils.ts",
              "confidence": "high",
              "source_file": "v2/helpers/utils.ts",
              "line_range": "L276",
              "excerpt_hash": "c9b498a52d11"
            },
            {
              "field_path": "operations[9].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'sendDiscordMessage' defined in v2/helpers/utils.ts",
              "confidence": "high",
              "source_file": "v2/helpers/utils.ts",
              "line_range": "L290",
              "excerpt_hash": "1f5515c2b7c5"
            },
            {
              "field_path": "operations[10].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'createSendAndWaitMessageBody' defined in v2/helpers/utils.ts",
              "confidence": "high",
              "source_file": "v2/helpers/utils.ts",
              "line_range": "L393",
              "excerpt_hash": "331ea5ba48ff"
            },
            {
              "field_path": "operations[11].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'getGuildId' defined in v2/methods/listSearch.ts",
              "confidence": "high",
              "source_file": "v2/methods/listSearch.ts",
              "line_range": "L10",
              "excerpt_hash": "f2f58ca622df"
            },
            {
              "field_path": "operations[12].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'checkBotAccessToGuild' defined in v2/methods/listSearch.ts",
              "confidence": "high",
              "source_file": "v2/methods/listSearch.ts",
              "line_range": "L30",
              "excerpt_hash": "f0669cf1ab4d"
            },
            {
              "field_path": "operations[13].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'guildSearch' defined in v2/methods/listSearch.ts",
              "confidence": "high",
              "source_file": "v2/methods/listSearch.ts",
              "line_range": "L46",
              "excerpt_hash": "b04bf300ebbf"
            },
            {
              "field_path": "operations[14].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'channelSearch' defined in v2/methods/listSearch.ts",
              "confidence": "high",
              "source_file": "v2/methods/listSearch.ts",
              "line_range": "L77",
              "excerpt_hash": "819f0a046606"
            },
            {
              "field_path": "operations[15].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'textChannelSearch' defined in v2/methods/listSearch.ts",
              "confidence": "high",
              "source_file": "v2/methods/listSearch.ts",
              "line_range": "L92",
              "excerpt_hash": "ac9743386f20"
            },
            {
              "field_path": "operations[16].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'categorySearch' defined in v2/methods/listSearch.ts",
              "confidence": "high",
              "source_file": "v2/methods/listSearch.ts",
              "line_range": "L110",
              "excerpt_hash": "4106e9133377"
            },
            {
              "field_path": "operations[17].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'userSearch' defined in v2/methods/listSearch.ts",
              "confidence": "high",
              "source_file": "v2/methods/listSearch.ts",
              "line_range": "L126",
              "excerpt_hash": "9a26f1450f53"
            },
            {
              "field_path": "operations[18].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'getRoles' defined in v2/methods/loadOptions.ts",
              "confidence": "high",
              "source_file": "v2/methods/loadOptions.ts",
              "line_range": "L6",
              "excerpt_hash": "c278e41447fc"
            },
            {
              "field_path": "operations[19].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'discordApiRequest' defined in v2/transport/discord.api.ts",
              "confidence": "high",
              "source_file": "v2/transport/discord.api.ts",
              "line_range": "L15",
              "excerpt_hash": "42374a6a2976"
            },
            {
              "field_path": "operations[20].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'discordApiMultiPartRequest' defined in v2/transport/discord.api.ts",
              "confidence": "high",
              "source_file": "v2/transport/discord.api.ts",
              "line_range": "L59",
              "excerpt_hash": "6517fe6ed0be"
            },
            {
              "field_path": "operations[21].name",
              "source": "SOURCE_CODE",
              "evidence": "Function 'requestApi' defined in v2/transport/helpers.ts",
              "confidence": "high",
              "source_file": "v2/transport/helpers.ts",
              "line_range": "L28",
              "excerpt_hash": "2e2a06acc0d6"
            },
            {
              "field_path": "credentials[0]",
              "source": "SOURCE_CODE",
              "evidence": "Auth pattern 'oauth' found in source",
              "confidence": "medium"
            }
          ],
          "generated_at": "2026-01-06T04:37:52.855502",
          "skill_version": "1.0.0",
          "_hybrid_metadata": {
            "source_type": "TYPE1",
            "extraction_confidence": 0.7374999999999999,
            "advisor_used": false,
            "assumption_ratio": 0.0,
            "deterministic_operations": 23,
            "assumption_operations": 0
          }
        },
        "schema": {
          "type": "node",
          "version": 1,
          "description": {
            "displayName": "Node",
            "name": "node",
            "inputs": [
              {
                "name": "main",
                "type": "main"
              }
            ],
            "outputs": [
              {
                "name": "main",
                "type": "main"
              }
            ]
          },
          "properties": {
            "parameters": [
              {
                "name": "operation",
                "type": "OPTIONS",
                "display_name": "Operation",
                "options": [
                  {
                    "name": "Send a Message",
                    "value": "sendLegacy",
                    "description": "Send a message to a channel using the webhook"
                  },
                  {
                    "name": "parseDiscordError",
                    "value": "parseDiscordError",
                    "description": "Operation: parseDiscordError"
                  },
                  {
                    "name": "prepareErrorData",
                    "value": "prepareErrorData",
                    "description": "Operation: prepareErrorData"
                  },
                  {
                    "name": "prepareOptions",
                    "value": "prepareOptions",
                    "description": "Operation: prepareOptions"
                  },
                  {
                    "name": "prepareEmbeds",
                    "value": "prepareEmbeds",
                    "description": "Operation: prepareEmbeds"
                  },
                  {
                    "name": "prepareMultiPartForm",
                    "value": "prepareMultiPartForm",
                    "description": "Operation: prepareMultiPartForm"
                  },
                  {
                    "name": "checkAccessToGuild",
                    "value": "checkAccessToGuild",
                    "description": "Operation: checkAccessToGuild"
                  },
                  {
                    "name": "checkAccessToChannel",
                    "value": "checkAccessToChannel",
                    "description": "Operation: checkAccessToChannel"
                  },
                  {
                    "name": "setupChannelGetter",
                    "value": "setupChannelGetter",
                    "description": "Operation: setupChannelGetter"
                  },
                  {
                    "name": "sendDiscordMessage",
                    "value": "sendDiscordMessage",
                    "description": "Operation: sendDiscordMessage"
                  },
                  {
                    "name": "createSendAndWaitMessageBody",
                    "value": "createSendAndWaitMessageBody",
                    "description": "Operation: createSendAndWaitMessageBody"
                  },
                  {
                    "name": "getGuildId",
                    "value": "getGuildId",
                    "description": "Operation: getGuildId"
                  },
                  {
                    "name": "checkBotAccessToGuild",
                    "value": "checkBotAccessToGuild",
                    "description": "Operation: checkBotAccessToGuild"
                  },
                  {
                    "name": "guildSearch",
                    "value": "guildSearch",
                    "description": "Operation: guildSearch"
                  },
                  {
                    "name": "channelSearch",
                    "value": "channelSearch",
                    "description": "Operation: channelSearch"
                  },
                  {
                    "name": "textChannelSearch",
                    "value": "textChannelSearch",
                    "description": "Operation: textChannelSearch"
                  },
                  {
                    "name": "categorySearch",
                    "value": "categorySearch",
                    "description": "Operation: categorySearch"
                  },
                  {
                    "name": "userSearch",
                    "value": "userSearch",
                    "description": "Operation: userSearch"
                  },
                  {
                    "name": "getRoles",
                    "value": "getRoles",
                    "description": "Operation: getRoles"
                  },
                  {
                    "name": "discordApiRequest",
                    "value": "discordApiRequest",
                    "description": "Operation: discordApiRequest"
                  },
                  {
                    "name": "discordApiMultiPartRequest",
                    "value": "discordApiMultiPartRequest",
                    "description": "Operation: discordApiMultiPartRequest"
                  },
                  {
                    "name": "requestApi",
                    "value": "requestApi",
                    "description": "Operation: requestApi"
                  }
                ],
                "default": "sendLegacy",
                "description": "Operation to perform"
              },
              {
                "name": "webhookUri",
                "display_name": "Webhook URL",
                "type": "STRING",
                "default": "",
                "required": true
              },
              {
                "name": "text",
                "display_name": "Content",
                "type": "STRING",
                "default": ""
              },
              {
                "name": "options",
                "display_name": "Additional Fields",
                "type": "COLLECTION",
                "default": "{",
                "description": "Whether this message be sent as a Text To Speech message"
              },
              {
                "name": "allowedMentions",
                "display_name": "Allowed Mentions",
                "type": "JSON",
                "default": ""
              },
              {
                "name": "attachments",
                "display_name": "Attachments",
                "type": "JSON",
                "default": ""
              },
              {
                "name": "avatarUrl",
                "display_name": "Avatar URL",
                "type": "STRING",
                "default": ""
              },
              {
                "name": "components",
                "display_name": "Components",
                "type": "JSON",
                "default": ""
              },
              {
                "name": "embeds",
                "display_name": "Embeds",
                "type": "JSON",
                "default": ""
              },
              {
                "name": "flags",
                "display_name": "Flags",
                "type": "NUMBER",
                "default": ""
              },
              {
                "name": "payloadJson",
                "display_name": "JSON Payload",
                "type": "JSON",
                "default": ""
              },
              {
                "name": "username",
                "display_name": "Username",
                "type": "STRING",
                "default": ""
              },
              {
                "name": "tts",
                "display_name": "TTS",
                "type": "BOOLEAN",
                "default": false,
                "description": "Whether this message be sent as a Text To Speech message"
              },
              {
                "name": "authentication",
                "display_name": "Connection Type",
                "type": "OPTIONS",
                "default": "botToken",
                "description": "Manage messages, channels, and members on a server",
                "options": [
                  {
                    "name": "Bot Token",
                    "value": "botToken"
                  },
                  {
                    "name": "OAuth2",
                    "value": "oAuth2"
                  },
                  {
                    "name": "Webhook",
                    "value": "webhook"
                  }
                ]
              },
              {
                "name": "OAuth2",
                "display_name": "Bot Token",
                "type": "OPTIONS",
                "description": "Manage messages, channels, and members on a server"
              }
            ],
            "credentials": [
              "oauth2"
            ]
          },
          "operations": [
            {
              "name": "sendLegacy",
              "display_name": "Send a Message",
              "description": "Send a message to a channel using the webhook"
            },
            {
              "name": "parseDiscordError",
              "description": "Operation: parseDiscordError"
            },
            {
              "name": "prepareErrorData",
              "description": "Operation: prepareErrorData"
            },
            {
              "name": "prepareOptions",
              "description": "Operation: prepareOptions"
            },
            {
              "name": "prepareEmbeds",
              "description": "Operation: prepareEmbeds"
            },
            {
              "name": "prepareMultiPartForm",
              "description": "Operation: prepareMultiPartForm"
            },
            {
              "name": "checkAccessToGuild",
              "description": "Operation: checkAccessToGuild"
            },
            {
              "name": "checkAccessToChannel",
              "description": "Operation: checkAccessToChannel"
            },
            {
              "name": "setupChannelGetter",
              "description": "Operation: setupChannelGetter"
            },
            {
              "name": "sendDiscordMessage",
              "description": "Operation: sendDiscordMessage"
            },
            {
              "name": "createSendAndWaitMessageBody",
              "description": "Operation: createSendAndWaitMessageBody"
            },
            {
              "name": "getGuildId",
              "description": "Operation: getGuildId"
            },
            {
              "name": "checkBotAccessToGuild",
              "description": "Operation: checkBotAccessToGuild"
            },
            {
              "name": "guildSearch",
              "description": "Operation: guildSearch"
            },
            {
              "name": "channelSearch",
              "description": "Operation: channelSearch"
            },
            {
              "name": "textChannelSearch",
              "description": "Operation: textChannelSearch"
            },
            {
              "name": "categorySearch",
              "description": "Operation: categorySearch"
            },
            {
              "name": "userSearch",
              "description": "Operation: userSearch"
            },
            {
              "name": "getRoles",
              "description": "Operation: getRoles"
            },
            {
              "name": "discordApiRequest",
              "description": "Operation: discordApiRequest"
            },
            {
              "name": "discordApiMultiPartRequest",
              "description": "Operation: discordApiMultiPartRequest"
            },
            {
              "name": "requestApi",
              "description": "Operation: requestApi"
            }
          ],
          "resources": [],
          "credentials": [
            "oauth2"
          ]
        },
        "assumptions": [],
        "artifacts_written": [
          "artifacts/node-discord-v2test3/schema/inferred_schema.json",
          "artifacts/node-discord-v2test3/schema/trace_map.json"
        ],
        "extraction_confidence": 0.7374999999999999,
        "advisor_used": false
      },
      "artifacts_produced": [
        "artifacts/node-discord-v2test3/inferred_schema.json",
        "artifacts/node-discord-v2test3/trace_map.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "scaffold",
      "skill_name": "node-scaffold",
      "status": "blocked",
      "started_at": "2026-01-06T04:37:53.248021",
      "completed_at": "2026-01-06T04:37:53.266364",
      "duration_ms": 18,
      "outputs": {
        "files_created": [
          "artifacts/node-discord-v2test3/generated_node/discord.py",
          "artifacts/node-discord-v2test3/generated_node/__init__.py"
        ],
        "allowlist": {
          "node_name": "discord",
          "patterns": [
            "nodes/discord*",
            "nodes/discord*",
            "tests/*discord*",
            "tests/*discord*",
            "credentials/*discord*",
            "credentials/*discord*"
          ]
        }
      },
      "artifacts_produced": [
        "artifacts/node-discord-v2test3/scaffold_manifest.json",
        "artifacts/node-discord-v2test3/allowlist.json"
      ],
      "errors": [
        "Artifact scope guard failed: Artifact scope violation: 2 file(s) outside artifacts/",
        "Details: {'violations': [{'file': 'artifacts/node-discord-v2test3/generated_node/discord.py', 'resolved': '/home/toni/agent-skills/artifacts/node-discord-v2test3/generated_node/discord.py', 'allowed_prefix': 'artifacts/node-discord-v2test3'}, {'file': 'artifacts/node-discord-v2test3/generated_node/__init__.py', 'resolved': '/home/toni/agent-skills/artifacts/node-discord-v2test3/generated_node/__init__.py', 'allowed_prefix': 'artifacts/node-discord-v2test3'}], 'fs_scope': 'artifacts', 'remediation': 'Skills with fs_scope=artifacts can only write to artifacts/{correlation_id}/. Use fs_scope=target_repo in SKILL.md to enable repo writes.'}"
      ],
      "skipped_reason": null
    },
    {
      "step_name": "convert",
      "skill_name": "code-convert",
      "status": "completed",
      "started_at": "2026-01-06T04:37:53.266406",
      "completed_at": "2026-01-06T04:37:53.292592",
      "duration_ms": 26,
      "outputs": {
        "files_modified": [
          "nodes/discord.py"
        ],
        "all_target_files": [
          "nodes/discord.py",
          "nodes/__init__.py"
        ],
        "artifact_paths": [
          "artifacts/node-discord-v2test3/converted/discord.py",
          "artifacts/node-discord-v2test3/converted/__init__.py"
        ],
        "conversion_notes": [
          "Found main node class for Discord",
          "Found 0 operation handlers",
          "Using 15 parameters from inferred schema"
        ],
        "generated_code": {
          "discord.py": "#!/usr/bin/env python3\n\"\"\"\nDiscord Node\n\nConverted from TypeScript by agent-skills/code-convert\nCorrelation ID: node-discord-v2test3\nGenerated: 2026-01-06T04:37:53.282221\n\nSYNC-CELERY SAFE: All methods are synchronous with timeouts.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List\n\nimport requests\n\nfrom .base import BaseNode, NodeParameterType, NodeExecutionData\n\nlogger = logging.getLogger(__name__)\n\n\nclass DiscordNode(BaseNode):\n    \"\"\"\n    Node node.\n    \n    \n    \"\"\"\n\n    type = \"discord\"\n    version = 1\n    \n    description = {\n        \"displayName\": \"Node\",\n        \"name\": \"discord\",\n        \"icon\": \"file:discord.svg\",\n        \"group\": ['output'],\n        \"description\": \"\",\n        \"inputs\": [{\"name\": \"main\", \"type\": \"main\", \"required\": True}],\n        \"outputs\": [{\"name\": \"main\", \"type\": \"main\", \"required\": True}],\n    }\n    \n    properties = {\n        \"parameters\": [\n            {\"name\": \"operation\", \"type\": NodeParameterType.OPTIONS, \"display_name\": \"Operation\", \"options\": [\n                {\"name\": \"Send a Message\", \"value\": \"sendLegacy\", \"description\": \"Send a message to a channel using the webhook\"},\n                {\"name\": \"parseDiscordError\", \"value\": \"parseDiscordError\", \"description\": \"Operation: parseDiscordError\"},\n                {\"name\": \"prepareErrorData\", \"value\": \"prepareErrorData\", \"description\": \"Operation: prepareErrorData\"},\n                {\"name\": \"prepareOptions\", \"value\": \"prepareOptions\", \"description\": \"Operation: prepareOptions\"},\n                {\"name\": \"prepareEmbeds\", \"value\": \"prepareEmbeds\", \"description\": \"Operation: prepareEmbeds\"},\n                {\"name\": \"prepareMultiPartForm\", \"value\": \"prepareMultiPartForm\", \"description\": \"Operation: prepareMultiPartForm\"},\n                {\"name\": \"checkAccessToGuild\", \"value\": \"checkAccessToGuild\", \"description\": \"Operation: checkAccessToGuild\"},\n                {\"name\": \"checkAccessToChannel\", \"value\": \"checkAccessToChannel\", \"description\": \"Operation: checkAccessToChannel\"},\n                {\"name\": \"setupChannelGetter\", \"value\": \"setupChannelGetter\", \"description\": \"Operation: setupChannelGetter\"},\n                {\"name\": \"sendDiscordMessage\", \"value\": \"sendDiscordMessage\", \"description\": \"Operation: sendDiscordMessage\"},\n                {\"name\": \"createSendAndWaitMessageBody\", \"value\": \"createSendAndWaitMessageBody\", \"description\": \"Operation: createSendAndWaitMessageBody\"},\n                {\"name\": \"getGuildId\", \"value\": \"getGuildId\", \"description\": \"Operation: getGuildId\"},\n                {\"name\": \"checkBotAccessToGuild\", \"value\": \"checkBotAccessToGuild\", \"description\": \"Operation: checkBotAccessToGuild\"},\n                {\"name\": \"guildSearch\", \"value\": \"guildSearch\", \"description\": \"Operation: guildSearch\"},\n                {\"name\": \"channelSearch\", \"value\": \"channelSearch\", \"description\": \"Operation: channelSearch\"},\n                {\"name\": \"textChannelSearch\", \"value\": \"textChannelSearch\", \"description\": \"Operation: textChannelSearch\"},\n                {\"name\": \"categorySearch\", \"value\": \"categorySearch\", \"description\": \"Operation: categorySearch\"},\n                {\"name\": \"userSearch\", \"value\": \"userSearch\", \"description\": \"Operation: userSearch\"},\n                {\"name\": \"getRoles\", \"value\": \"getRoles\", \"description\": \"Operation: getRoles\"},\n                {\"name\": \"discordApiRequest\", \"value\": \"discordApiRequest\", \"description\": \"Operation: discordApiRequest\"},\n                {\"name\": \"discordApiMultiPartRequest\", \"value\": \"discordApiMultiPartRequest\", \"description\": \"Operation: discordApiMultiPartRequest\"},\n                {\"name\": \"requestApi\", \"value\": \"requestApi\", \"description\": \"Operation: requestApi\"}\n            ], \"default\": \"sendLegacy\", \"description\": \"Operation to perform\"},\n            {\"name\": \"webhookUri\", \"type\": NodeParameterType.STRING, \"display_name\": \"Webhook URL\", \"default\": \"\", \"required\": True},\n            {\"name\": \"text\", \"type\": NodeParameterType.STRING, \"display_name\": \"Content\", \"default\": \"\"},\n            {\"name\": \"options\", \"type\": NodeParameterType.COLLECTION, \"display_name\": \"Additional Fields\", \"default\": \"{\", \"description\": \"Whether this message be sent as a Text To Speech message\"},\n            {\"name\": \"allowedMentions\", \"type\": NodeParameterType.JSON, \"display_name\": \"Allowed Mentions\", \"default\": \"\"},\n            {\"name\": \"attachments\", \"type\": NodeParameterType.JSON, \"display_name\": \"Attachments\", \"default\": \"\"},\n            {\"name\": \"avatarUrl\", \"type\": NodeParameterType.STRING, \"display_name\": \"Avatar URL\", \"default\": \"\"},\n            {\"name\": \"components\", \"type\": NodeParameterType.JSON, \"display_name\": \"Components\", \"default\": \"\"},\n            {\"name\": \"embeds\", \"type\": NodeParameterType.JSON, \"display_name\": \"Embeds\", \"default\": \"\"},\n            {\"name\": \"flags\", \"type\": NodeParameterType.NUMBER, \"display_name\": \"Flags\", \"default\": \"\"},\n            {\"name\": \"payloadJson\", \"type\": NodeParameterType.JSON, \"display_name\": \"JSON Payload\", \"default\": \"\"},\n            {\"name\": \"username\", \"type\": NodeParameterType.STRING, \"display_name\": \"Username\", \"default\": \"\"},\n            {\"name\": \"tts\", \"type\": NodeParameterType.BOOLEAN, \"display_name\": \"TTS\", \"default\": False, \"description\": \"Whether this message be sent as a Text To Speech message\"},\n            {\"name\": \"authentication\", \"type\": NodeParameterType.OPTIONS, \"display_name\": \"Connection Type\", \"options\": [\n                {\"name\": \"Bot Token\", \"value\": \"botToken\"},\n                {\"name\": \"OAuth2\", \"value\": \"oAuth2\"},\n                {\"name\": \"Webhook\", \"value\": \"webhook\"}\n            ], \"default\": \"botToken\", \"description\": \"Manage messages, channels, and members on a server\"},\n            {\"name\": \"OAuth2\", \"type\": NodeParameterType.OPTIONS, \"display_name\": \"Bot Token\", \"description\": \"Manage messages, channels, and members on a server\"}\n        ],\n        \"credentials\": [\n            {\"name\": \"oauth2\", \"required\": True}\n        ]\n    }\n    \n    icon = \"discord.svg\"\n\n    def execute(self) -> List[List[NodeExecutionData]]:\n        \"\"\"\n        Execute the node operations.\n        \n        SYNC-CELERY SAFE: All HTTP calls use timeout parameter.\n        \n        Returns:\n            List[List[NodeExecutionData]]: Nested list where outer list is output branches,\n            inner list is items in that branch.\n        \"\"\"\n        # Get input data from previous node\n        input_data = self.get_input_data()\n        \n        # Handle empty input\n        if not input_data:\n            return [[]]\n        \n        return_items: List[NodeExecutionData] = []\n\n        for i, item in enumerate(input_data):\n            try:\n                operation = self.get_node_parameter(\"operation\", i)\n                item_data = item.json_data if hasattr(item, 'json_data') else item.get('json', {})\n                \n                if operation == \"sendLegacy\":\n                    result = self._sendLegacy(i, item_data)\n                elif operation == \"parseDiscordError\":\n                    result = self._parseDiscordError(i, item_data)\n                elif operation == \"prepareErrorData\":\n                    result = self._prepareErrorData(i, item_data)\n                elif operation == \"prepareOptions\":\n                    result = self._prepareOptions(i, item_data)\n                elif operation == \"prepareEmbeds\":\n                    result = self._prepareEmbeds(i, item_data)\n                elif operation == \"prepareMultiPartForm\":\n                    result = self._prepareMultiPartForm(i, item_data)\n                elif operation == \"checkAccessToGuild\":\n                    result = self._checkAccessToGuild(i, item_data)\n                elif operation == \"checkAccessToChannel\":\n                    result = self._checkAccessToChannel(i, item_data)\n                elif operation == \"setupChannelGetter\":\n                    result = self._setupChannelGetter(i, item_data)\n                elif operation == \"sendDiscordMessage\":\n                    result = self._sendDiscordMessage(i, item_data)\n                elif operation == \"createSendAndWaitMessageBody\":\n                    result = self._createSendAndWaitMessageBody(i, item_data)\n                elif operation == \"getGuildId\":\n                    result = self._getGuildId(i, item_data)\n                elif operation == \"checkBotAccessToGuild\":\n                    result = self._checkBotAccessToGuild(i, item_data)\n                elif operation == \"guildSearch\":\n                    result = self._guildSearch(i, item_data)\n                elif operation == \"channelSearch\":\n                    result = self._channelSearch(i, item_data)\n                elif operation == \"textChannelSearch\":\n                    result = self._textChannelSearch(i, item_data)\n                elif operation == \"categorySearch\":\n                    result = self._categorySearch(i, item_data)\n                elif operation == \"userSearch\":\n                    result = self._userSearch(i, item_data)\n                elif operation == \"getRoles\":\n                    result = self._getRoles(i, item_data)\n                elif operation == \"discordApiRequest\":\n                    result = self._discordApiRequest(i, item_data)\n                elif operation == \"discordApiMultiPartRequest\":\n                    result = self._discordApiMultiPartRequest(i, item_data)\n                elif operation == \"requestApi\":\n                    result = self._requestApi(i, item_data)\n                else:\n                    raise ValueError(f\"Unknown operation: {operation}\")\n                \n                # Handle array results\n                if isinstance(result, list):\n                    for r in result:\n                        return_items.append(NodeExecutionData(json_data=r))\n                else:\n                    return_items.append(NodeExecutionData(json_data=result))\n                    \n            except Exception as e:\n                logger.error(f\"Error in operation {operation}: {e}\")\n                if self.continue_on_fail:\n                    return_items.append(NodeExecutionData(json_data={\"error\": str(e)}))\n                else:\n                    raise\n        \n        return [return_items]\n\n    def _api_request(\n        self,\n        method: str,\n        endpoint: str,\n        body: Dict[str, Any] | None = None,\n        query: Dict[str, Any] | None = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Make authenticated API request.\n        \n        SYNC-CELERY SAFE: Uses requests with timeout.\n        \"\"\"\n        credentials = self.get_credentials(\"oauth2\")\n        \n        # Build headers based on credential type\n        headers = {}\n        if credentials.get(\"accessToken\"):\n            headers[\"Authorization\"] = f\"Bot {credentials.get('accessToken')}\"\n        elif credentials.get(\"apiKey\"):\n            query = query or {}\n            query[\"api_key\"] = credentials.get(\"apiKey\")\n        \n        url = f\"https://api.example.com{endpoint}\"\n        \n        response = requests.request(\n            method,\n            url,\n            params=query,\n            json=body,\n            headers=headers,\n            timeout=30,  # REQUIRED for Celery\n        )\n        response.raise_for_status()\n        return response.json()\n\n    def _sendLegacy(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        sendLegacy operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"sendLegacy operation not implemented\")\n\n    def _parseDiscordError(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        parseDiscordError operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"parseDiscordError operation not implemented\")\n\n    def _prepareErrorData(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        prepareErrorData operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"prepareErrorData operation not implemented\")\n\n    def _prepareOptions(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        prepareOptions operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"prepareOptions operation not implemented\")\n\n    def _prepareEmbeds(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        prepareEmbeds operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"prepareEmbeds operation not implemented\")\n\n    def _prepareMultiPartForm(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        prepareMultiPartForm operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"prepareMultiPartForm operation not implemented\")\n\n    def _checkAccessToGuild(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        checkAccessToGuild operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"checkAccessToGuild operation not implemented\")\n\n    def _checkAccessToChannel(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        checkAccessToChannel operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"checkAccessToChannel operation not implemented\")\n\n    def _setupChannelGetter(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        setupChannelGetter operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"setupChannelGetter operation not implemented\")\n\n    def _sendDiscordMessage(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        sendDiscordMessage operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"sendDiscordMessage operation not implemented\")\n\n    def _createSendAndWaitMessageBody(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        createSendAndWaitMessageBody operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"createSendAndWaitMessageBody operation not implemented\")\n\n    def _getGuildId(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        getGuildId operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"getGuildId operation not implemented\")\n\n    def _checkBotAccessToGuild(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        checkBotAccessToGuild operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"checkBotAccessToGuild operation not implemented\")\n\n    def _guildSearch(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        guildSearch operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"guildSearch operation not implemented\")\n\n    def _channelSearch(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        channelSearch operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"channelSearch operation not implemented\")\n\n    def _textChannelSearch(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        textChannelSearch operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"textChannelSearch operation not implemented\")\n\n    def _categorySearch(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        categorySearch operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"categorySearch operation not implemented\")\n\n    def _userSearch(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        userSearch operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"userSearch operation not implemented\")\n\n    def _getRoles(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        getRoles operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"getRoles operation not implemented\")\n\n    def _discordApiRequest(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        discordApiRequest operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"discordApiRequest operation not implemented\")\n\n    def _discordApiMultiPartRequest(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        discordApiMultiPartRequest operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"discordApiMultiPartRequest operation not implemented\")\n\n    def _requestApi(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        requestApi operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"requestApi operation not implemented\")\n\n",
          "__init__.py": "\"\"\"\nDiscord Node Package\nConverted from TypeScript by agent-skills/code-convert\n\"\"\"\n\nfrom .discord import DiscordNode\n\n__all__ = [\"DiscordNode\"]\n"
        }
      },
      "artifacts_produced": [
        "artifacts/node-discord-v2test3/conversion_log.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "package",
      "skill_name": "node-package",
      "status": "completed",
      "started_at": "2026-01-06T04:37:53.292648",
      "completed_at": "2026-01-06T04:37:53.304667",
      "duration_ms": 11,
      "outputs": {
        "package_dir": "artifacts/node-discord-v2test3/package",
        "files": [
          {
            "filename": "discord.py",
            "source_path": "artifacts/node-discord-v2test3/converted/__init__.py",
            "target_path": "nodes/discord.py",
            "is_test": false
          },
          {
            "filename": "discord.py",
            "source_path": "artifacts/node-discord-v2test3/converted/discord.py",
            "target_path": "nodes/discord.py",
            "is_test": false
          }
        ],
        "registry_entry": {
          "import_statement": "from .discord import DiscordNode",
          "dict_entry": "'discord': {'node_class': DiscordNode, 'type': 'regular'}",
          "node_type": "discord",
          "node_class": "DiscordNode",
          "module_name": "discord"
        },
        "manifest": {
          "correlation_id": "node-discord-v2test3",
          "node_type": "discord",
          "node_class": "DiscordNode",
          "registry_strategy": "dict_import",
          "files": [
            {
              "filename": "discord.py",
              "target_path": "nodes/discord.py",
              "checksum": "b43fce5d968a5ea7",
              "size_bytes": 145
            },
            {
              "filename": "discord.py",
              "target_path": "nodes/discord.py",
              "checksum": "f9702e251db99b55",
              "size_bytes": 27804
            }
          ],
          "registry_entry": {
            "import_statement": "from .discord import DiscordNode",
            "dict_entry": "'discord': {'node_class': DiscordNode, 'type': 'regular'}",
            "node_type": "discord",
            "node_class": "DiscordNode",
            "module_name": "discord"
          }
        }
      },
      "artifacts_produced": [
        "artifacts/node-discord-v2test3/package/manifest.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "pre-validate",
      "skill_name": "node-validate",
      "status": "completed",
      "started_at": "2026-01-06T04:37:53.304693",
      "completed_at": "2026-01-06T04:37:53.329461",
      "duration_ms": 24,
      "outputs": {
        "valid": true,
        "checks": [
          {
            "name": "[discord.py] Syntax",
            "passed": true,
            "details": "Syntax valid"
          },
          {
            "name": "[discord.py] AST",
            "passed": true,
            "details": "AST parsed successfully"
          },
          {
            "name": "[discord.py] Imports",
            "passed": true,
            "details": "Found 5 imports"
          },
          {
            "name": "[discord.py] Sync Celery",
            "passed": true,
            "details": "No async patterns detected"
          },
          {
            "name": "[discord.py] Node Class",
            "passed": true,
            "details": "Valid node class: DiscordNode"
          },
          {
            "name": "[discord.py] Timeouts",
            "passed": false,
            "details": "HTTP call 'get' at line 199 missing timeout; HTTP call 'get' at line 201 missing timeout; HTTP call 'get' at line 203 missing timeout; HTTP call 'get' at line 118 missing timeout; HTTP call 'get' at line 200 missing timeout"
          }
        ],
        "errors": [],
        "warnings": [
          "[discord.py] HTTP call 'get' at line 199 missing timeout; HTTP call 'get' at line 201 missing timeout; HTTP call 'get' at line 203 missing timeout; HTTP call 'get' at line 118 missing timeout; HTTP call 'get' at line 200 missing timeout"
        ]
      },
      "artifacts_produced": [
        "artifacts/node-discord-v2test3/validation/results.json"
      ],
      "errors": [],
      "skipped_reason": null
    },
    {
      "step_name": "apply",
      "skill_name": "apply-changes",
      "status": "skipped",
      "started_at": "2026-01-06T04:37:53.329491",
      "completed_at": "2026-01-06T04:37:53.329498",
      "duration_ms": 0,
      "outputs": {},
      "artifacts_produced": [],
      "errors": [],
      "skipped_reason": "Condition 'apply == True' not met"
    },
    {
      "step_name": "smoke-test",
      "skill_name": "node-smoke-test",
      "status": "skipped",
      "started_at": "2026-01-06T04:37:53.329504",
      "completed_at": "2026-01-06T04:37:53.329507",
      "duration_ms": 0,
      "outputs": {},
      "artifacts_produced": [],
      "errors": [],
      "skipped_reason": "Condition 'run_tests == True' not met"
    }
  ],
  "outputs": {
    "normalize": {
      "correlation_id": "node-discord-4057cfab",
      "normalized_name": "discord",
      "snapshot": {
        "version": "1.0",
        "created_at": "2026-01-06T04:37:51.909084+00:00",
        "correlation_id": "node-discord-4057cfab",
        "request": {
          "raw_node_name": "Discord",
          "normalized_name": "discord",
          "source_refs": {}
        },
        "checksum": "2ebed21a8a45bf96"
      },
      "artifacts": {
        "request_snapshot": "artifacts/node-discord-4057cfab/request_snapshot.json"
      }
    },
    "classify": {
      "source_type": "TYPE1",
      "confidence": 1.0,
      "evidence": [
        {
          "type": "ts_file",
          "path_or_url": "input_sources/discord/Discord.node.ts",
          "verified": true,
          "description": "Found node file: Discord.node.ts"
        },
        {
          "type": "ts_file",
          "path_or_url": "input_sources/discord/v2/DiscordV2.node.ts",
          "verified": true,
          "description": "Found node file: DiscordV2.node.ts"
        },
        {
          "type": "ts_file",
          "path_or_url": "input_sources/discord/v1/DiscordV1.node.ts",
          "verified": true,
          "description": "Found node file: DiscordV1.node.ts"
        },
        {
          "type": "v2_router",
          "path_or_url": "input_sources/discord",
          "verified": true,
          "description": "Found router.ts - indicates v2 node structure"
        },
        {
          "type": "v2_structure",
          "path_or_url": "input_sources/discord",
          "verified": true,
          "description": "Found v2 directory structure with actions"
        },
        {
          "type": "file_count",
          "path_or_url": "input_sources/discord",
          "verified": true,
          "description": "Found 50 TypeScript files in source directory"
        }
      ],
      "artifacts": {
        "classification": "artifacts/node-discord-v2test3/classification.json"
      }
    },
    "ground": {
      "repo_facts_path": "artifacts/node-discord-v2test3/repo_facts.json",
      "repo_facts": {
        "basenode_contract_path": "nodes/base.py",
        "node_loader_paths": [
          "venv/lib/python3.12/site-packages/yaml/loader.py"
        ],
        "golden_node_paths": [
          "nodes/http_request.py",
          "venv/lib/python3.12/site-packages/langchain_community/chat_loaders/slack.py",
          "venv/lib/python3.12/site-packages/tqdm/contrib/slack.py",
          "venv/lib/python3.12/site-packages/langchain/chat_loaders/slack.py",
          "nodes/slack.py"
        ],
        "test_command": "pytest"
      },
      "target_repo_layout_path": "artifacts/node-discord-v2test3/target_repo_layout.json",
      "target_repo_layout": {
        "target_repo_root": "/home/toni/n8n/back",
        "node_output_base_dir": "nodes",
        "registry_file": "nodes/__init__.py",
        "registry_strategy": "dict_import",
        "registry_dict_name": "node_definitions",
        "base_class_file": "nodes/base.py",
        "base_class_name": "BaseNode",
        "tests_dir": "tests",
        "python_version": "3.10",
        "venv_path": ".venv",
        "extra_allowlist_patterns": []
      }
    },
    "ingest": {
      "raw_content": "// === File: Discord.node.ts ===\nimport type { INodeTypeBaseDescription, IVersionedNodeType } from 'n8n-workflow';\nimport { VersionedNodeType } from 'n8n-workflow';\n\nimport { DiscordV1 } from './v1/DiscordV1.node';\nimport { DiscordV2 } from './v2/DiscordV2.node';\n\nexport class Discord extends VersionedNodeType {\n\tconstructor() {\n\t\tconst baseDescription: INodeTypeBaseDescription = {\n\t\t\tdisplayName: 'Discord',\n\t\t\tname: 'discord',\n\t\t\ticon: 'file:discord.svg',\n\t\t\tgroup: ['output'],\n\t\t\tdefaultVersion: 2,\n\t\t\tdescription: 'Sends data to Discord',\n\t\t};\n\n\t\tconst nodeVersions: IVersionedNodeType['nodeVersions'] = {\n\t\t\t1: new DiscordV1(baseDescription),\n\t\t\t2: new DiscordV2(baseDescription),\n\t\t};\n\n\t\tsuper(nodeVersions, baseDescription);\n\t}\n}\n\n\n// === File: test/v2/node/channel/create.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => create', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.post('/guilds/1168516062791340136/channels', { name: 'third', type: '0' })\n\t\t.reply(200, {\n\t\t\tid: '1168528323006181417',\n\t\t\ttype: 0,\n\t\t\tlast_message_id: null,\n\t\t\tflags: 0,\n\t\t\tguild_id: '1168516062791340136',\n\t\t\tname: 'third',\n\t\t\tparent_id: null,\n\t\t\trate_limit_per_user: 0,\n\t\t\ttopic: null,\n\t\t\tposition: 3,\n\t\t\tpermission_overwrites: [],\n\t\t\tnsfw: false,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['create.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/channel/deleteChannel.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => deleteChannel', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.delete('/channels/1168528323006181417')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['deleteChannel.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/channel/get.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => get', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.persist()\n\t\t.get('/users/@me/guilds')\n\t\t.reply(200, [{ id: '1168516062791340136' }])\n\t\t.get('/channels/1168516240332034067')\n\t\t.reply(200, {\n\t\t\tid: '1168516240332034067',\n\t\t\ttype: 0,\n\t\t\tlast_message_id: null,\n\t\t\tflags: 0,\n\t\t\tguild_id: '1168516062791340136',\n\t\t\tname: 'first',\n\t\t\tparent_id: '1168516063340789831',\n\t\t\trate_limit_per_user: 0,\n\t\t\ttopic: null,\n\t\t\tposition: 1,\n\t\t\tpermission_overwrites: [],\n\t\t\tnsfw: false,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['get.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/channel/getAll.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/guilds/1168516062791340136/channels')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tid: '1168516063340789831',\n\t\t\t\ttype: 4,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'Text Channels',\n\t\t\t\tparent_id: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789832',\n\t\t\t\ttype: 4,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'Voice Channels',\n\t\t\t\tparent_id: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789833',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: '1168518371239792720',\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'general',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\ttopic: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t\ticon_emoji: {\n\t\t\t\t\tid: null,\n\t\t\t\t\tname: 'ðŸ‘‹',\n\t\t\t\t},\n\t\t\t\ttheme_color: null,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789834',\n\t\t\t\ttype: 2,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'General',\n\t\t\t\tparent_id: '1168516063340789832',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\tbitrate: 64000,\n\t\t\t\tuser_limit: 0,\n\t\t\t\trtc_region: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t\ticon_emoji: {\n\t\t\t\t\tid: null,\n\t\t\t\t\tname: 'ðŸŽ™ï¸',\n\t\t\t\t},\n\t\t\t\ttheme_color: null,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516240332034067',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'first-channel',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 30,\n\t\t\t\ttopic: 'This is channel topic',\n\t\t\t\tposition: 3,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516269079793766',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'second',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\ttopic: null,\n\t\t\t\tposition: 2,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/channel/update.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => update', () => {\n\tnock('https://discord.com/api/v10').patch('/channels/1168516240332034067').reply(200, {\n\t\tid: '1168516240332034067',\n\t\ttype: 0,\n\t\tlast_message_id: null,\n\t\tflags: 0,\n\t\tguild_id: '1168516062791340136',\n\t\tname: 'first-channel',\n\t\tparent_id: '1168516063340789831',\n\t\trate_limit_per_user: 30,\n\t\ttopic: 'This is channel topic',\n\t\tposition: 3,\n\t\tpermission_overwrites: [],\n\t\tnsfw: true,\n\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['update.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/member/getAll.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/guilds/1168516062791340136/members?limit=2')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tuser: {\n\t\t\t\t\tid: '470936827994570762',\n\t\t\t\t\tusername: 'michael',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '0',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: 'Michael',\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\troles: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: {\n\t\t\t\t\tid: '1070667629972430879',\n\t\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '1037',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbot: true,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: null,\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\troles: ['1168518368526077992'],\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/member/roleAdd.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => roleAdd', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.put('/guilds/1168516062791340136/members/470936827994570762/roles/1168772374540320890')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['roleAdd.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/member/roleRemove.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => roleRemove', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.persist()\n\t\t.delete(/\\/guilds\\/1168516062791340136\\/members\\/470936827994570762\\/roles\\/\\d+/)\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['roleRemove.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/message/deleteMessage.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => deleteMessage', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.delete('/channels/1168516240332034067/messages/1168776343194972210')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['deleteMessage.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/message/get.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => get', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/channels/1168516240332034067/messages/1168777380144369718')\n\t\t.reply(200, {\n\t\t\tid: '1168777380144369718',\n\t\t\tchannel_id: '1168516240332034067',\n\t\t\tauthor: {\n\t\t\t\tid: '1070667629972430879',\n\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\tavatar: null,\n\t\t\t\tdiscriminator: '1037',\n\t\t\t\tpublic_flags: 0,\n\t\t\t\tpremium_type: 0,\n\t\t\t\tflags: 0,\n\t\t\t\tbot: true,\n\t\t\t\tbanner: null,\n\t\t\t\taccent_color: null,\n\t\t\t\tglobal_name: null,\n\t\t\t\tavatar_decoration_data: null,\n\t\t\t\tbanner_color: null,\n\t\t\t},\n\t\t\tcontent: 'msg 3',\n\t\t\ttimestamp: '2023-10-31T05:04:02.260000+00:00',\n\t\t\ttype: 0,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['get.workflow.json'],\n\t});\n});\n\n\n// === File: test/v2/node/message/getAll.test.ts ===\nimport { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/channels/1168516240332034067/messages?limit=1')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tid: '1168784010269433998',\n\t\t\t\ttype: 0,\n\t\t\t\tcontent: 'msg 4',\n\t\t\t\tchannel_id: '1168516240332034067',\n\t\t\t\tauthor: {\n\t\t\t\t\tid: '1070667629972430879',\n\t\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '1037',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbot: true,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: null,\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\tattachments: [],\n\t\t\t\tembeds: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'rich',\n\t\t\t\t\t\ttitle: 'Some Title',\n\t\t\t\t\t\tdescription: 'description',\n\t\t\t\t\t\tcolor: 2112935,\n\t\t\t\t\t\ttimestamp: '2023-10-30T22:00:00+00:00',\n\t\t\t\t\t\tauthor: {\n\t\t\t\t\t\t\tname: 'Me',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tmentions: [],\n\t\t\t\tmention_roles: [],\n\t\t\t\tpinned: false,\n",
      "parsed_sections": {
        "class_name": "DiscordV1",
        "node_type": "discord",
        "version": 1.0,
        "description": null,
        "properties": [],
        "methods": [
          "function",
          "execute"
        ],
        "credentials": [
          "discordBotApi",
          "discordOAuth2Api",
          "discordWebhookApi"
        ],
        "resources": [
          "channel",
          "member",
          "message"
        ],
        "has_router": true,
        "files": [
          "Discord.node.ts",
          "test/v2/node/channel/create.test.ts",
          "test/v2/node/channel/deleteChannel.test.ts",
          "test/v2/node/channel/get.test.ts",
          "test/v2/node/channel/getAll.test.ts",
          "test/v2/node/channel/update.test.ts",
          "test/v2/node/member/getAll.test.ts",
          "test/v2/node/member/roleAdd.test.ts",
          "test/v2/node/member/roleRemove.test.ts",
          "test/v2/node/message/deleteMessage.test.ts",
          "test/v2/node/message/get.test.ts",
          "test/v2/node/message/getAll.test.ts",
          "test/v2/node/message/react.test.ts",
          "test/v2/node/message/send.test.ts",
          "test/v2/node/message/sendAndWait.test.ts",
          "test/v2/node/webhook/sendLegacy.test.ts",
          "test/v2/utils.test.ts",
          "v1/DiscordV1.node.ts",
          "v1/Interfaces.ts",
          "v2/DiscordV2.node.ts",
          "v2/actions/channel/create.operation.ts",
          "v2/actions/channel/deleteChannel.operation.ts",
          "v2/actions/channel/get.operation.ts",
          "v2/actions/channel/getAll.operation.ts",
          "v2/actions/channel/index.ts",
          "v2/actions/channel/update.operation.ts",
          "v2/actions/common.description.ts",
          "v2/actions/member/getAll.operation.ts",
          "v2/actions/member/index.ts",
          "v2/actions/member/roleAdd.operation.ts",
          "v2/actions/member/roleRemove.operation.ts",
          "v2/actions/message/deleteMessage.operation.ts",
          "v2/actions/message/get.operation.ts",
          "v2/actions/message/getAll.operation.ts",
          "v2/actions/message/index.ts",
          "v2/actions/message/react.operation.ts",
          "v2/actions/message/send.operation.ts",
          "v2/actions/message/sendAndWait.operation.ts",
          "v2/actions/node.type.ts",
          "v2/actions/router.ts",
          "v2/actions/versionDescription.ts",
          "v2/actions/webhook/index.ts",
          "v2/actions/webhook/sendLegacy.operation.ts",
          "v2/helpers/utils.ts",
          "v2/methods/index.ts",
          "v2/methods/listSearch.ts",
          "v2/methods/loadOptions.ts",
          "v2/transport/discord.api.ts",
          "v2/transport/helpers.ts",
          "v2/transport/index.ts"
        ],
        "code": [
          {
            "file": "Discord.node.ts",
            "content": "import type { INodeTypeBaseDescription, IVersionedNodeType } from 'n8n-workflow';\nimport { VersionedNodeType } from 'n8n-workflow';\n\nimport { DiscordV1 } from './v1/DiscordV1.node';\nimport { DiscordV2 } from './v2/DiscordV2.node';\n\nexport class Discord extends VersionedNodeType {\n\tconstructor() {\n\t\tconst baseDescription: INodeTypeBaseDescription = {\n\t\t\tdisplayName: 'Discord',\n\t\t\tname: 'discord',\n\t\t\ticon: 'file:discord.svg',\n\t\t\tgroup: ['output'],\n\t\t\tdefaultVersion: 2,\n\t\t\tdescription: 'Sends data to Discord',\n\t\t};\n\n\t\tconst nodeVersions: IVersionedNodeType['nodeVersions'] = {\n\t\t\t1: new DiscordV1(baseDescription),\n\t\t\t2: new DiscordV2(baseDescription),\n\t\t};\n\n\t\tsuper(nodeVersions, baseDescription);\n\t}\n}\n"
          },
          {
            "file": "test/v2/node/channel/create.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => create', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.post('/guilds/1168516062791340136/channels', { name: 'third', type: '0' })\n\t\t.reply(200, {\n\t\t\tid: '1168528323006181417',\n\t\t\ttype: 0,\n\t\t\tlast_message_id: null,\n\t\t\tflags: 0,\n\t\t\tguild_id: '1168516062791340136',\n\t\t\tname: 'third',\n\t\t\tparent_id: null,\n\t\t\trate_limit_per_user: 0,\n\t\t\ttopic: null,\n\t\t\tposition: 3,\n\t\t\tpermission_overwrites: [],\n\t\t\tnsfw: false,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['create.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/channel/deleteChannel.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => deleteChannel', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.delete('/channels/1168528323006181417')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['deleteChannel.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/channel/get.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => get', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.persist()\n\t\t.get('/users/@me/guilds')\n\t\t.reply(200, [{ id: '1168516062791340136' }])\n\t\t.get('/channels/1168516240332034067')\n\t\t.reply(200, {\n\t\t\tid: '1168516240332034067',\n\t\t\ttype: 0,\n\t\t\tlast_message_id: null,\n\t\t\tflags: 0,\n\t\t\tguild_id: '1168516062791340136',\n\t\t\tname: 'first',\n\t\t\tparent_id: '1168516063340789831',\n\t\t\trate_limit_per_user: 0,\n\t\t\ttopic: null,\n\t\t\tposition: 1,\n\t\t\tpermission_overwrites: [],\n\t\t\tnsfw: false,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['get.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/channel/getAll.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/guilds/1168516062791340136/channels')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tid: '1168516063340789831',\n\t\t\t\ttype: 4,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'Text Channels',\n\t\t\t\tparent_id: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789832',\n\t\t\t\ttype: 4,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'Voice Channels',\n\t\t\t\tparent_id: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789833',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: '1168518371239792720',\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'general',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\ttopic: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t\ticon_emoji: {\n\t\t\t\t\tid: null,\n\t\t\t\t\tname: 'ðŸ‘‹',\n\t\t\t\t},\n\t\t\t\ttheme_color: null,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516063340789834',\n\t\t\t\ttype: 2,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'General',\n\t\t\t\tparent_id: '1168516063340789832',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\tbitrate: 64000,\n\t\t\t\tuser_limit: 0,\n\t\t\t\trtc_region: null,\n\t\t\t\tposition: 0,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t\ticon_emoji: {\n\t\t\t\t\tid: null,\n\t\t\t\t\tname: 'ðŸŽ™ï¸',\n\t\t\t\t},\n\t\t\t\ttheme_color: null,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516240332034067',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'first-channel',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 30,\n\t\t\t\ttopic: 'This is channel topic',\n\t\t\t\tposition: 3,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '1168516269079793766',\n\t\t\t\ttype: 0,\n\t\t\t\tlast_message_id: null,\n\t\t\t\tflags: 0,\n\t\t\t\tguild_id: '1168516062791340136',\n\t\t\t\tname: 'second',\n\t\t\t\tparent_id: '1168516063340789831',\n\t\t\t\trate_limit_per_user: 0,\n\t\t\t\ttopic: null,\n\t\t\t\tposition: 2,\n\t\t\t\tpermission_overwrites: [],\n\t\t\t\tnsfw: false,\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/channel/update.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, channel => update', () => {\n\tnock('https://discord.com/api/v10').patch('/channels/1168516240332034067').reply(200, {\n\t\tid: '1168516240332034067',\n\t\ttype: 0,\n\t\tlast_message_id: null,\n\t\tflags: 0,\n\t\tguild_id: '1168516062791340136',\n\t\tname: 'first-channel',\n\t\tparent_id: '1168516063340789831',\n\t\trate_limit_per_user: 30,\n\t\ttopic: 'This is channel topic',\n\t\tposition: 3,\n\t\tpermission_overwrites: [],\n\t\tnsfw: true,\n\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['update.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/member/getAll.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/guilds/1168516062791340136/members?limit=2')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tuser: {\n\t\t\t\t\tid: '470936827994570762',\n\t\t\t\t\tusername: 'michael',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '0',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: 'Michael',\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\troles: [],\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: {\n\t\t\t\t\tid: '1070667629972430879',\n\t\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '1037',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbot: true,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: null,\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\troles: ['1168518368526077992'],\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/member/roleAdd.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => roleAdd', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.put('/guilds/1168516062791340136/members/470936827994570762/roles/1168772374540320890')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['roleAdd.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/member/roleRemove.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, member => roleRemove', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.persist()\n\t\t.delete(/\\/guilds\\/1168516062791340136\\/members\\/470936827994570762\\/roles\\/\\d+/)\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['roleRemove.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/message/deleteMessage.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => deleteMessage', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.delete('/channels/1168516240332034067/messages/1168776343194972210')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['deleteMessage.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/message/get.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => get', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/channels/1168516240332034067/messages/1168777380144369718')\n\t\t.reply(200, {\n\t\t\tid: '1168777380144369718',\n\t\t\tchannel_id: '1168516240332034067',\n\t\t\tauthor: {\n\t\t\t\tid: '1070667629972430879',\n\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\tavatar: null,\n\t\t\t\tdiscriminator: '1037',\n\t\t\t\tpublic_flags: 0,\n\t\t\t\tpremium_type: 0,\n\t\t\t\tflags: 0,\n\t\t\t\tbot: true,\n\t\t\t\tbanner: null,\n\t\t\t\taccent_color: null,\n\t\t\t\tglobal_name: null,\n\t\t\t\tavatar_decoration_data: null,\n\t\t\t\tbanner_color: null,\n\t\t\t},\n\t\t\tcontent: 'msg 3',\n\t\t\ttimestamp: '2023-10-31T05:04:02.260000+00:00',\n\t\t\ttype: 0,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['get.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/message/getAll.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => getAll', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.get('/channels/1168516240332034067/messages?limit=1')\n\t\t.reply(200, [\n\t\t\t{\n\t\t\t\tid: '1168784010269433998',\n\t\t\t\ttype: 0,\n\t\t\t\tcontent: 'msg 4',\n\t\t\t\tchannel_id: '1168516240332034067',\n\t\t\t\tauthor: {\n\t\t\t\t\tid: '1070667629972430879',\n\t\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\t\tavatar: null,\n\t\t\t\t\tdiscriminator: '1037',\n\t\t\t\t\tpublic_flags: 0,\n\t\t\t\t\tpremium_type: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tbot: true,\n\t\t\t\t\tbanner: null,\n\t\t\t\t\taccent_color: null,\n\t\t\t\t\tglobal_name: null,\n\t\t\t\t\tavatar_decoration_data: null,\n\t\t\t\t\tbanner_color: null,\n\t\t\t\t},\n\t\t\t\tattachments: [],\n\t\t\t\tembeds: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'rich',\n\t\t\t\t\t\ttitle: 'Some Title',\n\t\t\t\t\t\tdescription: 'description',\n\t\t\t\t\t\tcolor: 2112935,\n\t\t\t\t\t\ttimestamp: '2023-10-30T22:00:00+00:00',\n\t\t\t\t\t\tauthor: {\n\t\t\t\t\t\t\tname: 'Me',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tmentions: [],\n\t\t\t\tmention_roles: [],\n\t\t\t\tpinned: false,\n\t\t\t\tmention_everyone: false,\n\t\t\t\ttts: false,\n\t\t\t\ttimestamp: '2023-10-31T05:30:23.005000+00:00',\n\t\t\t\tedited_timestamp: null,\n\t\t\t\tflags: 0,\n\t\t\t\tcomponents: [],\n\t\t\t},\n\t\t]);\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['getAll.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/message/react.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => react', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.put('/channels/1168516240332034067/messages/1168777380144369718/reactions/%F0%9F%98%80/@me')\n\t\t.reply(200, { success: true });\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['react.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/message/send.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, message => send', () => {\n\tnock('https://discord.com/api/v10')\n\t\t.post('/channels/1168516240332034067/messages', {\n\t\t\tcontent: 'msg 4',\n\t\t\tembeds: [\n\t\t\t\t{\n\t\t\t\t\tauthor: { name: 'Me' },\n\t\t\t\t\tcolor: 2112935,\n\t\t\t\t\tdescription: 'description',\n\t\t\t\t\ttimestamp: '2023-10-30T22:00:00.000Z',\n\t\t\t\t\ttitle: 'Some Title',\n\t\t\t\t},\n\t\t\t],\n\t\t})\n\t\t.reply(200, {\n\t\t\tid: '1168784010269433998',\n\t\t\ttype: 0,\n\t\t\tcontent: 'msg 4',\n\t\t\tchannel_id: '1168516240332034067',\n\t\t\tauthor: {\n\t\t\t\tid: '1070667629972430879',\n\t\t\t\tusername: 'n8n-node-overhaul',\n\t\t\t\tavatar: null,\n\t\t\t\tdiscriminator: '1037',\n\t\t\t\tpublic_flags: 0,\n\t\t\t\tpremium_type: 0,\n\t\t\t\tflags: 0,\n\t\t\t\tbot: true,\n\t\t\t\tbanner: null,\n\t\t\t\taccent_color: null,\n\t\t\t\tglobal_name: null,\n\t\t\t\tavatar_decoration_data: null,\n\t\t\t\tbanner_color: null,\n\t\t\t},\n\t\t\tattachments: [],\n\t\t\tembeds: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'rich',\n\t\t\t\t\ttitle: 'Some Title',\n\t\t\t\t\tdescription: 'description',\n\t\t\t\t\tcolor: 2112935,\n\t\t\t\t\ttimestamp: '2023-10-30T22:00:00+00:00',\n\t\t\t\t\tauthor: {\n\t\t\t\t\t\tname: 'Me',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tmentions: [],\n\t\t\tmention_roles: [],\n\t\t\tpinned: false,\n\t\t\tmention_everyone: false,\n\t\t\ttts: false,\n\t\t\ttimestamp: '2023-10-31T05:30:23.005000+00:00',\n\t\t\tedited_timestamp: null,\n\t\t\tflags: 0,\n\t\t\tcomponents: [],\n\t\t\treferenced_message: null,\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tworkflowFiles: ['send.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/message/sendAndWait.test.ts",
            "content": "import type { MockProxy } from 'jest-mock-extended';\nimport { mock } from 'jest-mock-extended';\nimport { SEND_AND_WAIT_OPERATION, type IExecuteFunctions } from 'n8n-workflow';\n\nimport { versionDescription } from '../../../../v2/actions/versionDescription';\nimport { DiscordV2 } from '../../../../v2/DiscordV2.node';\nimport * as transport from '../../../../v2/transport/discord.api';\n\njest.mock('../../../../v2/transport/discord.api', () => {\n\tconst originalModule = jest.requireActual('../../../../v2/transport/discord.api');\n\treturn {\n\t\t...originalModule,\n\t\tdiscordApiRequest: jest.fn(async function (method: string) {\n\t\t\tif (method === 'POST') {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}),\n\t};\n});\n\ndescribe('Test DiscordV2, message => sendAndWait', () => {\n\tlet discord: DiscordV2;\n\tlet mockExecuteFunctions: MockProxy<IExecuteFunctions>;\n\n\tbeforeEach(() => {\n\t\tdiscord = new DiscordV2(versionDescription);\n\t\tmockExecuteFunctions = mock<IExecuteFunctions>();\n\t\tmockExecuteFunctions.helpers = {\n\t\t\tconstructExecutionMetaData: jest.fn(() => []),\n\t\t\treturnJsonArray: jest.fn(() => []),\n\t\t} as any;\n\t});\n\n\tafterEach(() => {\n\t\tjest.clearAllMocks();\n\t});\n\n\tit('should send message and put execution to wait', async () => {\n\t\tconst items = [{ json: { data: 'test' } }];\n\t\tmockExecuteFunctions.getNodeParameter.mockImplementation((key: string) => {\n\t\t\tif (key === 'operation') return SEND_AND_WAIT_OPERATION;\n\t\t\tif (key === 'resource') return 'message';\n\t\t\tif (key === 'authentication') return 'botToken';\n\t\t\tif (key === 'message') return 'my message';\n\t\t\tif (key === 'subject') return '';\n\t\t\tif (key === 'approvalOptions.values') return {};\n\t\t\tif (key === 'responseType') return 'approval';\n\t\t\tif (key === 'sendTo') return 'channel';\n\t\t\tif (key === 'channelId') return 'channelID';\n\t\t\tif (key === 'options.limitWaitTime.values') return {};\n\t\t});\n\n\t\tmockExecuteFunctions.putExecutionToWait.mockImplementation();\n\t\tmockExecuteFunctions.getInputData.mockReturnValue(items);\n\t\tmockExecuteFunctions.getInstanceId.mockReturnValue('instanceId');\n\n\t\tmockExecuteFunctions.evaluateExpression.mockReturnValueOnce('http://localhost/waiting-webhook');\n\t\tmockExecuteFunctions.evaluateExpression.mockReturnValueOnce('nodeID');\n\n\t\tmockExecuteFunctions.getSignedResumeUrl.mockReturnValue(\n\t\t\t'http://localhost/waiting-webhook/nodeID?approved=true&token=abc',\n\t\t);\n\n\t\tconst result = await discord.execute.call(mockExecuteFunctions);\n\n\t\texpect(result).toEqual([items]);\n\t\texpect(transport.discordApiRequest).toHaveBeenCalledTimes(1);\n\t\texpect(mockExecuteFunctions.putExecutionToWait).toHaveBeenCalledTimes(1);\n\n\t\texpect(transport.discordApiRequest).toHaveBeenCalledWith(\n\t\t\t'POST',\n\t\t\t'/channels/channelID/messages',\n\t\t\t{\n\t\t\t\tcomponents: [\n\t\t\t\t\t{\n\t\t\t\t\t\tcomponents: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlabel: 'Approve',\n\t\t\t\t\t\t\t\tstyle: 5,\n\t\t\t\t\t\t\t\ttype: 2,\n\t\t\t\t\t\t\t\turl: 'http://localhost/waiting-webhook/nodeID?approved=true&token=abc',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\ttype: 1,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tembeds: [\n\t\t\t\t\t{\n\t\t\t\t\t\tcolor: 5814783,\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'my message\\n\\n_This message was sent automatically with _[n8n](https://n8n.io/?utm_source=n8n-internal&utm_medium=powered_by&utm_campaign=n8n-nodes-base.discord_instanceId)',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t);\n\t});\n});\n"
          },
          {
            "file": "test/v2/node/webhook/sendLegacy.test.ts",
            "content": "import { NodeTestHarness } from '@nodes-testing/node-test-harness';\nimport nock from 'nock';\n\ndescribe('Test DiscordV2, webhook => sendLegacy', () => {\n\tconst credentials = {\n\t\tdiscordWebhookApi: {\n\t\t\twebhookUri: 'https://discord.com/webhook',\n\t\t},\n\t};\n\n\tnock(credentials.discordWebhookApi.webhookUri)\n\t\t.post('?wait=true')\n\t\t.reply(200, {\n\t\t\tid: '1168768986385747999',\n\t\t\ttype: 0,\n\t\t\tcontent: 'TEST Message',\n\t\t\tchannel_id: '1074646335082479626',\n\t\t\tauthor: {\n\t\t\t\tid: '1153265494955135077',\n\t\t\t\tusername: 'TEST_USER',\n\t\t\t\tavatar: null,\n\t\t\t\tdiscriminator: '0000',\n\t\t\t\tpublic_flags: 0,\n\t\t\t\tflags: 0,\n\t\t\t\tbot: true,\n\t\t\t\tglobal_name: null,\n\t\t\t},\n\t\t\tattachments: [],\n\t\t\tembeds: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'rich',\n\t\t\t\t\tdescription: 'some description',\n\t\t\t\t\tcolor: 10930459,\n\t\t\t\t\ttimestamp: '2023-10-17T21:00:00+00:00',\n\t\t\t\t\tauthor: {\n\t\t\t\t\t\tname: 'Michael',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tmentions: [],\n\t\t\tmention_roles: [],\n\t\t\tpinned: false,\n\t\t\tmention_everyone: false,\n\t\t\ttts: true,\n\t\t\ttimestamp: '2023-10-31T04:30:41.032000+00:00',\n\t\t\tedited_timestamp: null,\n\t\t\tflags: 4096,\n\t\t\tcomponents: [],\n\t\t\twebhook_id: '1153265494955135077',\n\t\t});\n\n\tnew NodeTestHarness().setupTests({\n\t\tcredentials,\n\t\tworkflowFiles: ['sendLegacy.workflow.json'],\n\t});\n});\n"
          },
          {
            "file": "test/v2/utils.test.ts",
            "content": "import type { IExecuteFunctions, INode } from 'n8n-workflow';\n\nimport * as transport from '../../v2//transport/discord.api';\nimport {\n\tcreateSimplifyFunction,\n\tprepareOptions,\n\tprepareEmbeds,\n\tcheckAccessToGuild,\n\tsetupChannelGetter,\n} from '../../v2/helpers/utils';\n\nconst node: INode = {\n\tid: '1',\n\tname: 'Discord node',\n\ttypeVersion: 2,\n\ttype: 'n8n-nodes-base.discord',\n\tposition: [60, 760],\n\tparameters: {\n\t\tresource: 'channel',\n\t\toperation: 'get',\n\t},\n};\n\ndescribe('Test Discord > createSimplifyFunction', () => {\n\tit('should create function', () => {\n\t\tconst result = createSimplifyFunction(['message_reference']);\n\t\texpect(result).toBeDefined();\n\t\texpect(typeof result).toBe('function');\n\t});\n\n\tit('should return object containing only specified fields', () => {\n\t\tconst simplify = createSimplifyFunction(['id', 'name']);\n\t\tconst data = {\n\t\t\tid: '123',\n\t\t\tname: 'test',\n\t\t\ttype: 'test',\n\t\t\trandomField: 'test',\n\t\t};\n\t\tconst result = simplify(data);\n\t\texpect(result).toEqual({\n\t\t\tid: '123',\n\t\t\tname: 'test',\n\t\t});\n\t});\n});\n\ndescribe('Test Discord > prepareOptions', () => {\n\tit('should return correct flag value', () => {\n\t\tconst result = prepareOptions({\n\t\t\tflags: ['SUPPRESS_EMBEDS', 'SUPPRESS_NOTIFICATIONS'],\n\t\t});\n\t\texpect(result.flags).toBe((1 << 2) + (1 << 12));\n\t});\n\n\tit('should convert message_reference', () => {\n\t\tconst result = prepareOptions(\n\t\t\t{\n\t\t\t\tmessage_reference: '123456',\n\t\t\t},\n\t\t\t'789000',\n\t\t);\n\t\texpect(result.message_reference).toEqual({\n\t\t\tmessage_id: '123456',\n\t\t\tguild_id: '789000',\n\t\t});\n\t});\n});\n\ndescribe('Test Discord > prepareEmbeds', () => {\n\tit('should return return empty object removing empty strings', () => {\n\t\tconst embeds = [\n\t\t\t{\n\t\t\t\ttest1: 'test',\n\t\t\t\ttest2: 'test',\n\t\t\t\tdescription: 'test',\n\t\t\t},\n\t\t];\n\n\t\tconst executeFunction = {};\n\n\t\tconst result = prepareEmbeds.call(executeFunction as unknown as IExecuteFunctions, embeds);\n\n\t\texpect(result).toEqual(embeds);\n\t});\n});\n\ndescribe('Test Discord > checkAccessToGuild', () => {\n\tit('should throw error', () => {\n\t\tconst guildId = '123456';\n\t\tconst guilds = [\n\t\t\t{\n\t\t\t\tid: '789000',\n\t\t\t},\n\t\t];\n\n\t\texpect(() => {\n\t\t\tcheckAccessToGuild(node, guildId, guilds);\n\t\t}).toThrow('You do not have access to the guild with the id 123456');\n\t});\n\n\tit('should pass', () => {\n\t\tconst guildId = '123456';\n\t\tconst guilds = [\n\t\t\t{\n\t\t\t\tid: '123456',\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: '789000',\n\t\t\t},\n\t\t];\n\n\t\texpect(() => {\n\t\t\tcheckAccessToGuild(node, guildId, guilds);\n\t\t}).not.toThrow();\n\t});\n});\n\ndescribe('Test Discord > setupChannelGetter & checkAccessToChannel', () => {\n\tconst discordApiRequestSpy = jest.spyOn(transport, 'discordApiRequest');\n\tdiscordApiRequestSpy.mockImplementation(async (method: string) => {\n\t\tif (method === 'GET') {\n\t\t\treturn {\n\t\t\t\tguild_id: '123456',\n\t\t\t};\n\t\t}\n\t});\n\n\tit('should setup channel getter and get channel id', async () => {\n\t\tconst fakeExecuteFunction = (auth: string) => {\n\t\t\treturn {\n\t\t\t\tgetNodeParameter: (parameter: string) => {\n\t\t\t\t\tif (parameter === 'authentication') return auth;\n\t\t\t\t\tif (parameter === 'channelId') return '42';\n\t\t\t\t},\n\t\t\t\tgetNode: () => node,\n\t\t\t} as unknown as IExecuteFunctions;\n\t\t};\n\n\t\tconst userGuilds = [\n\t\t\t{\n\t\t\t\tid: '789000',\n\t\t\t},\n\t\t];\n\n\t\ttry {\n\t\t\tconst getChannel = await setupChannelGetter.call(fakeExecuteFunction('oAuth2'), userGuilds);\n\t\t\tawait getChannel(0);\n\t\t} catch (error) {\n\t\t\texpect(error.message).toBe('You do not have access to the guild with the id 123456');\n\t\t}\n\n\t\tconst getChannel = await setupChannelGetter.call(fakeExecuteFunction('botToken'), userGuilds);\n\t\tconst channelId = await getChannel(0);\n\t\texpect(channelId).toBe('42');\n\t});\n});\n"
          },
          {
            "file": "v1/DiscordV1.node.ts",
            "content": "import type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n\tIRequestOptions,\n} from 'n8n-workflow';\nimport {\n\tjsonParse,\n\tNodeApiError,\n\tNodeConnectionTypes,\n\tNodeOperationError,\n\tsleep,\n} from 'n8n-workflow';\n\nimport type { DiscordAttachment, DiscordWebhook } from './Interfaces';\nimport { oldVersionNotice } from '../../../utils/descriptions';\n\nconst versionDescription: INodeTypeDescription = {\n\tdisplayName: 'Discord',\n\tname: 'discord',\n\ticon: 'file:discord.svg',\n\tgroup: ['output'],\n\tversion: 1,\n\tdescription: 'Sends data to Discord',\n\tdefaults: {\n\t\tname: 'Discord',\n\t},\n\tinputs: [NodeConnectionTypes.Main],\n\toutputs: [NodeConnectionTypes.Main],\n\tproperties: [\n\t\toldVersionNotice,\n\t\t{\n\t\t\tdisplayName: 'Webhook URL',\n\t\t\tname: 'webhookUri',\n\t\t\ttype: 'string',\n\t\t\trequired: true,\n\t\t\tdefault: '',\n\t\t\tplaceholder: 'https://discord.com/api/webhooks/ID/TOKEN',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Content',\n\t\t\tname: 'text',\n\t\t\ttype: 'string',\n\t\t\ttypeOptions: {\n\t\t\t\tmaxValue: 2000,\n\t\t\t},\n\t\t\tdefault: '',\n\t\t\tplaceholder: 'Hello World!',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Additional Fields',\n\t\t\tname: 'options',\n\t\t\ttype: 'collection',\n\t\t\tplaceholder: 'Add option',\n\t\t\tdefault: {},\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Allowed Mentions',\n\t\t\t\t\tname: 'allowedMentions',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Attachments',\n\t\t\t\t\tname: 'attachments',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Avatar URL',\n\t\t\t\t\tname: 'avatarUrl',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Components',\n\t\t\t\t\tname: 'components',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Embeds',\n\t\t\t\t\tname: 'embeds',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Flags',\n\t\t\t\t\tname: 'flags',\n\t\t\t\t\ttype: 'number',\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'JSON Payload',\n\t\t\t\t\tname: 'payloadJson',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\ttypeOptions: { alwaysOpenEditWindow: true },\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Username',\n\t\t\t\t\tname: 'username',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\tplaceholder: 'User',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'TTS',\n\t\t\t\t\tname: 'tts',\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tdefault: false,\n\t\t\t\t\tdescription: 'Whether this message be sent as a Text To Speech message',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport class DiscordV1 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t};\n\t}\n\n\tasync execute(this: IExecuteFunctions) {\n\t\tconst returnData: INodeExecutionData[] = [];\n\n\t\tconst webhookUri = this.getNodeParameter('webhookUri', 0, '') as string;\n\n\t\tif (!webhookUri) throw new NodeOperationError(this.getNode(), 'Webhook uri is required.');\n\n\t\tconst items = this.getInputData();\n\t\tconst length = items.length;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst body: DiscordWebhook = {};\n\n\t\t\tconst iterationWebhookUri = this.getNodeParameter('webhookUri', i) as string;\n\t\t\tbody.content = this.getNodeParameter('text', i) as string;\n\t\t\tconst options = this.getNodeParameter('options', i);\n\n\t\t\tif (!body.content && !options.embeds) {\n\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Either content or embeds must be set.', {\n\t\t\t\t\titemIndex: i,\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (options.embeds) {\n\t\t\t\ttry {\n\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\tbody.embeds = JSON.parse(options.embeds);\n\t\t\t\t\tif (!Array.isArray(body.embeds)) {\n\t\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Embeds must be an array of embeds.', {\n\t\t\t\t\t\t\titemIndex: i,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Embeds must be valid JSON.', {\n\t\t\t\t\t\titemIndex: i,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.username) {\n\t\t\t\tbody.username = options.username as string;\n\t\t\t}\n\n\t\t\tif (options.components) {\n\t\t\t\ttry {\n\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\tbody.components = JSON.parse(options.components);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Components must be valid JSON.', {\n\t\t\t\t\t\titemIndex: i,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (options.allowed_mentions) {\n\t\t\t\t//@ts-expect-error\n\t\t\t\tbody.allowed_mentions = jsonParse(options.allowed_mentions);\n\t\t\t}\n\n\t\t\tif (options.avatarUrl) {\n\t\t\t\tbody.avatar_url = options.avatarUrl as string;\n\t\t\t}\n\n\t\t\tif (options.flags) {\n\t\t\t\tbody.flags = options.flags as number;\n\t\t\t}\n\n\t\t\tif (options.tts) {\n\t\t\t\tbody.tts = options.tts as boolean;\n\t\t\t}\n\n\t\t\tif (options.payloadJson) {\n\t\t\t\t//@ts-expect-error\n\t\t\t\tbody.payload_json = jsonParse(options.payloadJson);\n\t\t\t}\n\n\t\t\tif (options.attachments) {\n\t\t\t\t//@ts-expect-error\n\t\t\t\tbody.attachments = jsonParse(options.attachments as DiscordAttachment[]);\n\t\t\t}\n\n\t\t\t//* Not used props, delete them from the payload as Discord won't need them :^\n\t\t\tif (!body.content) delete body.content;\n\t\t\tif (!body.username) delete body.username;\n\t\t\tif (!body.avatar_url) delete body.avatar_url;\n\t\t\tif (!body.embeds) delete body.embeds;\n\t\t\tif (!body.allowed_mentions) delete body.allowed_mentions;\n\t\t\tif (!body.flags) delete body.flags;\n\t\t\tif (!body.components) delete body.components;\n\t\t\tif (!body.payload_json) delete body.payload_json;\n\t\t\tif (!body.attachments) delete body.attachments;\n\n\t\t\tlet requestOptions: IRequestOptions;\n\n\t\t\tif (!body.payload_json) {\n\t\t\t\trequestOptions = {\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\tbody,\n\t\t\t\t\turi: iterationWebhookUri,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json; charset=utf-8',\n\t\t\t\t\t},\n\t\t\t\t\tjson: true,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\trequestOptions = {\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\tbody,\n\t\t\t\t\turi: iterationWebhookUri,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'multipart/form-data; charset=utf-8',\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t\tlet maxTries = 5;\n\t\t\tlet response;\n\n\t\t\tdo {\n\t\t\t\ttry {\n\t\t\t\t\tresponse = await this.helpers.request(requestOptions);\n\t\t\t\t\tconst resetAfter = response.headers['x-ratelimit-reset-after'] * 1000;\n\t\t\t\t\tconst remainingRatelimit = response.headers['x-ratelimit-remaining'];\n\n\t\t\t\t\t// remaining requests 0\n\t\t\t\t\t// https://discord.com/developers/docs/topics/rate-limits\n\t\t\t\t\tif (!+remainingRatelimit) {\n\t\t\t\t\t\tawait sleep(resetAfter ?? 1000);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// HTTP/1.1 429 TOO MANY REQUESTS\n\t\t\t\t\t// Await when the current rate limit will reset\n\t\t\t\t\t// https://discord.com/developers/docs/topics/rate-limits\n\t\t\t\t\tif (error.statusCode === 429) {\n\t\t\t\t\t\tconst retryAfter = error.response?.headers['retry-after'] || 1000;\n\n\t\t\t\t\t\tawait sleep(+retryAfter);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t} while (--maxTries);\n\n\t\t\tif (maxTries <= 0) {\n\t\t\t\tthrow new NodeApiError(this.getNode(), {\n\t\t\t\t\terror: 'Could not send Webhook message. Max amount of rate-limit retries reached.',\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\t\t\treturnData.push(...executionData);\n\t\t}\n\n\t\treturn [returnData];\n\t}\n}\n"
          },
          {
            "file": "v1/Interfaces.ts",
            "content": "export interface DiscordWebhook {\n\tcontent?: string;\n\tusername?: string;\n\tavatar_url?: string;\n\ttts?: boolean;\n\tfile?: Buffer;\n\tembeds?: any[];\n\tallowed_mentions?: {\n\t\tparse: Array<'roles' | 'users' | 'everyone'>;\n\t\troles: string[];\n\t\tusers: string[];\n\t\treplied_user: boolean;\n\t};\n\tflags?: number;\n\tattachments?: DiscordAttachment[];\n\tcomponents?: any[];\n\tpayload_json?: any;\n}\n\nexport interface DiscordAttachment {\n\tid?: string;\n\tfilename?: string;\n\tsize?: number;\n\tdescription?: string;\n\tcontent_type?: string;\n\turl?: string;\n\tproxy_url?: string;\n\theight?: number;\n\twidth?: number;\n\tephemeral?: boolean;\n}\n"
          },
          {
            "file": "v2/DiscordV2.node.ts",
            "content": "import type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\n\nimport { router } from './actions/router';\nimport { versionDescription } from './actions/versionDescription';\nimport { listSearch, loadOptions } from './methods';\nimport { sendAndWaitWebhook } from '../../../utils/sendAndWait/utils';\n\nexport class DiscordV2 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t\tusableAsTool: true,\n\t\t};\n\t}\n\n\tmethods = {\n\t\tlistSearch,\n\t\tloadOptions,\n\t};\n\n\twebhook = sendAndWaitWebhook;\n\n\tasync execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {\n\t\treturn await router.call(this);\n\t}\n}\n"
          },
          {
            "file": "v2/actions/channel/create.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { categoryRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Name',\n\t\tname: 'name',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\trequired: true,\n\t\tdescription: 'The name of the channel',\n\t\tplaceholder: 'e.g. new-channel',\n\t},\n\t{\n\t\tdisplayName: 'Type',\n\t\tname: 'type',\n\t\ttype: 'options',\n\t\tdefault: '0',\n\t\trequired: true,\n\t\tdescription: 'The type of channel to create',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Guild Text',\n\t\t\t\tvalue: '0',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Guild Voice',\n\t\t\t\tvalue: '2',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Guild Category',\n\t\t\t\tvalue: '4',\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Age-Restricted (NSFW)',\n\t\t\t\tname: 'nsfw',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether the content of the channel might be nsfw (not safe for work)',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\thide: {\n\t\t\t\t\t\t'/type': ['4'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Bitrate',\n\t\t\t\tname: 'bitrate',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 8000,\n\t\t\t\tplaceholder: 'e.g. 8000',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 8000,\n\t\t\t\t\tmaxValue: 96000,\n\t\t\t\t},\n\t\t\t\tdescription: 'The bitrate (in bits) of the voice channel',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\t'/type': ['2'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\t...categoryRLC,\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\thide: {\n\t\t\t\t\t\t'/type': ['4'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Position',\n\t\t\t\tname: 'position',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Rate Limit Per User',\n\t\t\t\tname: 'rate_limit_per_user',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 0,\n\t\t\t\tdescription: 'Amount of seconds a user has to wait before sending another message',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\thide: {\n\t\t\t\t\t\t'/type': ['4'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Topic',\n\t\t\t\tname: 'topic',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\trows: 2,\n\t\t\t\t},\n\t\t\t\tdescription: 'The channel topic description (0-1024 characters)',\n\t\t\t\tplaceholder: 'e.g. This channel is aboutâ€¦',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\thide: {\n\t\t\t\t\t\t'/type': ['4'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'User Limit',\n\t\t\t\tname: 'user_limit',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 0,\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 0,\n\t\t\t\t\tmaxValue: 99,\n\t\t\t\t},\n\t\t\t\tplaceholder: 'e.g. 20',\n\t\t\t\tdescription:\n\t\t\t\t\t'The limit for the number of members that can be in the channel (0 refers to no limit)',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\t'/type': ['2'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['create'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst name = this.getNodeParameter('name', i) as string;\n\t\t\tconst type = this.getNodeParameter('type', i) as string;\n\t\t\tconst options = this.getNodeParameter('options', i);\n\n\t\t\tif (options.categoryId) {\n\t\t\t\toptions.parent_id = (options.categoryId as IDataObject).value;\n\t\t\t\tdelete options.categoryId;\n\t\t\t}\n\n\t\t\tconst body: IDataObject = {\n\t\t\t\tname,\n\t\t\t\ttype,\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst response = await discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'POST',\n\t\t\t\t`/guilds/${guildId}/channels`,\n\t\t\t\tbody,\n\t\t\t);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/channel/deleteChannel.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [channelRLC];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['deleteChannel'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst response = await discordApiRequest.call(this, 'DELETE', `/channels/${channelId}`);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/channel/get.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [channelRLC];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['get'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst response = await discordApiRequest.call(this, 'GET', `/channels/${channelId}`);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/channel/getAll.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { returnAllOrLimit } from '../../../../../utils/descriptions';\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\n\nconst properties: INodeProperties[] = [\n\t...returnAllOrLimit,\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Filter by Type',\n\t\t\t\tname: 'filter',\n\t\t\t\ttype: 'multiOptions',\n\t\t\t\tdefault: [],\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Guild Text',\n\t\t\t\t\t\tvalue: 0,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Guild Voice',\n\t\t\t\t\t\tvalue: 2,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Guild Category',\n\t\t\t\t\t\tvalue: 4,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['getAll'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\n\ttry {\n\t\tconst returnAll = this.getNodeParameter('returnAll', 0, false);\n\t\tlet response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/channels`);\n\n\t\tif (!returnAll) {\n\t\t\tconst limit = this.getNodeParameter('limit', 0);\n\t\t\tresponse = (response as IDataObject[]).slice(0, limit);\n\t\t}\n\n\t\tconst options = this.getNodeParameter('options', 0, {});\n\n\t\tif (options.filter) {\n\t\t\tconst filter = options.filter as number[];\n\t\t\tresponse = (response as IDataObject[]).filter((item) => filter.includes(item.type as number));\n\t\t}\n\n\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t{ itemData: { item: 0 } },\n\t\t);\n\n\t\treturnData.push(...executionData);\n\t} catch (error) {\n\t\tconst err = parseDiscordError.call(this, error);\n\n\t\tif (this.continueOnFail()) {\n\t\t\treturnData.push(...prepareErrorData.call(this, err, 0));\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/channel/index.ts",
            "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport * as create from './create.operation';\nimport * as deleteChannel from './deleteChannel.operation';\nimport * as get from './get.operation';\nimport * as getAll from './getAll.operation';\nimport * as update from './update.operation';\nimport { guildRLC } from '../common.description';\n\nexport { create, get, getAll, update, deleteChannel };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['channel'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Create',\n\t\t\t\tvalue: 'create',\n\t\t\t\tdescription: 'Create a new channel',\n\t\t\t\taction: 'Create a channel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Delete',\n\t\t\t\tvalue: 'deleteChannel',\n\t\t\t\tdescription: 'Delete a channel',\n\t\t\t\taction: 'Delete a channel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Get',\n\t\t\t\tvalue: 'get',\n\t\t\t\tdescription: 'Get a channel',\n\t\t\t\taction: 'Get a channel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Get Many',\n\t\t\t\tvalue: 'getAll',\n\t\t\t\tdescription: 'Retrieve the channels of a server',\n\t\t\t\taction: 'Get many channels',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Update',\n\t\t\t\tvalue: 'update',\n\t\t\t\tdescription: 'Update a channel',\n\t\t\t\taction: 'Update a channel',\n\t\t\t},\n\t\t],\n\t\tdefault: 'create',\n\t},\n\t{\n\t\t...guildRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['channel'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t},\n\t...create.description,\n\t...deleteChannel.description,\n\t...get.description,\n\t...getAll.description,\n\t...update.description,\n];\n"
          },
          {
            "file": "v2/actions/channel/update.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { categoryRLC, channelRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\tchannelRLC,\n\t{\n\t\tdisplayName: 'Name',\n\t\tname: 'name',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription:\n\t\t\t\"The new name of the channel. Fill this field only if you want to change the channel's name.\",\n\t\tplaceholder: 'e.g. new-channel-name',\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Age-Restricted (NSFW)',\n\t\t\t\tname: 'nsfw',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether the content of the channel might be nsfw (not safe for work)',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Bitrate',\n\t\t\t\tname: 'bitrate',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 8000,\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 8000,\n\t\t\t\t\tmaxValue: 96000,\n\t\t\t\t},\n\t\t\t\tdescription: 'The bitrate (in bits) of the voice channel',\n\t\t\t\thint: 'Only applicable to voice channels',\n\t\t\t},\n\t\t\tcategoryRLC,\n\t\t\t{\n\t\t\t\tdisplayName: 'Position',\n\t\t\t\tname: 'position',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 1,\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tdisplayName: 'Rate Limit Per User',\n\t\t\t\tname: 'rate_limit_per_user',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 0,\n\t\t\t\tdescription: 'Amount of seconds a user has to wait before sending another message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Topic',\n\t\t\t\tname: 'topic',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\trows: 2,\n\t\t\t\t},\n\t\t\t\tdescription: 'The channel topic description (0-1024 characters)',\n\t\t\t\tplaceholder: 'e.g. This channel is aboutâ€¦',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'User Limit',\n\t\t\t\tname: 'user_limit',\n\t\t\t\ttype: 'number',\n\t\t\t\tdefault: 0,\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 0,\n\t\t\t\t\tmaxValue: 99,\n\t\t\t\t},\n\t\t\t\tplaceholder: 'e.g. 20',\n\t\t\t\thint: 'Only applicable to voice channels',\n\t\t\t\tdescription:\n\t\t\t\t\t'The limit for the number of members that can be in the channel (0 refers to no limit)',\n\t\t\t},\n\t\t],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['channel'],\n\t\toperation: ['update'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst name = this.getNodeParameter('name', i) as string;\n\t\t\tconst options = this.getNodeParameter('options', i);\n\n\t\t\tif (options.categoryId) {\n\t\t\t\toptions.parent_id = (options.categoryId as IDataObject).value;\n\t\t\t\tdelete options.categoryId;\n\t\t\t}\n\n\t\t\tconst body: IDataObject = {\n\t\t\t\tname,\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst response = await discordApiRequest.call(this, 'PATCH', `/channels/${channelId}`, body);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/common.description.ts",
            "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../utils/utilities';\n\nexport const guildRLC: INodeProperties = {\n\tdisplayName: 'Server',\n\tname: 'guildId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'Select the server (guild) that your bot is connected to',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. my-server',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'guildSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By URL',\n\t\t\tname: 'url',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. https://discord.com/channels/[guild-id]',\n\t\t\textractValue: {\n\t\t\t\ttype: 'regex',\n\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/([0-9]+)',\n\t\t\t},\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/([0-9]+)',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Server URL',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 896347036838936576',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Server ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const channelRLC: INodeProperties = {\n\tdisplayName: 'Channel',\n\tname: 'channelId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'Select the channel by name, URL, or ID',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. my-channel',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'channelSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By URL',\n\t\t\tname: 'url',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. https://discord.com/channels/[guild-id]/[channel-id]',\n\t\t\textractValue: {\n\t\t\t\ttype: 'regex',\n\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t},\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Channel URL',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 896347036838936576',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Channel ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const textChannelRLC: INodeProperties = {\n\tdisplayName: 'Channel',\n\tname: 'channelId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\trequired: true,\n\tdescription: 'Select the channel by name, URL, or ID',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. my-channel',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'textChannelSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By URL',\n\t\t\tname: 'url',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. https://discord.com/channels/[guild-id]/[channel-id]',\n\t\t\textractValue: {\n\t\t\t\ttype: 'regex',\n\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t},\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Channel URL',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 896347036838936576',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Channel ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const categoryRLC: INodeProperties = {\n\tdisplayName: 'Parent Category',\n\tname: 'categoryId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\tdescription: 'The parent category where you want the channel to appear',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. my-channel',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'categorySearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By URL',\n\t\t\tname: 'url',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. https://discord.com/channels/[guild-id]/[channel-id]',\n\t\t\textractValue: {\n\t\t\t\ttype: 'regex',\n\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t},\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: 'https:\\\\/\\\\/discord.com\\\\/channels\\\\/[0-9]+\\\\/([0-9]+)',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Category URL',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 896347036838936576',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid Discord Category ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const userRLC: INodeProperties = {\n\tdisplayName: 'User',\n\tname: 'userId',\n\ttype: 'resourceLocator',\n\tdefault: { mode: 'list', value: '' },\n\tdescription: 'Select the user you want to assign a role to',\n\tmodes: [\n\t\t{\n\t\t\tdisplayName: 'By Name',\n\t\t\tname: 'list',\n\t\t\ttype: 'list',\n\t\t\tplaceholder: 'e.g. DiscordUser',\n\t\t\ttypeOptions: {\n\t\t\t\tsearchListMethod: 'userSearch',\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'By ID',\n\t\t\tname: 'id',\n\t\t\ttype: 'string',\n\t\t\tplaceholder: 'e.g. 786953432728469534',\n\t\t\tvalidation: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'regex',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tregex: '[0-9]+',\n\t\t\t\t\t\terrorMessage: 'Not a valid User ID',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const roleMultiOptions: INodeProperties = {\n\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-wrong-for-dynamic-multi-options\n\tdisplayName: 'Role',\n\tname: 'role',\n\ttype: 'multiOptions',\n\ttypeOptions: {\n\t\tloadOptionsMethod: 'getRoles',\n\t\tloadOptionsDependsOn: ['userId.value', 'guildId.value', 'operation'],\n\t},\n\trequired: true,\n\t// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-dynamic-multi-options\n\tdescription: 'Select the roles you want to add to the user',\n\tdefault: [],\n};\n\nexport const maxResultsNumber: INodeProperties = {\n\tdisplayName: 'Max Results',\n\tname: 'maxResults',\n\ttype: 'number',\n\ttypeOptions: {\n\t\tminValue: 1,\n\t},\n\tdefault: 50,\n\tdescription: 'Maximum number of results. Too many results may slow down the query.',\n};\n\nexport const messageIdString: INodeProperties = {\n\tdisplayName: 'Message ID',\n\tname: 'messageId',\n\ttype: 'string',\n\tdefault: '',\n\trequired: true,\n\tdescription: 'The ID of the message',\n\tplaceholder: 'e.g. 1057576506244726804',\n};\n\nexport const simplifyBoolean: INodeProperties = {\n\tdisplayName: 'Simplify',\n\tname: 'simplify',\n\ttype: 'boolean',\n\tdefault: true,\n\tdescription: 'Whether to return a simplified version of the response instead of the raw data',\n};\n\n// embeds -----------------------------------------------------------------------------------------\nconst embedFields: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Description',\n\t\tname: 'description',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The description of embed',\n\t\tplaceholder: 'e.g. My description',\n\t\ttypeOptions: {\n\t\t\trows: 2,\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Author',\n\t\tname: 'author',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The name of the author',\n\t\tplaceholder: 'e.g. John Doe',\n\t},\n\t{\n\t\tdisplayName: 'Color',\n\t\tname: 'color',\n\n\t\ttype: 'color',\n\t\tdefault: '',\n\t\tdescription: 'Color code of the embed',\n\t\tplaceholder: 'e.g. 12123432',\n\t},\n\t{\n\t\tdisplayName: 'Timestamp',\n\t\tname: 'timestamp',\n\t\ttype: 'dateTime',\n\t\tdefault: '',\n\t\tdescription: 'The time displayed at the bottom of the embed. Provide in ISO8601 format.',\n\t\tplaceholder: 'e.g. 2023-02-08 09:30:26',\n\t},\n\t{\n\t\tdisplayName: 'Title',\n\t\tname: 'title',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The title of embed',\n\t\tplaceholder: \"e.g. Embed's title\",\n\t},\n\t{\n\t\tdisplayName: 'URL',\n\t\tname: 'url',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The URL where you want to link the embed to',\n\t\tplaceholder: 'e.g. https://discord.com/',\n\t},\n\t{\n\t\tdisplayName: 'URL Image',\n\t\tname: 'image',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'Source URL of image (only supports http(s) and attachments)',\n\t\tplaceholder: 'e.g. https://example.com/image.png',\n\t},\n\t{\n\t\tdisplayName: 'URL Thumbnail',\n\t\tname: 'thumbnail',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'Source URL of thumbnail (only supports http(s) and attachments)',\n\t\tplaceholder: 'e.g. https://example.com/image.png',\n\t},\n\t{\n\t\tdisplayName: 'URL Video',\n\t\tname: 'video',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'Source URL of video',\n\t\tplaceholder: 'e.g. https://example.com/video.mp4',\n\t},\n];\n\nconst embedFieldsDescription = updateDisplayOptions(\n\t{\n\t\tshow: {\n\t\t\tinputMethod: ['fields'],\n\t\t},\n\t},\n\tembedFields,\n);\n\nexport const embedsFixedCollection: INodeProperties = {\n\tdisplayName: 'Embeds',\n\tname: 'embeds',\n\ttype: 'fixedCollection',\n\tplaceholder: 'Add Embeds',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tdefault: [],\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Input Method',\n\t\t\t\t\tname: 'inputMethod',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Enter Fields',\n\t\t\t\t\t\t\tvalue: 'fields',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Raw JSON',\n\t\t\t\t\t\t\tvalue: 'json',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'fields',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Value',\n\t\t\t\t\tname: 'json',\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\tdefault: '={}',\n\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\trows: 2,\n\t\t\t\t\t},\n\t\t\t\t\tdisplayOptions: {\n\t\t\t\t\t\tshow: {\n\t\t\t\t\t\t\tinputMethod: ['json'],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t...embedFieldsDescription,\n\t\t\t],\n\t\t},\n\t],\n};\n\n// -------------------------------------------------------------------------------------------\n\nexport const filesFixedCollection: INodeProperties = {\n\tdisplayName: 'Files',\n\tname: 'files',\n\ttype: 'fixedCollection',\n\tplaceholder: 'Add Files',\n\ttypeOptions: {\n\t\tmultipleValues: true,\n\t},\n\tdefault: [],\n\toptions: [\n\t\t{\n\t\t\tdisplayName: 'Values',\n\t\t\tname: 'values',\n\t\t\tvalues: [\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Input Data Field Name',\n\t\t\t\t\tname: 'inputFieldName',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: 'data',\n\t\t\t\t\tdescription: 'The contents of the file being sent with the message',\n\t\t\t\t\tplaceholder: 'e.g. data',\n\t\t\t\t\thint: 'The name of the input field containing the binary file data to be sent',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport const sendToProperties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Send To',\n\t\tname: 'sendTo',\n\t\ttype: 'options',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'User',\n\t\t\t\tvalue: 'user',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Channel',\n\t\t\t\tvalue: 'channel',\n\t\t\t},\n\t\t],\n\t\tdefault: 'channel',\n\t\tdescription: 'Send message to a channel or DM to a user',\n\t},\n\n\t{\n\t\t...userRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tsendTo: ['user'],\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t...textChannelRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tsendTo: ['channel'],\n\t\t\t},\n\t\t},\n\t},\n];\n"
          },
          {
            "file": "v2/actions/member/getAll.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { returnAllOrLimit } from '../../../../../utils/descriptions';\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { createSimplifyFunction, parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { simplifyBoolean } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\t...returnAllOrLimit,\n\t{\n\t\tdisplayName: 'After',\n\t\tname: 'after',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tplaceholder: 'e.g. 786953432728469534',\n\t\tdescription: 'The ID of the user after which to return the members',\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [simplifyBoolean],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['member'],\n\t\toperation: ['getAll'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\n\tconst returnAll = this.getNodeParameter('returnAll', 0, false);\n\tconst after = this.getNodeParameter('after', 0);\n\n\tconst qs: IDataObject = {};\n\n\tif (!returnAll) {\n\t\tconst limit = this.getNodeParameter('limit', 0);\n\t\tqs.limit = limit;\n\t}\n\n\tif (after) {\n\t\tqs.after = after;\n\t}\n\n\tlet response: IDataObject[] = [];\n\n\ttry {\n\t\tif (!returnAll) {\n\t\t\tconst limit = this.getNodeParameter('limit', 0);\n\t\t\tqs.limit = limit;\n\t\t\tresponse = await discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'GET',\n\t\t\t\t`/guilds/${guildId}/members`,\n\t\t\t\tundefined,\n\t\t\t\tqs,\n\t\t\t);\n\t\t} else {\n\t\t\tlet responseData;\n\t\t\tqs.limit = 100;\n\n\t\t\tdo {\n\t\t\t\tresponseData = await discordApiRequest.call(\n\t\t\t\t\tthis,\n\t\t\t\t\t'GET',\n\t\t\t\t\t`/guilds/${guildId}/members`,\n\t\t\t\t\tundefined,\n\t\t\t\t\tqs,\n\t\t\t\t);\n\t\t\t\tif (!responseData?.length) break;\n\t\t\t\tqs.after = responseData[responseData.length - 1].user.id;\n\t\t\t\tresponse.push(...responseData);\n\t\t\t} while (responseData.length);\n\t\t}\n\n\t\tconst simplify = this.getNodeParameter('options.simplify', 0, false) as boolean;\n\n\t\tif (simplify) {\n\t\t\tconst simplifyResponse = createSimplifyFunction(['user', 'roles', 'permissions']);\n\n\t\t\tresponse = response.map(simplifyResponse);\n\t\t}\n\n\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t{ itemData: { item: 0 } },\n\t\t);\n\n\t\treturnData.push(...executionData);\n\t} catch (error) {\n\t\tconst err = parseDiscordError.call(this, error);\n\n\t\tif (this.continueOnFail()) {\n\t\t\treturnData.push(...prepareErrorData.call(this, err, 0));\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/member/index.ts",
            "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport * as getAll from './getAll.operation';\nimport * as roleAdd from './roleAdd.operation';\nimport * as roleRemove from './roleRemove.operation';\nimport { guildRLC } from '../common.description';\n\nexport { getAll, roleAdd, roleRemove };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['member'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Get Many',\n\t\t\t\tvalue: 'getAll',\n\t\t\t\tdescription: 'Retrieve the members of a server',\n\t\t\t\taction: 'Get many members',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Role Add',\n\t\t\t\tvalue: 'roleAdd',\n\t\t\t\tdescription: 'Add a role to a member',\n\t\t\t\taction: 'Add a role to a member',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Role Remove',\n\t\t\t\tvalue: 'roleRemove',\n\t\t\t\tdescription: 'Remove a role from a member',\n\t\t\t\taction: 'Remove a role from a member',\n\t\t\t},\n\t\t],\n\t\tdefault: 'getAll',\n\t},\n\t{\n\t\t...guildRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['member'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t},\n\t...getAll.description,\n\t...roleAdd.description,\n\t...roleRemove.description,\n];\n"
          },
          {
            "file": "v2/actions/member/roleAdd.operation.ts",
            "content": "import type { IExecuteFunctions, INodeExecutionData, INodeProperties } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { roleMultiOptions, userRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [userRLC, roleMultiOptions];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['member'],\n\t\toperation: ['roleAdd'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst userId = this.getNodeParameter('userId', i, undefined, {\n\t\t\t\textractValue: true,\n\t\t\t}) as string;\n\n\t\t\tconst roles = this.getNodeParameter('role', i, []) as string[];\n\n\t\t\tfor (const roleId of roles) {\n\t\t\t\tawait discordApiRequest.call(\n\t\t\t\t\tthis,\n\t\t\t\t\t'PUT',\n\t\t\t\t\t`/guilds/${guildId}/members/${userId}/roles/${roleId}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/member/roleRemove.operation.ts",
            "content": "import type { IExecuteFunctions, INodeExecutionData, INodeProperties } from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { roleMultiOptions, userRLC } from '../common.description';\n\nconst properties: INodeProperties[] = [userRLC, roleMultiOptions];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['member'],\n\t\toperation: ['roleRemove'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst userId = this.getNodeParameter('userId', i, undefined, {\n\t\t\t\textractValue: true,\n\t\t\t}) as string;\n\n\t\t\tconst roles = this.getNodeParameter('role', i, []) as string[];\n\n\t\t\tfor (const roleId of roles) {\n\t\t\t\tawait discordApiRequest.call(\n\t\t\t\t\tthis,\n\t\t\t\t\t'DELETE',\n\t\t\t\t\t`/guilds/${guildId}/members/${userId}/roles/${roleId}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/message/deleteMessage.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC, messageIdString } from '../common.description';\n\nconst properties: INodeProperties[] = [channelRLC, messageIdString];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['deleteMessage'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst messageId = this.getNodeParameter('messageId', i) as string;\n\n\t\t\tawait discordApiRequest.call(this, 'DELETE', `/channels/${channelId}/messages/${messageId}`);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/message/get.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport {\n\tcreateSimplifyFunction,\n\tparseDiscordError,\n\tprepareErrorData,\n\tsetupChannelGetter,\n} from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC, messageIdString, simplifyBoolean } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\tchannelRLC,\n\tmessageIdString,\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [simplifyBoolean],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['get'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\tconst simplifyResponse = createSimplifyFunction([\n\t\t'id',\n\t\t'channel_id',\n\t\t'author',\n\t\t'content',\n\t\t'timestamp',\n\t\t'type',\n\t]);\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst messageId = this.getNodeParameter('messageId', i) as string;\n\n\t\t\tlet response = await discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'GET',\n\t\t\t\t`/channels/${channelId}/messages/${messageId}`,\n\t\t\t);\n\n\t\t\tconst simplify = this.getNodeParameter('options.simplify', i, false) as boolean;\n\n\t\t\tif (simplify) {\n\t\t\t\tresponse = simplifyResponse(response);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/message/getAll.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { returnAllOrLimit } from '../../../../../utils/descriptions';\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport {\n\tcreateSimplifyFunction,\n\tparseDiscordError,\n\tprepareErrorData,\n\tsetupChannelGetter,\n} from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC, simplifyBoolean } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\tchannelRLC,\n\t...returnAllOrLimit,\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [simplifyBoolean],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['getAll'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\tconst simplifyResponse = createSimplifyFunction([\n\t\t'id',\n\t\t'channel_id',\n\t\t'author',\n\t\t'content',\n\t\t'timestamp',\n\t\t'type',\n\t]);\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst returnAll = this.getNodeParameter('returnAll', i, false);\n\n\t\t\tconst qs: IDataObject = {};\n\n\t\t\tlet response: IDataObject[] = [];\n\n\t\t\tif (!returnAll) {\n\t\t\t\tconst limit = this.getNodeParameter('limit', 0);\n\t\t\t\tqs.limit = limit;\n\t\t\t\tresponse = await discordApiRequest.call(\n\t\t\t\t\tthis,\n\t\t\t\t\t'GET',\n\t\t\t\t\t`/channels/${channelId}/messages`,\n\t\t\t\t\tundefined,\n\t\t\t\t\tqs,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tlet responseData;\n\t\t\t\tqs.limit = 100;\n\n\t\t\t\tdo {\n\t\t\t\t\tresponseData = await discordApiRequest.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\t'GET',\n\t\t\t\t\t\t`/channels/${channelId}/messages`,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tqs,\n\t\t\t\t\t);\n\t\t\t\t\tif (!responseData?.length) break;\n\t\t\t\t\tqs.before = responseData[responseData.length - 1].id;\n\t\t\t\t\tresponse.push(...responseData);\n\t\t\t\t} while (responseData.length);\n\t\t\t}\n\n\t\t\tconst simplify = this.getNodeParameter('options.simplify', i, false) as boolean;\n\n\t\t\tif (simplify) {\n\t\t\t\tresponse = response.map(simplifyResponse);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/message/index.ts",
            "content": "import { SEND_AND_WAIT_OPERATION, type INodeProperties } from 'n8n-workflow';\n\nimport * as deleteMessage from './deleteMessage.operation';\nimport * as get from './get.operation';\nimport * as getAll from './getAll.operation';\nimport * as react from './react.operation';\nimport * as send from './send.operation';\nimport * as sendAndWait from './sendAndWait.operation';\nimport { guildRLC } from '../common.description';\n\nexport { getAll, react, send, deleteMessage, get, sendAndWait };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['message'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Delete',\n\t\t\t\tvalue: 'deleteMessage',\n\t\t\t\tdescription: 'Delete a message in a channel',\n\t\t\t\taction: 'Delete a message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Get',\n\t\t\t\tvalue: 'get',\n\t\t\t\tdescription: 'Get a message in a channel',\n\t\t\t\taction: 'Get a message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Get Many',\n\t\t\t\tvalue: 'getAll',\n\t\t\t\tdescription: 'Retrieve the latest messages in a channel',\n\t\t\t\taction: 'Get many messages',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'React with Emoji',\n\t\t\t\tvalue: 'react',\n\t\t\t\tdescription: 'React to a message with an emoji',\n\t\t\t\taction: 'React with an emoji to a message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Send',\n\t\t\t\tvalue: 'send',\n\t\t\t\tdescription: 'Send a message to a channel, thread, or member',\n\t\t\t\taction: 'Send a message',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Send and Wait for Response',\n\t\t\t\tvalue: SEND_AND_WAIT_OPERATION,\n\t\t\t\tdescription: 'Send a message and wait for response',\n\t\t\t\taction: 'Send message and wait for response',\n\t\t\t},\n\t\t],\n\t\tdefault: 'send',\n\t},\n\t{\n\t\t...guildRLC,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tresource: ['message'],\n\t\t\t\tauthentication: ['botToken', 'oAuth2'],\n\t\t\t},\n\t\t},\n\t},\n\t...getAll.description,\n\t...react.description,\n\t...send.description,\n\t...deleteMessage.description,\n\t...get.description,\n\t...sendAndWait.description,\n];\n"
          },
          {
            "file": "v2/actions/message/react.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport { parseDiscordError, prepareErrorData, setupChannelGetter } from '../../helpers/utils';\nimport { discordApiRequest } from '../../transport';\nimport { channelRLC, messageIdString } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\tchannelRLC,\n\tmessageIdString,\n\t{\n\t\tdisplayName: 'Emoji',\n\t\tname: 'emoji',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\trequired: true,\n\t\tdescription: 'The emoji you want to react with',\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['react'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\t_guildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst getChannelId = await setupChannelGetter.call(this, userGuilds);\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst channelId = await getChannelId(i);\n\n\t\t\tconst messageId = this.getNodeParameter('messageId', i) as string;\n\t\t\tconst emoji = this.getNodeParameter('emoji', i) as string;\n\n\t\t\tawait discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'PUT',\n\t\t\t\t`/channels/${channelId}/messages/${messageId}/reactions/${encodeURIComponent(emoji)}/@me`,\n\t\t\t);\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray({ success: true }),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/message/send.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport {\n\tparseDiscordError,\n\tprepareEmbeds,\n\tprepareErrorData,\n\tprepareOptions,\n\tsendDiscordMessage,\n} from '../../helpers/utils';\nimport {\n\tembedsFixedCollection,\n\tfilesFixedCollection,\n\tsendToProperties,\n} from '../common.description';\n\nconst properties: INodeProperties[] = [\n\t...sendToProperties,\n\t{\n\t\tdisplayName: 'Message',\n\t\tname: 'content',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The content of the message (up to 2000 characters)',\n\t\tplaceholder: 'e.g. My message',\n\t\ttypeOptions: {\n\t\t\trows: 2,\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Flags',\n\t\t\t\tname: 'flags',\n\t\t\t\ttype: 'multiOptions',\n\t\t\t\tdefault: [],\n\t\t\t\tdescription:\n\t\t\t\t\t'Message flags. <a href=\"https://discord.com/developers/docs/resources/channel#message-object-message-flags\" target=\"_blank\">More info</a>.â€.',\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Suppress Embeds',\n\t\t\t\t\t\tvalue: 'SUPPRESS_EMBEDS',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Suppress Notifications',\n\t\t\t\t\t\tvalue: 'SUPPRESS_NOTIFICATIONS',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\t// eslint-disable-next-line n8n-nodes-base/node-param-display-name-miscased\n\t\t\t\tdisplayName: 'Message to Reply to',\n\t\t\t\tname: 'message_reference',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'Fill this to make your message a reply. Add the message ID.',\n\t\t\t\tplaceholder: 'e.g. 1059467601836773386',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Text-to-Speech (TTS)',\n\t\t\t\tname: 'tts',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to have a bot reading the message directly in the channel',\n\t\t\t},\n\t\t],\n\t},\n\tembedsFixedCollection,\n\tfilesFixedCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tresource: ['message'],\n\t\toperation: ['send'],\n\t},\n\thide: {\n\t\tauthentication: ['webhook'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst content = this.getNodeParameter('content', i) as string;\n\t\tconst options = prepareOptions(this.getNodeParameter('options', i, {}), guildId);\n\n\t\tconst embeds = (this.getNodeParameter('embeds', i, undefined) as IDataObject)\n\t\t\t?.values as IDataObject[];\n\t\tconst files = (this.getNodeParameter('files', i, undefined) as IDataObject)\n\t\t\t?.values as IDataObject[];\n\n\t\tconst body: IDataObject = {\n\t\t\tcontent,\n\t\t\t...options,\n\t\t};\n\n\t\tif (embeds) {\n\t\t\tbody.embeds = prepareEmbeds.call(this, embeds);\n\t\t}\n\n\t\ttry {\n\t\t\treturnData.push(\n\t\t\t\t...(await sendDiscordMessage.call(this, {\n\t\t\t\t\tguildId,\n\t\t\t\t\tuserGuilds,\n\t\t\t\t\tisOAuth2,\n\t\t\t\t\tbody,\n\t\t\t\t\titems,\n\t\t\t\t\tfiles,\n\t\t\t\t\titemIndex: i,\n\t\t\t\t})),\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/actions/message/sendAndWait.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { getSendAndWaitProperties } from '../../../../../utils/sendAndWait/utils';\nimport {\n\tcreateSendAndWaitMessageBody,\n\tparseDiscordError,\n\tprepareErrorData,\n\tsendDiscordMessage,\n} from '../../helpers/utils';\nimport { sendToProperties } from '../common.description';\n\nexport const description: INodeProperties[] = getSendAndWaitProperties(\n\tsendToProperties,\n\t'message',\n\tundefined,\n\t{\n\t\tnoButtonStyle: true,\n\t\tdefaultApproveLabel: 'âœ“ Approve',\n\t\tdefaultDisapproveLabel: 'âœ— Decline',\n\t},\n).filter((p) => p.name !== 'subject');\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tguildId: string,\n\tuserGuilds: IDataObject[],\n): Promise<INodeExecutionData[]> {\n\tconst items = this.getInputData();\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';\n\n\ttry {\n\t\tawait sendDiscordMessage.call(this, {\n\t\t\tguildId,\n\t\t\tuserGuilds,\n\t\t\tisOAuth2,\n\t\t\tbody: createSendAndWaitMessageBody(this),\n\t\t\titems,\n\t\t});\n\t} catch (error) {\n\t\tconst err = parseDiscordError.call(this, error, 0);\n\n\t\tif (this.continueOnFail()) {\n\t\t\treturn prepareErrorData.call(this, err, 0);\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\treturn items;\n}\n"
          },
          {
            "file": "v2/actions/node.type.ts",
            "content": "import type { AllEntities } from 'n8n-workflow';\n\ntype NodeMap = {\n\tchannel: 'get' | 'getAll' | 'create' | 'update' | 'deleteChannel';\n\tmessage: 'deleteMessage' | 'getAll' | 'get' | 'react' | 'send' | 'sendAndWait';\n\tmember: 'getAll' | 'roleAdd' | 'roleRemove';\n\twebhook: 'sendLegacy';\n};\n\nexport type Discord = AllEntities<NodeMap>;\n"
          },
          {
            "file": "v2/actions/router.ts",
            "content": "import type { IDataObject, IExecuteFunctions, INodeExecutionData } from 'n8n-workflow';\nimport { NodeOperationError, SEND_AND_WAIT_OPERATION } from 'n8n-workflow';\n\nimport * as channel from './channel';\nimport * as member from './member';\nimport * as message from './message';\nimport type { Discord } from './node.type';\nimport * as webhook from './webhook';\nimport { configureWaitTillDate } from '../../../../utils/sendAndWait/configureWaitTillDate.util';\nimport { checkAccessToGuild } from '../helpers/utils';\nimport { discordApiRequest } from '../transport';\n\nexport async function router(this: IExecuteFunctions) {\n\tlet returnData: INodeExecutionData[] = [];\n\n\tlet resource = 'webhook';\n\t//resource parameter is hidden when authentication is set to webhook\n\t//prevent error when getting resource parameter\n\ttry {\n\t\tresource = this.getNodeParameter<Discord>('resource', 0);\n\t} catch (error) {}\n\tconst operation = this.getNodeParameter('operation', 0);\n\n\tlet guildId = '';\n\tlet userGuilds: IDataObject[] = [];\n\n\tif (resource !== 'webhook') {\n\t\tguildId = this.getNodeParameter('guildId', 0, '', {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst isOAuth2 = this.getNodeParameter('authentication', 0, '') === 'oAuth2';\n\n\t\tif (isOAuth2) {\n\t\t\tuserGuilds = (await discordApiRequest.call(\n\t\t\t\tthis,\n\t\t\t\t'GET',\n\t\t\t\t'/users/@me/guilds',\n\t\t\t)) as IDataObject[];\n\n\t\t\tcheckAccessToGuild(this.getNode(), guildId, userGuilds);\n\t\t}\n\t}\n\n\tconst discord = {\n\t\tresource,\n\t\toperation,\n\t} as Discord;\n\n\tif (discord.resource === 'message' && discord.operation === SEND_AND_WAIT_OPERATION) {\n\t\treturnData = await message[discord.operation].execute.call(this, guildId, userGuilds);\n\n\t\tconst waitTill = configureWaitTillDate(this);\n\n\t\tawait this.putExecutionToWait(waitTill);\n\t\treturn [returnData];\n\t}\n\n\tswitch (discord.resource) {\n\t\tcase 'channel':\n\t\t\treturnData = await channel[discord.operation].execute.call(this, guildId, userGuilds);\n\t\t\tbreak;\n\t\tcase 'message':\n\t\t\treturnData = await message[discord.operation].execute.call(this, guildId, userGuilds);\n\t\t\tbreak;\n\t\tcase 'member':\n\t\t\treturnData = await member[discord.operation].execute.call(this, guildId);\n\t\t\tbreak;\n\t\tcase 'webhook':\n\t\t\treturnData = await webhook[discord.operation].execute.call(this);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new NodeOperationError(this.getNode(), `The resource \"${resource}\" is not known`);\n\t}\n\n\treturn [returnData];\n}\n"
          },
          {
            "file": "v2/actions/versionDescription.ts",
            "content": "/* eslint-disable n8n-nodes-base/node-filename-against-convention */\nimport { NodeConnectionTypes, type INodeTypeDescription } from 'n8n-workflow';\n\nimport * as channel from './channel';\nimport * as member from './member';\nimport * as message from './message';\nimport * as webhook from './webhook';\nimport { sendAndWaitWebhooksDescription } from '../../../../utils/sendAndWait/descriptions';\n\nexport const versionDescription: INodeTypeDescription = {\n\tdisplayName: 'Discord',\n\tname: 'discord',\n\ticon: 'file:discord.svg',\n\tgroup: ['output'],\n\tversion: 2,\n\tsubtitle: '={{ $parameter[\"operation\"] + \": \" + $parameter[\"resource\"] }}',\n\tdescription: 'Sends data to Discord',\n\tdefaults: {\n\t\tname: 'Discord',\n\t},\n\tinputs: [NodeConnectionTypes.Main],\n\toutputs: [NodeConnectionTypes.Main],\n\twebhooks: sendAndWaitWebhooksDescription,\n\tcredentials: [\n\t\t{\n\t\t\tname: 'discordBotApi',\n\t\t\trequired: true,\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tauthentication: ['botToken'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'discordOAuth2Api',\n\t\t\trequired: true,\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tauthentication: ['oAuth2'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'discordWebhookApi',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tauthentication: ['webhook'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t],\n\tproperties: [\n\t\t{\n\t\t\tdisplayName: 'Connection Type',\n\t\t\tname: 'authentication',\n\t\t\ttype: 'options',\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Bot Token',\n\t\t\t\t\tvalue: 'botToken',\n\t\t\t\t\tdescription: 'Manage messages, channels, and members on a server',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'OAuth2',\n\t\t\t\t\tvalue: 'oAuth2',\n\t\t\t\t\tdescription: \"Same features as 'Bot Token' with easier Bot installation\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Webhook',\n\t\t\t\t\tvalue: 'webhook',\n\t\t\t\t\tdescription: 'Send messages to a specific channel',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'botToken',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Resource',\n\t\t\tname: 'resource',\n\t\t\ttype: 'options',\n\t\t\tnoDataExpression: true,\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Channel',\n\t\t\t\t\tvalue: 'channel',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Message',\n\t\t\t\t\tvalue: 'message',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Member',\n\t\t\t\t\tvalue: 'member',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'channel',\n\t\t\tdisplayOptions: {\n\t\t\t\thide: {\n\t\t\t\t\tauthentication: ['webhook'],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\t...message.description,\n\t\t...channel.description,\n\t\t...member.description,\n\t\t...webhook.description,\n\t],\n};\n"
          },
          {
            "file": "v2/actions/webhook/index.ts",
            "content": "import type { INodeProperties } from 'n8n-workflow';\n\nimport * as sendLegacy from './sendLegacy.operation';\n\nexport { sendLegacy };\n\nexport const description: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Operation',\n\t\tname: 'operation',\n\t\ttype: 'options',\n\t\tnoDataExpression: true,\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\tauthentication: ['webhook'],\n\t\t\t},\n\t\t},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Send a Message',\n\t\t\t\tvalue: 'sendLegacy',\n\t\t\t\tdescription: 'Send a message to a channel using the webhook',\n\t\t\t\taction: 'Send a message',\n\t\t\t},\n\t\t],\n\t\tdefault: 'sendLegacy',\n\t},\n\t...sendLegacy.description,\n];\n"
          },
          {
            "file": "v2/actions/webhook/sendLegacy.operation.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '../../../../../utils/utilities';\nimport {\n\tparseDiscordError,\n\tprepareEmbeds,\n\tprepareErrorData,\n\tprepareMultiPartForm,\n\tprepareOptions,\n} from '../../helpers/utils';\nimport { discordApiMultiPartRequest, discordApiRequest } from '../../transport';\nimport { embedsFixedCollection, filesFixedCollection } from '../common.description';\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Message',\n\t\tname: 'content',\n\t\ttype: 'string',\n\t\tdefault: '',\n\t\tdescription: 'The content of the message (up to 2000 characters)',\n\t\tplaceholder: 'e.g. My message',\n\t\ttypeOptions: {\n\t\t\trows: 2,\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Avatar URL',\n\t\t\t\tname: 'avatar_url',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'Override the default avatar of the webhook',\n\t\t\t\tplaceholder: 'e.g. https://example.com/image.png',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Flags',\n\t\t\t\tname: 'flags',\n\t\t\t\ttype: 'multiOptions',\n\t\t\t\tdefault: [],\n\t\t\t\tdescription:\n\t\t\t\t\t'Message flags. <a href=\"https://discord.com/developers/docs/resources/channel#message-object-message-flags\" target=\"_blank\">More info</a>.â€.',\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Suppress Embeds',\n\t\t\t\t\t\tvalue: 'SUPPRESS_EMBEDS',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Suppress Notifications',\n\t\t\t\t\t\tvalue: 'SUPPRESS_NOTIFICATIONS',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Text-to-Speech (TTS)',\n\t\t\t\tname: 'tts',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether to have a bot reading the message directly in the channel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Username',\n\t\t\t\tname: 'username',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tdescription: 'Override the default username of the webhook',\n\t\t\t\tplaceholder: 'e.g. My Username',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Wait',\n\t\t\t\tname: 'wait',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription: 'Whether wait for the message to be created before returning its response',\n\t\t\t},\n\t\t],\n\t},\n\tembedsFixedCollection,\n\tfilesFixedCollection,\n];\n\nconst displayOptions = {\n\tshow: {\n\t\toperation: ['sendLegacy'],\n\t},\n\thide: {\n\t\tauthentication: ['botToken', 'oAuth2'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(this: IExecuteFunctions): Promise<INodeExecutionData[]> {\n\tconst returnData: INodeExecutionData[] = [];\n\tconst items = this.getInputData();\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst content = this.getNodeParameter('content', i) as string;\n\t\tconst options = prepareOptions(this.getNodeParameter('options', i, {}));\n\n\t\tconst embeds = (this.getNodeParameter('embeds', i, undefined) as IDataObject)\n\t\t\t?.values as IDataObject[];\n\t\tconst files = (this.getNodeParameter('files', i, undefined) as IDataObject)\n\t\t\t?.values as IDataObject[];\n\n\t\tlet qs: IDataObject | undefined = undefined;\n\n\t\tif (options.wait) {\n\t\t\tqs = {\n\t\t\t\twait: options.wait,\n\t\t\t};\n\n\t\t\tdelete options.wait;\n\t\t}\n\n\t\tconst body: IDataObject = {\n\t\t\tcontent,\n\t\t\t...options,\n\t\t};\n\n\t\tif (embeds) {\n\t\t\tbody.embeds = prepareEmbeds.call(this, embeds);\n\t\t}\n\n\t\ttry {\n\t\t\tlet response: IDataObject[] = [];\n\n\t\t\tif (files?.length) {\n\t\t\t\tconst multiPartBody = await prepareMultiPartForm.call(this, items, files, body, i);\n\n\t\t\t\tresponse = await discordApiMultiPartRequest.call(this, 'POST', '', multiPartBody);\n\t\t\t} else {\n\t\t\t\tresponse = await discordApiRequest.call(this, 'POST', '', body, qs);\n\t\t\t}\n\n\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\tthis.helpers.returnJsonArray(response),\n\t\t\t\t{ itemData: { item: i } },\n\t\t\t);\n\n\t\t\treturnData.push(...executionData);\n\t\t} catch (error) {\n\t\t\tconst err = parseDiscordError.call(this, error, i);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push(...prepareErrorData.call(this, err, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"
          },
          {
            "file": "v2/helpers/utils.ts",
            "content": "import FormData from 'form-data';\nimport isEmpty from 'lodash/isEmpty';\nimport { extension } from 'mime-types';\nimport type {\n\tIBinaryKeyData,\n\tIDataObject,\n\tIExecuteFunctions,\n\tINode,\n\tINodeExecutionData,\n} from 'n8n-workflow';\nimport { jsonParse, NodeApiError, NodeOperationError } from 'n8n-workflow';\n\nimport { getSendAndWaitConfig } from '../../../../utils/sendAndWait/utils';\nimport { capitalize, createUtmCampaignLink } from '../../../../utils/utilities';\nimport { discordApiMultiPartRequest, discordApiRequest } from '../transport';\n\nexport const createSimplifyFunction =\n\t(includedFields: string[]) =>\n\t(item: IDataObject): IDataObject => {\n\t\tconst result: IDataObject = {};\n\n\t\tfor (const field of includedFields) {\n\t\t\tif (item[field] === undefined) continue;\n\n\t\t\tresult[field] = item[field];\n\t\t}\n\n\t\treturn result;\n\t};\n\nexport function parseDiscordError(this: IExecuteFunctions, error: any, itemIndex = 0) {\n\tlet errorData = error.cause.error;\n\tconst errorOptions: IDataObject = { itemIndex };\n\n\tif (!errorData && error.description) {\n\t\ttry {\n\t\t\tconst errorString = (error.description as string).split(' - ')[1];\n\t\t\tif (errorString) {\n\t\t\t\terrorData = jsonParse(errorString);\n\t\t\t}\n\t\t} catch (err) {}\n\t}\n\n\tif (errorData?.message) {\n\t\terrorOptions.message = errorData.message;\n\t}\n\n\tif ((error?.message as string)?.toLowerCase()?.includes('bad request') && errorData) {\n\t\tif (errorData?.message) {\n\t\t\terrorOptions.message = errorData.message;\n\t\t}\n\n\t\tif (errorData?.errors?.embeds) {\n\t\t\tconst embedErrors = errorData.errors.embeds?.[0];\n\t\t\tconst embedErrorsKeys = Object.keys(embedErrors).map((key) => capitalize(key));\n\n\t\t\tif (embedErrorsKeys.length) {\n\t\t\t\tconst message =\n\t\t\t\t\tembedErrorsKeys.length === 1\n\t\t\t\t\t\t? `The parameter ${embedErrorsKeys[0]} is not properly formatted`\n\t\t\t\t\t\t: `The parameters ${embedErrorsKeys.join(', ')} are not properly formatted`;\n\t\t\t\terrorOptions.message = message;\n\t\t\t\terrorOptions.description = 'Review the formatting or clear it';\n\t\t\t}\n\n\t\t\treturn new NodeOperationError(this.getNode(), errorData.errors, errorOptions);\n\t\t}\n\n\t\tif (errorData?.errors?.message_reference) {\n\t\t\terrorOptions.message = \"The message to reply to ID can't be found\";\n\t\t\terrorOptions.description =\n\t\t\t\t'Check the \"Message to Reply to\" parameter and remove it if you don\\'t want to reply to an existing message';\n\n\t\t\treturn new NodeOperationError(this.getNode(), errorData.errors, errorOptions);\n\t\t}\n\n\t\tif (errorOptions.message === 'Cannot send an empty message') {\n\t\t\terrorOptions.description =\n\t\t\t\t'Something has to be send to the channel whether it is a message, an embed or a file';\n\t\t}\n\t}\n\treturn new NodeOperationError(this.getNode(), errorData || error, errorOptions);\n}\n\nexport function prepareErrorData(this: IExecuteFunctions, error: any, i: number) {\n\tlet description = error.description;\n\n\ttry {\n\t\tdescription = JSON.parse(error.description as string);\n\t} catch (err) {}\n\n\treturn this.helpers.constructExecutionMetaData(\n\t\tthis.helpers.returnJsonArray({ error: error.message, description }),\n\t\t{ itemData: { item: i } },\n\t);\n}\n\nexport function prepareOptions(options: IDataObject, guildId?: string) {\n\tif (options.flags) {\n\t\tif ((options.flags as string[]).length === 2) {\n\t\t\toptions.flags = (1 << 2) + (1 << 12);\n\t\t} else if ((options.flags as string[]).includes('SUPPRESS_EMBEDS')) {\n\t\t\toptions.flags = 1 << 2;\n\t\t} else if ((options.flags as string[]).includes('SUPPRESS_NOTIFICATIONS')) {\n\t\t\toptions.flags = 1 << 12;\n\t\t}\n\t}\n\n\tif (options.message_reference) {\n\t\toptions.message_reference = {\n\t\t\tmessage_id: options.message_reference,\n\t\t\tguild_id: guildId,\n\t\t};\n\t}\n\n\treturn options;\n}\n\nexport function prepareEmbeds(this: IExecuteFunctions, embeds: IDataObject[]) {\n\treturn embeds\n\t\t.map((embed) => {\n\t\t\tlet embedReturnData: IDataObject = {};\n\n\t\t\tif (embed.inputMethod === 'json') {\n\t\t\t\tif (typeof embed.json === 'object') {\n\t\t\t\t\tembedReturnData = embed.json as IDataObject;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tembedReturnData = jsonParse(embed.json as string);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Not a valid JSON', error);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdelete embed.inputMethod;\n\n\t\t\t\tfor (const key of Object.keys(embed)) {\n\t\t\t\t\tif (embed[key] !== '') {\n\t\t\t\t\t\tembedReturnData[key] = embed[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (embedReturnData.author) {\n\t\t\t\tembedReturnData.author = {\n\t\t\t\t\tname: embedReturnData.author,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (embedReturnData.color && typeof embedReturnData.color === 'string') {\n\t\t\t\tembedReturnData.color = parseInt(embedReturnData.color.replace('#', ''), 16);\n\t\t\t}\n\t\t\tif (embedReturnData.video) {\n\t\t\t\tembedReturnData.video = {\n\t\t\t\t\turl: embedReturnData.video,\n\t\t\t\t\twidth: 1270,\n\t\t\t\t\theight: 720,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (embedReturnData.thumbnail) {\n\t\t\t\tembedReturnData.thumbnail = {\n\t\t\t\t\turl: embedReturnData.thumbnail,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (embedReturnData.image) {\n\t\t\t\tembedReturnData.image = {\n\t\t\t\t\turl: embedReturnData.image,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn embedReturnData;\n\t\t})\n\t\t.filter((embed) => !isEmpty(embed));\n}\n\nexport async function prepareMultiPartForm(\n\tthis: IExecuteFunctions,\n\titems: INodeExecutionData[],\n\tfiles: IDataObject[],\n\tjsonPayload: IDataObject,\n\ti: number,\n) {\n\tconst multiPartBody = new FormData();\n\tconst attachments: IDataObject[] = [];\n\tconst filesData: IDataObject[] = [];\n\n\tfor (const [index, file] of files.entries()) {\n\t\tconst binaryData = (items[i].binary as IBinaryKeyData)?.[file.inputFieldName as string];\n\n\t\tif (!binaryData) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t`Input item [${i}] does not contain binary data on property ${file.inputFieldName}`,\n\t\t\t);\n\t\t}\n\n\t\tlet filename = binaryData.fileName as string;\n\n\t\tif (!filename.includes('.')) {\n\t\t\tif (binaryData.fileExtension) {\n\t\t\t\tfilename += `.${binaryData.fileExtension}`;\n\t\t\t}\n\t\t\tif (binaryData.mimeType) {\n\t\t\t\tfilename += `.${extension(binaryData.mimeType)}`;\n\t\t\t}\n\t\t}\n\n\t\tattachments.push({\n\t\t\tid: index,\n\t\t\tfilename,\n\t\t});\n\n\t\tfilesData.push({\n\t\t\tdata: await this.helpers.getBinaryDataBuffer(i, file.inputFieldName as string),\n\t\t\tname: filename,\n\t\t\tmime: binaryData.mimeType,\n\t\t});\n\t}\n\n\tmultiPartBody.append('payload_json', JSON.stringify({ ...jsonPayload, attachments }), {\n\t\tcontentType: 'application/json',\n\t});\n\n\tfor (const [index, binaryData] of filesData.entries()) {\n\t\tmultiPartBody.append(`files[${index}]`, binaryData.data, {\n\t\t\tcontentType: binaryData.name as string,\n\t\t\tfilename: binaryData.mime as string,\n\t\t});\n\t}\n\n\treturn multiPartBody;\n}\n\nexport function checkAccessToGuild(\n\tnode: INode,\n\tguildId: string,\n\tuserGuilds: IDataObject[],\n\titemIndex = 0,\n) {\n\tif (!userGuilds.some((guild) => guild.id === guildId)) {\n\t\tthrow new NodeOperationError(\n\t\t\tnode,\n\t\t\t`You do not have access to the guild with the id ${guildId}`,\n\t\t\t{\n\t\t\t\titemIndex,\n\t\t\t\tlevel: 'warning',\n\t\t\t},\n\t\t);\n\t}\n}\n\nexport async function checkAccessToChannel(\n\tthis: IExecuteFunctions,\n\tchannelId: string,\n\tuserGuilds: IDataObject[],\n\titemIndex = 0,\n) {\n\tlet guildId = '';\n\n\ttry {\n\t\tconst channel = await discordApiRequest.call(this, 'GET', `/channels/${channelId}`);\n\t\tguildId = channel.guild_id;\n\t} catch (error) {}\n\n\tif (!guildId) {\n\t\tthrow new NodeOperationError(\n\t\t\tthis.getNode(),\n\t\t\t`Could not find server for channel with the id ${channelId}`,\n\t\t\t{\n\t\t\t\titemIndex,\n\t\t\t},\n\t\t);\n\t}\n\n\tcheckAccessToGuild(this.getNode(), guildId, userGuilds, itemIndex);\n}\n\nexport async function setupChannelGetter(this: IExecuteFunctions, userGuilds: IDataObject[]) {\n\tconst isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';\n\n\treturn async (i: number) => {\n\t\tconst channelId = this.getNodeParameter('channelId', i, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tif (isOAuth2) await checkAccessToChannel.call(this, channelId, userGuilds, i);\n\n\t\treturn channelId;\n\t};\n}\n\nexport async function sendDiscordMessage(\n\tthis: IExecuteFunctions,\n\t{\n\t\tguildId,\n\t\tuserGuilds,\n\t\tisOAuth2,\n\t\tbody,\n\t\titems,\n\t\tfiles = [],\n\t\titemIndex = 0,\n\t}: {\n\t\tguildId: string;\n\t\tuserGuilds: IDataObject[];\n\t\tisOAuth2: boolean;\n\t\tbody: IDataObject;\n\t\titems: INodeExecutionData[];\n\t\tfiles?: IDataObject[];\n\t\titemIndex?: number;\n\t},\n) {\n\tconst sendTo = this.getNodeParameter('sendTo', itemIndex) as string;\n\n\tlet channelId = '';\n\n\tif (sendTo === 'user') {\n\t\tconst userId = this.getNodeParameter('userId', itemIndex, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tif (isOAuth2) {\n\t\t\ttry {\n\t\t\t\tawait discordApiRequest.call(this, 'GET', `/guilds/${guildId}/members/${userId}`);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof NodeApiError && error.httpCode === '404') {\n\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t\t`User with the id ${userId} is not a member of the selected guild`,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthrow new NodeOperationError(this.getNode(), error, {\n\t\t\t\t\titemIndex,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tchannelId = (\n\t\t\t(await discordApiRequest.call(this, 'POST', '/users/@me/channels', {\n\t\t\t\trecipient_id: userId,\n\t\t\t})) as IDataObject\n\t\t).id as string;\n\n\t\tif (!channelId) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\t'Could not create a channel to send direct message to',\n\t\t\t\t{ itemIndex },\n\t\t\t);\n\t\t}\n\t}\n\n\tif (sendTo === 'channel') {\n\t\tchannelId = this.getNodeParameter('channelId', itemIndex, undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\t}\n\n\tif (isOAuth2 && sendTo !== 'user') {\n\t\tawait checkAccessToChannel.call(this, channelId, userGuilds, itemIndex);\n\t}\n\n\tif (!channelId) {\n\t\tthrow new NodeOperationError(this.getNode(), 'Channel ID is required', {\n\t\t\titemIndex,\n\t\t});\n\t}\n\n\tlet response: IDataObject[] = [];\n\n\tif (files?.length) {\n\t\tconst multiPartBody = await prepareMultiPartForm.call(this, items, files, body, itemIndex);\n\n\t\tresponse = await discordApiMultiPartRequest.call(\n\t\t\tthis,\n\t\t\t'POST',\n\t\t\t`/channels/${channelId}/messages`,\n\t\t\tmultiPartBody,\n\t\t);\n\t} else {\n\t\tresponse = await discordApiRequest.call(this, 'POST', `/channels/${channelId}/messages`, body);\n\t}\n\n\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\tthis.helpers.returnJsonArray(response),\n\t\t{ itemData: { item: itemIndex } },\n\t);\n\n\treturn executionData;\n}\n\nexport function createSendAndWaitMessageBody(context: IExecuteFunctions) {\n\tconst config = getSendAndWaitConfig(context);\n\tlet description = config.message;\n\tif (config.appendAttribution !== false) {\n\t\tconst instanceId = context.getInstanceId();\n\t\tconst attributionText = 'This message was sent automatically with ';\n\t\tconst link = createUtmCampaignLink('n8n-nodes-base.discord', instanceId);\n\t\tdescription = `${config.message}\\n\\n_${attributionText}_[n8n](${link})`;\n\t}\n\n\tconst body = {\n\t\tembeds: [\n\t\t\t{\n\t\t\t\tdescription,\n\t\t\t\tcolor: 5814783,\n\t\t\t},\n\t\t],\n\t\tcomponents: [\n\t\t\t{\n\t\t\t\ttype: 1,\n\t\t\t\tcomponents: config.options.map((option) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 2,\n\t\t\t\t\t\tstyle: 5,\n\t\t\t\t\t\tlabel: option.label,\n\t\t\t\t\t\turl: option.url,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t},\n\t\t],\n\t};\n\n\treturn body;\n}\n"
          },
          {
            "file": "v2/methods/index.ts",
            "content": "export * as listSearch from './listSearch';\nexport * as loadOptions from './loadOptions';\n"
          },
          {
            "file": "v2/methods/listSearch.ts",
            "content": "import {\n\ttype IDataObject,\n\ttype ILoadOptionsFunctions,\n\ttype INodeListSearchResult,\n} from 'n8n-workflow';\n\nimport { checkAccessToGuild } from '../helpers/utils';\nimport { discordApiRequest } from '../transport';\n\nasync function getGuildId(this: ILoadOptionsFunctions) {\n\tconst guildId = this.getNodeParameter('guildId', undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', '') === 'oAuth2';\n\n\tif (isOAuth2) {\n\t\tconst userGuilds = (await discordApiRequest.call(\n\t\t\tthis,\n\t\t\t'GET',\n\t\t\t'/users/@me/guilds',\n\t\t)) as IDataObject[];\n\n\t\tcheckAccessToGuild(this.getNode(), guildId, userGuilds);\n\t}\n\n\treturn guildId;\n}\n\nasync function checkBotAccessToGuild(this: ILoadOptionsFunctions, guildId: string, botId: string) {\n\ttry {\n\t\tconst members: Array<{ user: { id: string } }> = await discordApiRequest.call(\n\t\t\tthis,\n\t\t\t'GET',\n\t\t\t`/guilds/${guildId}/members`,\n\t\t\tundefined,\n\t\t\t{ limit: 1000 },\n\t\t);\n\n\t\treturn members.some((member) => member.user.id === botId);\n\t} catch (error) {}\n\n\treturn false;\n}\n\nexport async function guildSearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst response = (await discordApiRequest.call(\n\t\tthis,\n\t\t'GET',\n\t\t'/users/@me/guilds',\n\t)) as IDataObject[];\n\n\tlet guilds: IDataObject[] = [];\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';\n\n\tif (isOAuth2) {\n\t\tconst botId = (await discordApiRequest.call(this, 'GET', '/users/@me')).id as string;\n\n\t\tfor (const guild of response) {\n\t\t\tif (!(await checkBotAccessToGuild.call(this, guild.id as string, botId))) continue;\n\t\t\tguilds.push(guild);\n\t\t}\n\t} else {\n\t\tguilds = response;\n\t}\n\n\treturn {\n\t\tresults: guilds.map((guild) => ({\n\t\t\tname: guild.name as string,\n\t\t\tvalue: guild.id as string,\n\t\t\turl: `https://discord.com/channels/${guild.id}`,\n\t\t})),\n\t};\n}\n\nexport async function channelSearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst guildId = await getGuildId.call(this);\n\tconst response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/channels`);\n\n\treturn {\n\t\tresults: (response as IDataObject[])\n\t\t\t.filter((cannel) => cannel.type !== 4) // Filter out categories\n\t\t\t.map((channel) => ({\n\t\t\t\tname: channel.name as string,\n\t\t\t\tvalue: channel.id as string,\n\t\t\t\turl: `https://discord.com/channels/${guildId}/${channel.id}`,\n\t\t\t})),\n\t};\n}\n\nexport async function textChannelSearch(\n\tthis: ILoadOptionsFunctions,\n): Promise<INodeListSearchResult> {\n\tconst guildId = await getGuildId.call(this);\n\n\tconst response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/channels`);\n\n\treturn {\n\t\tresults: (response as IDataObject[])\n\t\t\t.filter((cannel) => ![2, 4].includes(cannel.type as number)) // Only text channels\n\t\t\t.map((channel) => ({\n\t\t\t\tname: channel.name as string,\n\t\t\t\tvalue: channel.id as string,\n\t\t\t\turl: `https://discord.com/channels/${guildId}/${channel.id}`,\n\t\t\t})),\n\t};\n}\n\nexport async function categorySearch(this: ILoadOptionsFunctions): Promise<INodeListSearchResult> {\n\tconst guildId = await getGuildId.call(this);\n\n\tconst response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/channels`);\n\n\treturn {\n\t\tresults: (response as IDataObject[])\n\t\t\t.filter((cannel) => cannel.type === 4) // Return only categories\n\t\t\t.map((channel) => ({\n\t\t\t\tname: channel.name as string,\n\t\t\t\tvalue: channel.id as string,\n\t\t\t\turl: `https://discord.com/channels/${guildId}/${channel.id}`,\n\t\t\t})),\n\t};\n}\n\nexport async function userSearch(\n\tthis: ILoadOptionsFunctions,\n\t_filter?: string,\n\tpaginationToken?: string,\n): Promise<INodeListSearchResult> {\n\tconst guildId = await getGuildId.call(this);\n\n\tconst limit = 100;\n\tconst qs = { limit, after: paginationToken };\n\n\tconst response = await discordApiRequest.call(\n\t\tthis,\n\t\t'GET',\n\t\t`/guilds/${guildId}/members`,\n\t\tundefined,\n\t\tqs,\n\t);\n\n\tif (response.length === 0) {\n\t\treturn {\n\t\t\tresults: [],\n\t\t\tpaginationToken: undefined,\n\t\t};\n\t}\n\n\tlet lastUserId;\n\n\t//less then limit means that there are no more users to return, so leave lastUserId undefined\n\tif (!(response.length < limit)) {\n\t\tlastUserId = response[response.length - 1].user.id as string;\n\t}\n\n\treturn {\n\t\tresults: (response as Array<{ user: IDataObject }>).map(({ user }) => ({\n\t\t\tname: user.username as string,\n\t\t\tvalue: user.id as string,\n\t\t})),\n\t\tpaginationToken: lastUserId,\n\t};\n}\n"
          },
          {
            "file": "v2/methods/loadOptions.ts",
            "content": "import type { IDataObject, ILoadOptionsFunctions, INodePropertyOptions } from 'n8n-workflow';\n\nimport { checkAccessToGuild } from '../helpers/utils';\nimport { discordApiRequest } from '../transport';\n\nexport async function getRoles(this: ILoadOptionsFunctions): Promise<INodePropertyOptions[]> {\n\tconst guildId = this.getNodeParameter('guildId', undefined, {\n\t\textractValue: true,\n\t}) as string;\n\n\tconst isOAuth2 = this.getNodeParameter('authentication', '') === 'oAuth2';\n\n\tif (isOAuth2) {\n\t\tconst userGuilds = (await discordApiRequest.call(\n\t\t\tthis,\n\t\t\t'GET',\n\t\t\t'/users/@me/guilds',\n\t\t)) as IDataObject[];\n\n\t\tcheckAccessToGuild(this.getNode(), guildId, userGuilds);\n\t}\n\n\tlet response = await discordApiRequest.call(this, 'GET', `/guilds/${guildId}/roles`);\n\n\tconst operations = this.getNodeParameter('operation') as string;\n\n\tif (operations === 'roleRemove') {\n\t\tconst userId = this.getNodeParameter('userId', undefined, {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\tconst userRoles = ((\n\t\t\tawait discordApiRequest.call(this, 'GET', `/guilds/${guildId}/members/${userId}`)\n\t\t).roles || []) as string[];\n\n\t\tresponse = response.filter((role: IDataObject) => {\n\t\t\treturn userRoles.includes(role.id as string);\n\t\t});\n\t}\n\n\treturn response\n\t\t.filter((role: IDataObject) => role.name !== '@everyone' && !role.managed)\n\t\t.map((role: IDataObject) => ({\n\t\t\tname: role.name as string,\n\t\t\tvalue: role.id as string,\n\t\t}));\n}\n"
          },
          {
            "file": "v2/transport/discord.api.ts",
            "content": "import type FormData from 'form-data';\nimport type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tIExecuteSingleFunctions,\n\tIHookFunctions,\n\tIHttpRequestMethods,\n\tILoadOptionsFunctions,\n\tIRequestOptions,\n} from 'n8n-workflow';\nimport { sleep, NodeApiError, jsonParse } from 'n8n-workflow';\n\nimport { getCredentialsType, requestApi } from './helpers';\n\nexport async function discordApiRequest(\n\tthis: IHookFunctions | IExecuteFunctions | IExecuteSingleFunctions | ILoadOptionsFunctions,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tbody?: IDataObject,\n\tqs?: IDataObject,\n) {\n\tconst authentication = this.getNodeParameter('authentication', 0, 'webhook') as string;\n\tconst headers: IDataObject = {};\n\n\tconst credentialType = getCredentialsType(authentication);\n\n\tconst options: IRequestOptions = {\n\t\theaders,\n\t\tmethod,\n\t\tqs,\n\t\tbody,\n\t\turl: `https://discord.com/api/v10${endpoint}`,\n\t\tjson: true,\n\t};\n\n\tif (credentialType === 'discordWebhookApi') {\n\t\tconst credentials = await this.getCredentials('discordWebhookApi');\n\t\toptions.url = credentials.webhookUri as string;\n\t}\n\n\ttry {\n\t\tconst response = await requestApi.call(this, options, credentialType, endpoint);\n\n\t\tconst resetAfter = Number(response.headers['x-ratelimit-reset-after']);\n\t\tconst remaining = Number(response.headers['x-ratelimit-remaining']);\n\n\t\tif (remaining === 0) {\n\t\t\tawait sleep(resetAfter);\n\t\t} else {\n\t\t\tawait sleep(20); //prevent exceeding global rate limit of 50 requests per second\n\t\t}\n\n\t\treturn response.body || { success: true };\n\t} catch (error) {\n\t\tthrow new NodeApiError(this.getNode(), error);\n\t}\n}\n\nexport async function discordApiMultiPartRequest(\n\tthis: IHookFunctions | IExecuteFunctions | IExecuteSingleFunctions | ILoadOptionsFunctions,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tformData: FormData,\n) {\n\tconst headers: IDataObject = {\n\t\t'content-type': 'multipart/form-data; charset=utf-8',\n\t};\n\tconst authentication = this.getNodeParameter('authentication', 0, 'webhook') as string;\n\n\tconst credentialType = getCredentialsType(authentication);\n\n\tconst options: IRequestOptions = {\n\t\theaders,\n\t\tmethod,\n\t\tformData,\n\t\turl: `https://discord.com/api/v10${endpoint}`,\n\t};\n\n\tif (credentialType === 'discordWebhookApi') {\n\t\tconst credentials = await this.getCredentials('discordWebhookApi');\n\t\toptions.url = credentials.webhookUri as string;\n\t}\n\n\ttry {\n\t\tconst response = await requestApi.call(this, options, credentialType, endpoint);\n\n\t\tconst resetAfter = Number(response.headers['x-ratelimit-reset-after']);\n\t\tconst remaining = Number(response.headers['x-ratelimit-remaining']);\n\n\t\tif (remaining === 0) {\n\t\t\tawait sleep(resetAfter);\n\t\t} else {\n\t\t\tawait sleep(20); //prevent exceeding global rate limit of 50 requests per second\n\t\t}\n\n\t\treturn jsonParse<IDataObject[]>(response.body);\n\t} catch (error) {\n\t\tthrow new NodeApiError(this.getNode(), error);\n\t}\n}\n"
          },
          {
            "file": "v2/transport/helpers.ts",
            "content": "import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tIExecuteSingleFunctions,\n\tIHookFunctions,\n\tILoadOptionsFunctions,\n\tIRequestOptions,\n} from 'n8n-workflow';\n\nexport const getCredentialsType = (authentication: string) => {\n\tlet credentialType = '';\n\tswitch (authentication) {\n\t\tcase 'botToken':\n\t\t\tcredentialType = 'discordBotApi';\n\t\t\tbreak;\n\t\tcase 'oAuth2':\n\t\t\tcredentialType = 'discordOAuth2Api';\n\t\t\tbreak;\n\t\tcase 'webhook':\n\t\t\tcredentialType = 'discordWebhookApi';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcredentialType = 'discordBotApi';\n\t}\n\treturn credentialType;\n};\n\nexport async function requestApi(\n\tthis: IHookFunctions | IExecuteFunctions | IExecuteSingleFunctions | ILoadOptionsFunctions,\n\toptions: IRequestOptions,\n\tcredentialType: string,\n\tendpoint: string,\n) {\n\tlet response;\n\tif (credentialType === 'discordOAuth2Api' && endpoint !== '/users/@me/guilds') {\n\t\tconst credentials = await this.getCredentials('discordOAuth2Api');\n\t\t(options.headers as IDataObject).Authorization = `Bot ${credentials.botToken}`;\n\t\tresponse = await this.helpers.request({ ...options, resolveWithFullResponse: true });\n\t} else {\n\t\tresponse = await this.helpers.requestWithAuthentication.call(this, credentialType, {\n\t\t\t...options,\n\t\t\tresolveWithFullResponse: true,\n\t\t});\n\t}\n\treturn response;\n}\n"
          },
          {
            "file": "v2/transport/index.ts",
            "content": "export * from './discord.api';\nexport * from './helpers';\n"
          }
        ]
      },
      "metadata": {
        "fetch_time": "2026-01-06T04:37:52.645104+00:00",
        "source_type": "TYPE1",
        "source_path": "input_sources/discord",
        "file_count": 50,
        "content_hash": "a31752750c0ad872"
      },
      "artifacts": {
        "raw_source": "artifacts/node-discord-v2test3/raw_source.txt",
        "parsed_source": "artifacts/node-discord-v2test3/parsed_source.json",
        "source_bundle": "artifacts/node-discord-v2test3/source_bundle"
      }
    },
    "infer-schema": {
      "inferred_schema": {
        "type": "node",
        "version": 1,
        "description": {
          "displayName": "Node",
          "name": "node",
          "inputs": [
            {
              "name": "main",
              "type": "main"
            }
          ],
          "outputs": [
            {
              "name": "main",
              "type": "main"
            }
          ]
        },
        "properties": {
          "parameters": [
            {
              "name": "operation",
              "type": "OPTIONS",
              "display_name": "Operation",
              "options": [
                {
                  "name": "Send a Message",
                  "value": "sendLegacy",
                  "description": "Send a message to a channel using the webhook"
                },
                {
                  "name": "parseDiscordError",
                  "value": "parseDiscordError",
                  "description": "Operation: parseDiscordError"
                },
                {
                  "name": "prepareErrorData",
                  "value": "prepareErrorData",
                  "description": "Operation: prepareErrorData"
                },
                {
                  "name": "prepareOptions",
                  "value": "prepareOptions",
                  "description": "Operation: prepareOptions"
                },
                {
                  "name": "prepareEmbeds",
                  "value": "prepareEmbeds",
                  "description": "Operation: prepareEmbeds"
                },
                {
                  "name": "prepareMultiPartForm",
                  "value": "prepareMultiPartForm",
                  "description": "Operation: prepareMultiPartForm"
                },
                {
                  "name": "checkAccessToGuild",
                  "value": "checkAccessToGuild",
                  "description": "Operation: checkAccessToGuild"
                },
                {
                  "name": "checkAccessToChannel",
                  "value": "checkAccessToChannel",
                  "description": "Operation: checkAccessToChannel"
                },
                {
                  "name": "setupChannelGetter",
                  "value": "setupChannelGetter",
                  "description": "Operation: setupChannelGetter"
                },
                {
                  "name": "sendDiscordMessage",
                  "value": "sendDiscordMessage",
                  "description": "Operation: sendDiscordMessage"
                },
                {
                  "name": "createSendAndWaitMessageBody",
                  "value": "createSendAndWaitMessageBody",
                  "description": "Operation: createSendAndWaitMessageBody"
                },
                {
                  "name": "getGuildId",
                  "value": "getGuildId",
                  "description": "Operation: getGuildId"
                },
                {
                  "name": "checkBotAccessToGuild",
                  "value": "checkBotAccessToGuild",
                  "description": "Operation: checkBotAccessToGuild"
                },
                {
                  "name": "guildSearch",
                  "value": "guildSearch",
                  "description": "Operation: guildSearch"
                },
                {
                  "name": "channelSearch",
                  "value": "channelSearch",
                  "description": "Operation: channelSearch"
                },
                {
                  "name": "textChannelSearch",
                  "value": "textChannelSearch",
                  "description": "Operation: textChannelSearch"
                },
                {
                  "name": "categorySearch",
                  "value": "categorySearch",
                  "description": "Operation: categorySearch"
                },
                {
                  "name": "userSearch",
                  "value": "userSearch",
                  "description": "Operation: userSearch"
                },
                {
                  "name": "getRoles",
                  "value": "getRoles",
                  "description": "Operation: getRoles"
                },
                {
                  "name": "discordApiRequest",
                  "value": "discordApiRequest",
                  "description": "Operation: discordApiRequest"
                },
                {
                  "name": "discordApiMultiPartRequest",
                  "value": "discordApiMultiPartRequest",
                  "description": "Operation: discordApiMultiPartRequest"
                },
                {
                  "name": "requestApi",
                  "value": "requestApi",
                  "description": "Operation: requestApi"
                }
              ],
              "default": "sendLegacy",
              "description": "Operation to perform"
            },
            {
              "name": "webhookUri",
              "display_name": "Webhook URL",
              "type": "STRING",
              "default": "",
              "required": true
            },
            {
              "name": "text",
              "display_name": "Content",
              "type": "STRING",
              "default": ""
            },
            {
              "name": "options",
              "display_name": "Additional Fields",
              "type": "COLLECTION",
              "default": "{",
              "description": "Whether this message be sent as a Text To Speech message"
            },
            {
              "name": "allowedMentions",
              "display_name": "Allowed Mentions",
              "type": "JSON",
              "default": ""
            },
            {
              "name": "attachments",
              "display_name": "Attachments",
              "type": "JSON",
              "default": ""
            },
            {
              "name": "avatarUrl",
              "display_name": "Avatar URL",
              "type": "STRING",
              "default": ""
            },
            {
              "name": "components",
              "display_name": "Components",
              "type": "JSON",
              "default": ""
            },
            {
              "name": "embeds",
              "display_name": "Embeds",
              "type": "JSON",
              "default": ""
            },
            {
              "name": "flags",
              "display_name": "Flags",
              "type": "NUMBER",
              "default": ""
            },
            {
              "name": "payloadJson",
              "display_name": "JSON Payload",
              "type": "JSON",
              "default": ""
            },
            {
              "name": "username",
              "display_name": "Username",
              "type": "STRING",
              "default": ""
            },
            {
              "name": "tts",
              "display_name": "TTS",
              "type": "BOOLEAN",
              "default": false,
              "description": "Whether this message be sent as a Text To Speech message"
            },
            {
              "name": "authentication",
              "display_name": "Connection Type",
              "type": "OPTIONS",
              "default": "botToken",
              "description": "Manage messages, channels, and members on a server",
              "options": [
                {
                  "name": "Bot Token",
                  "value": "botToken"
                },
                {
                  "name": "OAuth2",
                  "value": "oAuth2"
                },
                {
                  "name": "Webhook",
                  "value": "webhook"
                }
              ]
            },
            {
              "name": "OAuth2",
              "display_name": "Bot Token",
              "type": "OPTIONS",
              "description": "Manage messages, channels, and members on a server"
            }
          ],
          "credentials": [
            "oauth2"
          ]
        },
        "operations": [
          {
            "name": "sendLegacy",
            "display_name": "Send a Message",
            "description": "Send a message to a channel using the webhook"
          },
          {
            "name": "parseDiscordError",
            "description": "Operation: parseDiscordError"
          },
          {
            "name": "prepareErrorData",
            "description": "Operation: prepareErrorData"
          },
          {
            "name": "prepareOptions",
            "description": "Operation: prepareOptions"
          },
          {
            "name": "prepareEmbeds",
            "description": "Operation: prepareEmbeds"
          },
          {
            "name": "prepareMultiPartForm",
            "description": "Operation: prepareMultiPartForm"
          },
          {
            "name": "checkAccessToGuild",
            "description": "Operation: checkAccessToGuild"
          },
          {
            "name": "checkAccessToChannel",
            "description": "Operation: checkAccessToChannel"
          },
          {
            "name": "setupChannelGetter",
            "description": "Operation: setupChannelGetter"
          },
          {
            "name": "sendDiscordMessage",
            "description": "Operation: sendDiscordMessage"
          },
          {
            "name": "createSendAndWaitMessageBody",
            "description": "Operation: createSendAndWaitMessageBody"
          },
          {
            "name": "getGuildId",
            "description": "Operation: getGuildId"
          },
          {
            "name": "checkBotAccessToGuild",
            "description": "Operation: checkBotAccessToGuild"
          },
          {
            "name": "guildSearch",
            "description": "Operation: guildSearch"
          },
          {
            "name": "channelSearch",
            "description": "Operation: channelSearch"
          },
          {
            "name": "textChannelSearch",
            "description": "Operation: textChannelSearch"
          },
          {
            "name": "categorySearch",
            "description": "Operation: categorySearch"
          },
          {
            "name": "userSearch",
            "description": "Operation: userSearch"
          },
          {
            "name": "getRoles",
            "description": "Operation: getRoles"
          },
          {
            "name": "discordApiRequest",
            "description": "Operation: discordApiRequest"
          },
          {
            "name": "discordApiMultiPartRequest",
            "description": "Operation: discordApiMultiPartRequest"
          },
          {
            "name": "requestApi",
            "description": "Operation: requestApi"
          }
        ],
        "resources": [],
        "credentials": [
          "oauth2"
        ]
      },
      "trace_map": {
        "correlation_id": "node-discord-v2test3",
        "node_type": "node",
        "trace_entries": [
          {
            "field_path": "operations[6].name",
            "source": "SOURCE_CODE",
            "evidence": "n8n operation 'sendLegacy' (display: 'Send a Message') in v2/actions/webhook/index.ts",
            "confidence": "high",
            "source_file": "v2/actions/webhook/index.ts",
            "line_range": "L9",
            "excerpt_hash": "fd3cec6eea12"
          },
          {
            "field_path": "operations[1].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'parseDiscordError' defined in v2/helpers/utils.ts",
            "confidence": "high",
            "source_file": "v2/helpers/utils.ts",
            "line_range": "L31",
            "excerpt_hash": "42372fe2e01d"
          },
          {
            "field_path": "operations[2].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'prepareErrorData' defined in v2/helpers/utils.ts",
            "confidence": "high",
            "source_file": "v2/helpers/utils.ts",
            "line_range": "L85",
            "excerpt_hash": "b6633c8b90ae"
          },
          {
            "field_path": "operations[3].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'prepareOptions' defined in v2/helpers/utils.ts",
            "confidence": "high",
            "source_file": "v2/helpers/utils.ts",
            "line_range": "L98",
            "excerpt_hash": "da613906b237"
          },
          {
            "field_path": "operations[4].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'prepareEmbeds' defined in v2/helpers/utils.ts",
            "confidence": "high",
            "source_file": "v2/helpers/utils.ts",
            "line_range": "L119",
            "excerpt_hash": "e5f387c655c2"
          },
          {
            "field_path": "operations[5].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'prepareMultiPartForm' defined in v2/helpers/utils.ts",
            "confidence": "high",
            "source_file": "v2/helpers/utils.ts",
            "line_range": "L174",
            "excerpt_hash": "996c807696ed"
          },
          {
            "field_path": "operations[6].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'checkAccessToGuild' defined in v2/helpers/utils.ts",
            "confidence": "high",
            "source_file": "v2/helpers/utils.ts",
            "line_range": "L232",
            "excerpt_hash": "9701125899e2"
          },
          {
            "field_path": "operations[7].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'checkAccessToChannel' defined in v2/helpers/utils.ts",
            "confidence": "high",
            "source_file": "v2/helpers/utils.ts",
            "line_range": "L250",
            "excerpt_hash": "5e594774dff5"
          },
          {
            "field_path": "operations[8].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'setupChannelGetter' defined in v2/helpers/utils.ts",
            "confidence": "high",
            "source_file": "v2/helpers/utils.ts",
            "line_range": "L276",
            "excerpt_hash": "c9b498a52d11"
          },
          {
            "field_path": "operations[9].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'sendDiscordMessage' defined in v2/helpers/utils.ts",
            "confidence": "high",
            "source_file": "v2/helpers/utils.ts",
            "line_range": "L290",
            "excerpt_hash": "1f5515c2b7c5"
          },
          {
            "field_path": "operations[10].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'createSendAndWaitMessageBody' defined in v2/helpers/utils.ts",
            "confidence": "high",
            "source_file": "v2/helpers/utils.ts",
            "line_range": "L393",
            "excerpt_hash": "331ea5ba48ff"
          },
          {
            "field_path": "operations[11].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'getGuildId' defined in v2/methods/listSearch.ts",
            "confidence": "high",
            "source_file": "v2/methods/listSearch.ts",
            "line_range": "L10",
            "excerpt_hash": "f2f58ca622df"
          },
          {
            "field_path": "operations[12].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'checkBotAccessToGuild' defined in v2/methods/listSearch.ts",
            "confidence": "high",
            "source_file": "v2/methods/listSearch.ts",
            "line_range": "L30",
            "excerpt_hash": "f0669cf1ab4d"
          },
          {
            "field_path": "operations[13].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'guildSearch' defined in v2/methods/listSearch.ts",
            "confidence": "high",
            "source_file": "v2/methods/listSearch.ts",
            "line_range": "L46",
            "excerpt_hash": "b04bf300ebbf"
          },
          {
            "field_path": "operations[14].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'channelSearch' defined in v2/methods/listSearch.ts",
            "confidence": "high",
            "source_file": "v2/methods/listSearch.ts",
            "line_range": "L77",
            "excerpt_hash": "819f0a046606"
          },
          {
            "field_path": "operations[15].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'textChannelSearch' defined in v2/methods/listSearch.ts",
            "confidence": "high",
            "source_file": "v2/methods/listSearch.ts",
            "line_range": "L92",
            "excerpt_hash": "ac9743386f20"
          },
          {
            "field_path": "operations[16].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'categorySearch' defined in v2/methods/listSearch.ts",
            "confidence": "high",
            "source_file": "v2/methods/listSearch.ts",
            "line_range": "L110",
            "excerpt_hash": "4106e9133377"
          },
          {
            "field_path": "operations[17].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'userSearch' defined in v2/methods/listSearch.ts",
            "confidence": "high",
            "source_file": "v2/methods/listSearch.ts",
            "line_range": "L126",
            "excerpt_hash": "9a26f1450f53"
          },
          {
            "field_path": "operations[18].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'getRoles' defined in v2/methods/loadOptions.ts",
            "confidence": "high",
            "source_file": "v2/methods/loadOptions.ts",
            "line_range": "L6",
            "excerpt_hash": "c278e41447fc"
          },
          {
            "field_path": "operations[19].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'discordApiRequest' defined in v2/transport/discord.api.ts",
            "confidence": "high",
            "source_file": "v2/transport/discord.api.ts",
            "line_range": "L15",
            "excerpt_hash": "42374a6a2976"
          },
          {
            "field_path": "operations[20].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'discordApiMultiPartRequest' defined in v2/transport/discord.api.ts",
            "confidence": "high",
            "source_file": "v2/transport/discord.api.ts",
            "line_range": "L59",
            "excerpt_hash": "6517fe6ed0be"
          },
          {
            "field_path": "operations[21].name",
            "source": "SOURCE_CODE",
            "evidence": "Function 'requestApi' defined in v2/transport/helpers.ts",
            "confidence": "high",
            "source_file": "v2/transport/helpers.ts",
            "line_range": "L28",
            "excerpt_hash": "2e2a06acc0d6"
          },
          {
            "field_path": "credentials[0]",
            "source": "SOURCE_CODE",
            "evidence": "Auth pattern 'oauth' found in source",
            "confidence": "medium"
          }
        ],
        "generated_at": "2026-01-06T04:37:52.855502",
        "skill_version": "1.0.0",
        "_hybrid_metadata": {
          "source_type": "TYPE1",
          "extraction_confidence": 0.7374999999999999,
          "advisor_used": false,
          "assumption_ratio": 0.0,
          "deterministic_operations": 23,
          "assumption_operations": 0
        }
      },
      "schema": {
        "type": "node",
        "version": 1,
        "description": {
          "displayName": "Node",
          "name": "node",
          "inputs": [
            {
              "name": "main",
              "type": "main"
            }
          ],
          "outputs": [
            {
              "name": "main",
              "type": "main"
            }
          ]
        },
        "properties": {
          "parameters": [
            {
              "name": "operation",
              "type": "OPTIONS",
              "display_name": "Operation",
              "options": [
                {
                  "name": "Send a Message",
                  "value": "sendLegacy",
                  "description": "Send a message to a channel using the webhook"
                },
                {
                  "name": "parseDiscordError",
                  "value": "parseDiscordError",
                  "description": "Operation: parseDiscordError"
                },
                {
                  "name": "prepareErrorData",
                  "value": "prepareErrorData",
                  "description": "Operation: prepareErrorData"
                },
                {
                  "name": "prepareOptions",
                  "value": "prepareOptions",
                  "description": "Operation: prepareOptions"
                },
                {
                  "name": "prepareEmbeds",
                  "value": "prepareEmbeds",
                  "description": "Operation: prepareEmbeds"
                },
                {
                  "name": "prepareMultiPartForm",
                  "value": "prepareMultiPartForm",
                  "description": "Operation: prepareMultiPartForm"
                },
                {
                  "name": "checkAccessToGuild",
                  "value": "checkAccessToGuild",
                  "description": "Operation: checkAccessToGuild"
                },
                {
                  "name": "checkAccessToChannel",
                  "value": "checkAccessToChannel",
                  "description": "Operation: checkAccessToChannel"
                },
                {
                  "name": "setupChannelGetter",
                  "value": "setupChannelGetter",
                  "description": "Operation: setupChannelGetter"
                },
                {
                  "name": "sendDiscordMessage",
                  "value": "sendDiscordMessage",
                  "description": "Operation: sendDiscordMessage"
                },
                {
                  "name": "createSendAndWaitMessageBody",
                  "value": "createSendAndWaitMessageBody",
                  "description": "Operation: createSendAndWaitMessageBody"
                },
                {
                  "name": "getGuildId",
                  "value": "getGuildId",
                  "description": "Operation: getGuildId"
                },
                {
                  "name": "checkBotAccessToGuild",
                  "value": "checkBotAccessToGuild",
                  "description": "Operation: checkBotAccessToGuild"
                },
                {
                  "name": "guildSearch",
                  "value": "guildSearch",
                  "description": "Operation: guildSearch"
                },
                {
                  "name": "channelSearch",
                  "value": "channelSearch",
                  "description": "Operation: channelSearch"
                },
                {
                  "name": "textChannelSearch",
                  "value": "textChannelSearch",
                  "description": "Operation: textChannelSearch"
                },
                {
                  "name": "categorySearch",
                  "value": "categorySearch",
                  "description": "Operation: categorySearch"
                },
                {
                  "name": "userSearch",
                  "value": "userSearch",
                  "description": "Operation: userSearch"
                },
                {
                  "name": "getRoles",
                  "value": "getRoles",
                  "description": "Operation: getRoles"
                },
                {
                  "name": "discordApiRequest",
                  "value": "discordApiRequest",
                  "description": "Operation: discordApiRequest"
                },
                {
                  "name": "discordApiMultiPartRequest",
                  "value": "discordApiMultiPartRequest",
                  "description": "Operation: discordApiMultiPartRequest"
                },
                {
                  "name": "requestApi",
                  "value": "requestApi",
                  "description": "Operation: requestApi"
                }
              ],
              "default": "sendLegacy",
              "description": "Operation to perform"
            },
            {
              "name": "webhookUri",
              "display_name": "Webhook URL",
              "type": "STRING",
              "default": "",
              "required": true
            },
            {
              "name": "text",
              "display_name": "Content",
              "type": "STRING",
              "default": ""
            },
            {
              "name": "options",
              "display_name": "Additional Fields",
              "type": "COLLECTION",
              "default": "{",
              "description": "Whether this message be sent as a Text To Speech message"
            },
            {
              "name": "allowedMentions",
              "display_name": "Allowed Mentions",
              "type": "JSON",
              "default": ""
            },
            {
              "name": "attachments",
              "display_name": "Attachments",
              "type": "JSON",
              "default": ""
            },
            {
              "name": "avatarUrl",
              "display_name": "Avatar URL",
              "type": "STRING",
              "default": ""
            },
            {
              "name": "components",
              "display_name": "Components",
              "type": "JSON",
              "default": ""
            },
            {
              "name": "embeds",
              "display_name": "Embeds",
              "type": "JSON",
              "default": ""
            },
            {
              "name": "flags",
              "display_name": "Flags",
              "type": "NUMBER",
              "default": ""
            },
            {
              "name": "payloadJson",
              "display_name": "JSON Payload",
              "type": "JSON",
              "default": ""
            },
            {
              "name": "username",
              "display_name": "Username",
              "type": "STRING",
              "default": ""
            },
            {
              "name": "tts",
              "display_name": "TTS",
              "type": "BOOLEAN",
              "default": false,
              "description": "Whether this message be sent as a Text To Speech message"
            },
            {
              "name": "authentication",
              "display_name": "Connection Type",
              "type": "OPTIONS",
              "default": "botToken",
              "description": "Manage messages, channels, and members on a server",
              "options": [
                {
                  "name": "Bot Token",
                  "value": "botToken"
                },
                {
                  "name": "OAuth2",
                  "value": "oAuth2"
                },
                {
                  "name": "Webhook",
                  "value": "webhook"
                }
              ]
            },
            {
              "name": "OAuth2",
              "display_name": "Bot Token",
              "type": "OPTIONS",
              "description": "Manage messages, channels, and members on a server"
            }
          ],
          "credentials": [
            "oauth2"
          ]
        },
        "operations": [
          {
            "name": "sendLegacy",
            "display_name": "Send a Message",
            "description": "Send a message to a channel using the webhook"
          },
          {
            "name": "parseDiscordError",
            "description": "Operation: parseDiscordError"
          },
          {
            "name": "prepareErrorData",
            "description": "Operation: prepareErrorData"
          },
          {
            "name": "prepareOptions",
            "description": "Operation: prepareOptions"
          },
          {
            "name": "prepareEmbeds",
            "description": "Operation: prepareEmbeds"
          },
          {
            "name": "prepareMultiPartForm",
            "description": "Operation: prepareMultiPartForm"
          },
          {
            "name": "checkAccessToGuild",
            "description": "Operation: checkAccessToGuild"
          },
          {
            "name": "checkAccessToChannel",
            "description": "Operation: checkAccessToChannel"
          },
          {
            "name": "setupChannelGetter",
            "description": "Operation: setupChannelGetter"
          },
          {
            "name": "sendDiscordMessage",
            "description": "Operation: sendDiscordMessage"
          },
          {
            "name": "createSendAndWaitMessageBody",
            "description": "Operation: createSendAndWaitMessageBody"
          },
          {
            "name": "getGuildId",
            "description": "Operation: getGuildId"
          },
          {
            "name": "checkBotAccessToGuild",
            "description": "Operation: checkBotAccessToGuild"
          },
          {
            "name": "guildSearch",
            "description": "Operation: guildSearch"
          },
          {
            "name": "channelSearch",
            "description": "Operation: channelSearch"
          },
          {
            "name": "textChannelSearch",
            "description": "Operation: textChannelSearch"
          },
          {
            "name": "categorySearch",
            "description": "Operation: categorySearch"
          },
          {
            "name": "userSearch",
            "description": "Operation: userSearch"
          },
          {
            "name": "getRoles",
            "description": "Operation: getRoles"
          },
          {
            "name": "discordApiRequest",
            "description": "Operation: discordApiRequest"
          },
          {
            "name": "discordApiMultiPartRequest",
            "description": "Operation: discordApiMultiPartRequest"
          },
          {
            "name": "requestApi",
            "description": "Operation: requestApi"
          }
        ],
        "resources": [],
        "credentials": [
          "oauth2"
        ]
      },
      "assumptions": [],
      "artifacts_written": [
        "artifacts/node-discord-v2test3/schema/inferred_schema.json",
        "artifacts/node-discord-v2test3/schema/trace_map.json"
      ],
      "extraction_confidence": 0.7374999999999999,
      "advisor_used": false
    },
    "scaffold": {
      "files_created": [
        "artifacts/node-discord-v2test3/generated_node/discord.py",
        "artifacts/node-discord-v2test3/generated_node/__init__.py"
      ],
      "allowlist": {
        "node_name": "discord",
        "patterns": [
          "nodes/discord*",
          "nodes/discord*",
          "tests/*discord*",
          "tests/*discord*",
          "credentials/*discord*",
          "credentials/*discord*"
        ]
      }
    },
    "convert": {
      "files_modified": [
        "nodes/discord.py"
      ],
      "all_target_files": [
        "nodes/discord.py",
        "nodes/__init__.py"
      ],
      "artifact_paths": [
        "artifacts/node-discord-v2test3/converted/discord.py",
        "artifacts/node-discord-v2test3/converted/__init__.py"
      ],
      "conversion_notes": [
        "Found main node class for Discord",
        "Found 0 operation handlers",
        "Using 15 parameters from inferred schema"
      ],
      "generated_code": {
        "discord.py": "#!/usr/bin/env python3\n\"\"\"\nDiscord Node\n\nConverted from TypeScript by agent-skills/code-convert\nCorrelation ID: node-discord-v2test3\nGenerated: 2026-01-06T04:37:53.282221\n\nSYNC-CELERY SAFE: All methods are synchronous with timeouts.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List\n\nimport requests\n\nfrom .base import BaseNode, NodeParameterType, NodeExecutionData\n\nlogger = logging.getLogger(__name__)\n\n\nclass DiscordNode(BaseNode):\n    \"\"\"\n    Node node.\n    \n    \n    \"\"\"\n\n    type = \"discord\"\n    version = 1\n    \n    description = {\n        \"displayName\": \"Node\",\n        \"name\": \"discord\",\n        \"icon\": \"file:discord.svg\",\n        \"group\": ['output'],\n        \"description\": \"\",\n        \"inputs\": [{\"name\": \"main\", \"type\": \"main\", \"required\": True}],\n        \"outputs\": [{\"name\": \"main\", \"type\": \"main\", \"required\": True}],\n    }\n    \n    properties = {\n        \"parameters\": [\n            {\"name\": \"operation\", \"type\": NodeParameterType.OPTIONS, \"display_name\": \"Operation\", \"options\": [\n                {\"name\": \"Send a Message\", \"value\": \"sendLegacy\", \"description\": \"Send a message to a channel using the webhook\"},\n                {\"name\": \"parseDiscordError\", \"value\": \"parseDiscordError\", \"description\": \"Operation: parseDiscordError\"},\n                {\"name\": \"prepareErrorData\", \"value\": \"prepareErrorData\", \"description\": \"Operation: prepareErrorData\"},\n                {\"name\": \"prepareOptions\", \"value\": \"prepareOptions\", \"description\": \"Operation: prepareOptions\"},\n                {\"name\": \"prepareEmbeds\", \"value\": \"prepareEmbeds\", \"description\": \"Operation: prepareEmbeds\"},\n                {\"name\": \"prepareMultiPartForm\", \"value\": \"prepareMultiPartForm\", \"description\": \"Operation: prepareMultiPartForm\"},\n                {\"name\": \"checkAccessToGuild\", \"value\": \"checkAccessToGuild\", \"description\": \"Operation: checkAccessToGuild\"},\n                {\"name\": \"checkAccessToChannel\", \"value\": \"checkAccessToChannel\", \"description\": \"Operation: checkAccessToChannel\"},\n                {\"name\": \"setupChannelGetter\", \"value\": \"setupChannelGetter\", \"description\": \"Operation: setupChannelGetter\"},\n                {\"name\": \"sendDiscordMessage\", \"value\": \"sendDiscordMessage\", \"description\": \"Operation: sendDiscordMessage\"},\n                {\"name\": \"createSendAndWaitMessageBody\", \"value\": \"createSendAndWaitMessageBody\", \"description\": \"Operation: createSendAndWaitMessageBody\"},\n                {\"name\": \"getGuildId\", \"value\": \"getGuildId\", \"description\": \"Operation: getGuildId\"},\n                {\"name\": \"checkBotAccessToGuild\", \"value\": \"checkBotAccessToGuild\", \"description\": \"Operation: checkBotAccessToGuild\"},\n                {\"name\": \"guildSearch\", \"value\": \"guildSearch\", \"description\": \"Operation: guildSearch\"},\n                {\"name\": \"channelSearch\", \"value\": \"channelSearch\", \"description\": \"Operation: channelSearch\"},\n                {\"name\": \"textChannelSearch\", \"value\": \"textChannelSearch\", \"description\": \"Operation: textChannelSearch\"},\n                {\"name\": \"categorySearch\", \"value\": \"categorySearch\", \"description\": \"Operation: categorySearch\"},\n                {\"name\": \"userSearch\", \"value\": \"userSearch\", \"description\": \"Operation: userSearch\"},\n                {\"name\": \"getRoles\", \"value\": \"getRoles\", \"description\": \"Operation: getRoles\"},\n                {\"name\": \"discordApiRequest\", \"value\": \"discordApiRequest\", \"description\": \"Operation: discordApiRequest\"},\n                {\"name\": \"discordApiMultiPartRequest\", \"value\": \"discordApiMultiPartRequest\", \"description\": \"Operation: discordApiMultiPartRequest\"},\n                {\"name\": \"requestApi\", \"value\": \"requestApi\", \"description\": \"Operation: requestApi\"}\n            ], \"default\": \"sendLegacy\", \"description\": \"Operation to perform\"},\n            {\"name\": \"webhookUri\", \"type\": NodeParameterType.STRING, \"display_name\": \"Webhook URL\", \"default\": \"\", \"required\": True},\n            {\"name\": \"text\", \"type\": NodeParameterType.STRING, \"display_name\": \"Content\", \"default\": \"\"},\n            {\"name\": \"options\", \"type\": NodeParameterType.COLLECTION, \"display_name\": \"Additional Fields\", \"default\": \"{\", \"description\": \"Whether this message be sent as a Text To Speech message\"},\n            {\"name\": \"allowedMentions\", \"type\": NodeParameterType.JSON, \"display_name\": \"Allowed Mentions\", \"default\": \"\"},\n            {\"name\": \"attachments\", \"type\": NodeParameterType.JSON, \"display_name\": \"Attachments\", \"default\": \"\"},\n            {\"name\": \"avatarUrl\", \"type\": NodeParameterType.STRING, \"display_name\": \"Avatar URL\", \"default\": \"\"},\n            {\"name\": \"components\", \"type\": NodeParameterType.JSON, \"display_name\": \"Components\", \"default\": \"\"},\n            {\"name\": \"embeds\", \"type\": NodeParameterType.JSON, \"display_name\": \"Embeds\", \"default\": \"\"},\n            {\"name\": \"flags\", \"type\": NodeParameterType.NUMBER, \"display_name\": \"Flags\", \"default\": \"\"},\n            {\"name\": \"payloadJson\", \"type\": NodeParameterType.JSON, \"display_name\": \"JSON Payload\", \"default\": \"\"},\n            {\"name\": \"username\", \"type\": NodeParameterType.STRING, \"display_name\": \"Username\", \"default\": \"\"},\n            {\"name\": \"tts\", \"type\": NodeParameterType.BOOLEAN, \"display_name\": \"TTS\", \"default\": False, \"description\": \"Whether this message be sent as a Text To Speech message\"},\n            {\"name\": \"authentication\", \"type\": NodeParameterType.OPTIONS, \"display_name\": \"Connection Type\", \"options\": [\n                {\"name\": \"Bot Token\", \"value\": \"botToken\"},\n                {\"name\": \"OAuth2\", \"value\": \"oAuth2\"},\n                {\"name\": \"Webhook\", \"value\": \"webhook\"}\n            ], \"default\": \"botToken\", \"description\": \"Manage messages, channels, and members on a server\"},\n            {\"name\": \"OAuth2\", \"type\": NodeParameterType.OPTIONS, \"display_name\": \"Bot Token\", \"description\": \"Manage messages, channels, and members on a server\"}\n        ],\n        \"credentials\": [\n            {\"name\": \"oauth2\", \"required\": True}\n        ]\n    }\n    \n    icon = \"discord.svg\"\n\n    def execute(self) -> List[List[NodeExecutionData]]:\n        \"\"\"\n        Execute the node operations.\n        \n        SYNC-CELERY SAFE: All HTTP calls use timeout parameter.\n        \n        Returns:\n            List[List[NodeExecutionData]]: Nested list where outer list is output branches,\n            inner list is items in that branch.\n        \"\"\"\n        # Get input data from previous node\n        input_data = self.get_input_data()\n        \n        # Handle empty input\n        if not input_data:\n            return [[]]\n        \n        return_items: List[NodeExecutionData] = []\n\n        for i, item in enumerate(input_data):\n            try:\n                operation = self.get_node_parameter(\"operation\", i)\n                item_data = item.json_data if hasattr(item, 'json_data') else item.get('json', {})\n                \n                if operation == \"sendLegacy\":\n                    result = self._sendLegacy(i, item_data)\n                elif operation == \"parseDiscordError\":\n                    result = self._parseDiscordError(i, item_data)\n                elif operation == \"prepareErrorData\":\n                    result = self._prepareErrorData(i, item_data)\n                elif operation == \"prepareOptions\":\n                    result = self._prepareOptions(i, item_data)\n                elif operation == \"prepareEmbeds\":\n                    result = self._prepareEmbeds(i, item_data)\n                elif operation == \"prepareMultiPartForm\":\n                    result = self._prepareMultiPartForm(i, item_data)\n                elif operation == \"checkAccessToGuild\":\n                    result = self._checkAccessToGuild(i, item_data)\n                elif operation == \"checkAccessToChannel\":\n                    result = self._checkAccessToChannel(i, item_data)\n                elif operation == \"setupChannelGetter\":\n                    result = self._setupChannelGetter(i, item_data)\n                elif operation == \"sendDiscordMessage\":\n                    result = self._sendDiscordMessage(i, item_data)\n                elif operation == \"createSendAndWaitMessageBody\":\n                    result = self._createSendAndWaitMessageBody(i, item_data)\n                elif operation == \"getGuildId\":\n                    result = self._getGuildId(i, item_data)\n                elif operation == \"checkBotAccessToGuild\":\n                    result = self._checkBotAccessToGuild(i, item_data)\n                elif operation == \"guildSearch\":\n                    result = self._guildSearch(i, item_data)\n                elif operation == \"channelSearch\":\n                    result = self._channelSearch(i, item_data)\n                elif operation == \"textChannelSearch\":\n                    result = self._textChannelSearch(i, item_data)\n                elif operation == \"categorySearch\":\n                    result = self._categorySearch(i, item_data)\n                elif operation == \"userSearch\":\n                    result = self._userSearch(i, item_data)\n                elif operation == \"getRoles\":\n                    result = self._getRoles(i, item_data)\n                elif operation == \"discordApiRequest\":\n                    result = self._discordApiRequest(i, item_data)\n                elif operation == \"discordApiMultiPartRequest\":\n                    result = self._discordApiMultiPartRequest(i, item_data)\n                elif operation == \"requestApi\":\n                    result = self._requestApi(i, item_data)\n                else:\n                    raise ValueError(f\"Unknown operation: {operation}\")\n                \n                # Handle array results\n                if isinstance(result, list):\n                    for r in result:\n                        return_items.append(NodeExecutionData(json_data=r))\n                else:\n                    return_items.append(NodeExecutionData(json_data=result))\n                    \n            except Exception as e:\n                logger.error(f\"Error in operation {operation}: {e}\")\n                if self.continue_on_fail:\n                    return_items.append(NodeExecutionData(json_data={\"error\": str(e)}))\n                else:\n                    raise\n        \n        return [return_items]\n\n    def _api_request(\n        self,\n        method: str,\n        endpoint: str,\n        body: Dict[str, Any] | None = None,\n        query: Dict[str, Any] | None = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Make authenticated API request.\n        \n        SYNC-CELERY SAFE: Uses requests with timeout.\n        \"\"\"\n        credentials = self.get_credentials(\"oauth2\")\n        \n        # Build headers based on credential type\n        headers = {}\n        if credentials.get(\"accessToken\"):\n            headers[\"Authorization\"] = f\"Bot {credentials.get('accessToken')}\"\n        elif credentials.get(\"apiKey\"):\n            query = query or {}\n            query[\"api_key\"] = credentials.get(\"apiKey\")\n        \n        url = f\"https://api.example.com{endpoint}\"\n        \n        response = requests.request(\n            method,\n            url,\n            params=query,\n            json=body,\n            headers=headers,\n            timeout=30,  # REQUIRED for Celery\n        )\n        response.raise_for_status()\n        return response.json()\n\n    def _sendLegacy(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        sendLegacy operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"sendLegacy operation not implemented\")\n\n    def _parseDiscordError(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        parseDiscordError operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"parseDiscordError operation not implemented\")\n\n    def _prepareErrorData(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        prepareErrorData operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"prepareErrorData operation not implemented\")\n\n    def _prepareOptions(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        prepareOptions operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"prepareOptions operation not implemented\")\n\n    def _prepareEmbeds(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        prepareEmbeds operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"prepareEmbeds operation not implemented\")\n\n    def _prepareMultiPartForm(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        prepareMultiPartForm operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"prepareMultiPartForm operation not implemented\")\n\n    def _checkAccessToGuild(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        checkAccessToGuild operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"checkAccessToGuild operation not implemented\")\n\n    def _checkAccessToChannel(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        checkAccessToChannel operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"checkAccessToChannel operation not implemented\")\n\n    def _setupChannelGetter(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        setupChannelGetter operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"setupChannelGetter operation not implemented\")\n\n    def _sendDiscordMessage(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        sendDiscordMessage operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"sendDiscordMessage operation not implemented\")\n\n    def _createSendAndWaitMessageBody(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        createSendAndWaitMessageBody operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"createSendAndWaitMessageBody operation not implemented\")\n\n    def _getGuildId(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        getGuildId operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"getGuildId operation not implemented\")\n\n    def _checkBotAccessToGuild(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        checkBotAccessToGuild operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"checkBotAccessToGuild operation not implemented\")\n\n    def _guildSearch(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        guildSearch operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"guildSearch operation not implemented\")\n\n    def _channelSearch(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        channelSearch operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"channelSearch operation not implemented\")\n\n    def _textChannelSearch(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        textChannelSearch operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"textChannelSearch operation not implemented\")\n\n    def _categorySearch(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        categorySearch operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"categorySearch operation not implemented\")\n\n    def _userSearch(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        userSearch operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"userSearch operation not implemented\")\n\n    def _getRoles(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        getRoles operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"getRoles operation not implemented\")\n\n    def _discordApiRequest(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        discordApiRequest operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"discordApiRequest operation not implemented\")\n\n    def _discordApiMultiPartRequest(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        discordApiMultiPartRequest operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"discordApiMultiPartRequest operation not implemented\")\n\n    def _requestApi(self, item_index: int, item_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        requestApi operation.\n        \n        Args:\n            item_index: Index of the current item being processed\n            item_data: JSON data from the input item\n            \n        Returns:\n            Dict with operation result\n            \n        TODO: Implement operation logic.\n        \"\"\"\n        # TODO: Extract parameters using item_index\n        # param = self.get_node_parameter(\"paramName\", item_index)\n        \n        # TODO: Make API call\n        # response = self._api_request(\"GET\", \"/endpoint\", query={\"param\": param})\n        \n        raise NotImplementedError(\"requestApi operation not implemented\")\n\n",
        "__init__.py": "\"\"\"\nDiscord Node Package\nConverted from TypeScript by agent-skills/code-convert\n\"\"\"\n\nfrom .discord import DiscordNode\n\n__all__ = [\"DiscordNode\"]\n"
      }
    },
    "package": {
      "package_dir": "artifacts/node-discord-v2test3/package",
      "files": [
        {
          "filename": "discord.py",
          "source_path": "artifacts/node-discord-v2test3/converted/__init__.py",
          "target_path": "nodes/discord.py",
          "is_test": false
        },
        {
          "filename": "discord.py",
          "source_path": "artifacts/node-discord-v2test3/converted/discord.py",
          "target_path": "nodes/discord.py",
          "is_test": false
        }
      ],
      "registry_entry": {
        "import_statement": "from .discord import DiscordNode",
        "dict_entry": "'discord': {'node_class': DiscordNode, 'type': 'regular'}",
        "node_type": "discord",
        "node_class": "DiscordNode",
        "module_name": "discord"
      },
      "manifest": {
        "correlation_id": "node-discord-v2test3",
        "node_type": "discord",
        "node_class": "DiscordNode",
        "registry_strategy": "dict_import",
        "files": [
          {
            "filename": "discord.py",
            "target_path": "nodes/discord.py",
            "checksum": "b43fce5d968a5ea7",
            "size_bytes": 145
          },
          {
            "filename": "discord.py",
            "target_path": "nodes/discord.py",
            "checksum": "f9702e251db99b55",
            "size_bytes": 27804
          }
        ],
        "registry_entry": {
          "import_statement": "from .discord import DiscordNode",
          "dict_entry": "'discord': {'node_class': DiscordNode, 'type': 'regular'}",
          "node_type": "discord",
          "node_class": "DiscordNode",
          "module_name": "discord"
        }
      }
    },
    "pre-validate": {
      "valid": true,
      "checks": [
        {
          "name": "[discord.py] Syntax",
          "passed": true,
          "details": "Syntax valid"
        },
        {
          "name": "[discord.py] AST",
          "passed": true,
          "details": "AST parsed successfully"
        },
        {
          "name": "[discord.py] Imports",
          "passed": true,
          "details": "Found 5 imports"
        },
        {
          "name": "[discord.py] Sync Celery",
          "passed": true,
          "details": "No async patterns detected"
        },
        {
          "name": "[discord.py] Node Class",
          "passed": true,
          "details": "Valid node class: DiscordNode"
        },
        {
          "name": "[discord.py] Timeouts",
          "passed": false,
          "details": "HTTP call 'get' at line 199 missing timeout; HTTP call 'get' at line 201 missing timeout; HTTP call 'get' at line 203 missing timeout; HTTP call 'get' at line 118 missing timeout; HTTP call 'get' at line 200 missing timeout"
        }
      ],
      "errors": [],
      "warnings": [
        "[discord.py] HTTP call 'get' at line 199 missing timeout; HTTP call 'get' at line 201 missing timeout; HTTP call 'get' at line 203 missing timeout; HTTP call 'get' at line 118 missing timeout; HTTP call 'get' at line 200 missing timeout"
      ]
    },
    "apply": {},
    "smoke-test": {}
  },
  "artifacts_dir": "artifacts/node-discord-v2test3",
  "errors": [
    "Step 'scaffold' blocked by gate"
  ]
}