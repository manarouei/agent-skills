// === File: GenericFunctions.ts ===
import type {
	IExecuteFunctions,
	IHookFunctions,
	IDataObject,
	ILoadOptionsFunctions,
	JsonObject,
	IHttpRequestMethods,
	IRequestOptions,
} from 'n8n-workflow';
import { NodeApiError, NodeOperationError } from 'n8n-workflow';

/**
 * Make an API request to Github
 *
 */
export async function githubApiRequest(
	this: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions,
	method: IHttpRequestMethods,
	endpoint: string,
	body: object,
	query?: IDataObject,
	option: IDataObject = {},
): Promise<any> {
	const options: IRequestOptions = {
		method,
		headers: {
			'User-Agent': 'n8n',
		},
		body,
		qs: query,
		uri: '',
		json: true,
	};

	if (Object.keys(option).length !== 0) {
		Object.assign(options, option);
	}

	try {
		const authenticationMethod = this.getNodeParameter(
			'authentication',
			0,
			'accessToken',
		) as string;
		let credentialType = '';

		if (authenticationMethod === 'accessToken') {
			const credentials = await this.getCredentials('githubApi');
			credentialType = 'githubApi';

			const baseUrl = credentials.server || 'https://api.github.com';
			options.uri = `${baseUrl}${endpoint}`;
		} else {
			const credentials = await this.getCredentials('githubOAuth2Api');
			credentialType = 'githubOAuth2Api';

			const baseUrl = credentials.server || 'https://api.github.com';
			options.uri = `${baseUrl}${endpoint}`;
		}

		return await this.helpers.requestWithAuthentication.call(this, credentialType, options);
	} catch (error) {
		throw new NodeApiError(this.getNode(), error as JsonObject);
	}
}

/**
 * Returns the SHA of the given file
 *
 * @param {(IHookFunctions | IExecuteFunctions)} this
 */
export async function getFileSha(
	this: IHookFunctions | IExecuteFunctions,
	owner: string,
	repository: string,
	filePath: string,
	branch?: string,
): Promise<any> {
	const query: IDataObject = {};
	if (branch !== undefined) {
		query.ref = branch;
	}

	const getEndpoint = `/repos/${owner}/${repository}/contents/${encodeURI(filePath)}`;
	const responseData = await githubApiRequest.call(this, 'GET', getEndpoint, {}, query);

	if (responseData.sha === undefined) {
		throw new NodeOperationError(this.getNode(), 'Could not get the SHA of the file.');
	}
	return responseData.sha;
}

export async function githubApiRequestAllItems(
	this: IHookFunctions | IExecuteFunctions,
	method: IHttpRequestMethods,
	endpoint: string,

	body: any = {},
	query: IDataObject = {},
): Promise<any> {
	const returnData: IDataObject[] = [];

	let responseData;

	query.per_page = 100;
	query.page = 1;

	do {
		responseData = await githubApiRequest.call(this, method, endpoint, body as IDataObject, query, {
			resolveWithFullResponse: true,
		});
		query.page++;
		returnData.push.apply(returnData, responseData.body as IDataObject[]);
	} while (responseData.headers.link?.includes('next'));
	return returnData;
}

export function isBase64(content: string) {
	const base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
	return base64regex.test(content);
}

export function validateJSON(json: string | undefined): any {
	let result;
	try {
		result = JSON.parse(json!);
	} catch (exception) {
		result = undefined;
	}
	return result;
}


// === File: Github.node.ts ===
import { snakeCase } from 'change-case';
import type {
	IDataObject,
	IExecuteFunctions,
	IHttpRequestMethods,
	INodeExecutionData,
	INodeType,
	INodeTypeDescription,
	IWebhookFunctions,
	IWebhookResponseData,
	JsonObject,
} from 'n8n-workflow';
import {
	NodeApiError,
	NodeConnectionTypes,
	NodeOperationError,
	WAIT_INDEFINITELY,
} from 'n8n-workflow';

import {
	getFileSha,
	githubApiRequest,
	githubApiRequestAllItems,
	isBase64,
	validateJSON,
} from './GenericFunctions';
import { getRefs, getRepositories, getUsers, getWorkflows } from './SearchFunctions';
import { removeTrailingSlash } from '../../utils/utilities';
import { defaultWebhookDescription } from '../Webhook/description';

export class Github implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'GitHub',
		name: 'github',
		icon: {
			light: 'file:github.svg',
			dark: 'file:github.dark.svg',
		},
		group: ['input'],
		version: [1, 1.1],
		subtitle: '={{$parameter["operation"] + ": " + $parameter["resource"]}}',
		description: 'Consume GitHub API',
		defaults: {
			name: 'GitHub',
		},
		usableAsTool: true,
		inputs: [NodeConnectionTypes.Main],
		outputs: [NodeConnectionTypes.Main],
		webhooks: [
			{
				...defaultWebhookDescription,
				path: '',
				restartWebhook: true,
				httpMethod: 'POST',
				responseMode: 'onReceived',
			},
		],
		credentials: [
			{
				name: 'githubApi',
				required: true,
				displayOptions: {
					show: {
						authentication: ['accessToken'],
					},
				},
			},
			{
				name: 'githubOAuth2Api',
				required: true,
				displayOptions: {
					show: {
						authentication: ['oAuth2'],
					},
				},
			},
		],
		properties: [
			{
				displayName: 'Authentication',
				name: 'authentication',
				type: 'options',
				options: [
					{
						name: 'Access Token',
						value: 'accessToken',
					},
					{
						name: 'OAuth2',
						value: 'oAuth2',
					},
				],
				default: 'accessToken',
			},
			{
				displayName: 'Resource',
				name: 'resource',
				type: 'options',
				noDataExpression: true,
				options: [
					{
						name: 'File',
						value: 'file',
					},
					{
						name: 'Issue',
						value: 'issue',
					},
					{
						name: 'Organization',
						value: 'organization',
					},
					{
						name: 'Release',
						value: 'release',
					},
					{
						name: 'Repository',
						value: 'repository',
					},
					{
						name: 'Review',
						value: 'review',
					},
					{
						name: 'User',
						value: 'user',
					},
					{
						name: 'Workflow',
						value: 'workflow',
					},
				],
				default: 'issue',
			},

			// ----------------------------------
			//         operations
			// ----------------------------------
			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				displayOptions: {
					show: {
						resource: ['organization'],
					},
				},
				options: [
					{
						name: 'Get Repositories',
						value: 'getRepositories',
						description: 'Returns all repositories of an organization',
						action: 'Get repositories for an organization',
					},
				],
				default: 'getRepositories',
			},

			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				displayOptions: {
					show: {
						resource: ['issue'],
					},
				},
				options: [
					{
						name: 'Create',
						value: 'create',
						description: 'Create a new issue',
						action: 'Create an issue',
					},
					{
						name: 'Create Comment',
						value: 'createComment',
						description: 'Create a new comment on an issue',
						action: 'Create a comment on an issue',
					},
					{
						name: 'Edit',
						value: 'edit',
						description: 'Edit an issue',
						action: 'Edit an issue',
					},
					{
						name: 'Get',
						value: 'get',
						description: 'Get the data of a single issue',
						action: 'Get an issue',
					},
					{
						name: 'Lock',
						value: 'lock',
						description: 'Lock an issue',
						action: 'Lock an issue',
					},
				],
				default: 'create',
			},

			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				displayOptions: {
					show: {
						resource: ['file'],
					},
				},
				options: [
					{
						name: 'Create',
						value: 'create',
						description: 'Create a new file in repository',
						action: 'Create a file',
					},
					{
						name: 'Delete',
						value: 'delete',
						description: 'Delete a file in repository',
						action: 'Delete a file',
					},
					{
						name: 'Edit',
						value: 'edit',
						description: 'Edit a file in repository',
						action: 'Edit a file',
					},
					{
						name: 'Get',
						value: 'get',
						description: 'Get the data of a single file',
						action: 'Get a file',
					},
					{
						name: 'List',
						value: 'list',
						description: 'List contents of a folder',
						action: 'List files',
					},
				],
				default: 'create',
			},

			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				displayOptions: {
					show: {
						resource: ['repository'],
					},
				},
				options: [
					{
						name: 'Get',
						value: 'get',
						description: 'Get the data of a single repository',
						action: 'Get a repository',
					},
					{
						name: 'Get Issues',
						value: 'getIssues',
						description: 'Returns issues of a repository',
						action: 'Get issues of a repository',
					},
					{
						name: 'Get License',
						value: 'getLicense',
						description:
							"Returns the contents of the repository's license file, if one is detected",
						action: 'Get the license of a repository',
					},
					{
						name: 'Get Profile',
						value: 'getProfile',
						description:
							'Get the community profile of a repository with metrics, health score, description, license, etc',
						action: 'Get the profile of a repository',
					},
					{
						name: 'Get Pull Requests',
						value: 'getPullRequests',
						description: 'Returns pull requests of a repository',
						action: 'Get pull requests of a repository',
					},
					{
						name: 'List Popular Paths',
						value: 'listPopularPaths',
						description: 'Get the top 10 popular content paths over the last 14 days',
						action: 'List popular paths in a repository',
					},
					{
						name: 'List Referrers',
						value: 'listReferrers',
						description: 'Get the top 10 referrering domains over the last 14 days',
						action: 'List the top referrers of a repository',
					},
				],
				default: 'getIssues',
			},

			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				displayOptions: {
					show: {
						resource: ['user'],
					},
				},
				options: [
					{
						name: 'Get Repositories',
						value: 'getRepositories',
						description: 'Returns the repositories of a user',
						action: "Get a user's repositories",
					},
					{
						name: 'Invite',
						value: 'invite',
						description: 'Invites a user to an organization',
						action: 'Invite a user',
					},
				],
				default: 'getRepositories',
			},

			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				displayOptions: {
					show: {
						resource: ['release'],
					},
				},
				options: [
					{
						name: 'Create',
						value: 'create',
						description: 'Creates a new release',
						action: 'Create a release',
					},
					{
						name: 'Delete',
						value: 'delete',
						description: 'Delete a release',
						action: 'Delete a release',
					},
					{
						name: 'Get',
						value: 'get',
						description: 'Get a release',
						action: 'Get a release',
					},
					{
						name: 'Get Many',
						value: 'getAll',
						description: 'Get many repository releases',
						action: 'Get many releases',
					},
					{
						name: 'Update',
						value: 'update',
						description: 'Update a release',
						action: 'Update a release',
					},
				],
				default: 'create',
			},

			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				displayOptions: {
					show: {
						resource: ['review'],
					},
				},
				options: [
					{
						name: 'Create',
						value: 'create',
						description: 'Creates a new review',
						action: 'Create a review',
					},
					{
						name: 'Get',
						value: 'get',
						description: 'Get a review for a pull request',
						action: 'Get a review',
					},
					{
						name: 'Get Many',
						value: 'getAll',
						description: 'Get many reviews for a pull request',
						action: 'Get many reviews',
					},
					{
						name: 'Update',
						value: 'update',
						description: 'Update a review',
						action: 'Update a review',
					},
				],
				default: 'create',
			},

			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				displayOptions: {
					show: {
						resource: ['workflow'],
					},
				},
				options: [
					{
						name: 'Disable',
						value: 'disable',
						description: 'Disable a workflow',
						action: 'Disable a workflow',
					},
					{
						name: 'Dispatch',
						value: 'dispatch',
						description: 'Dispatch a workflow event',
						action: 'Dispatch a workflow event',
					},
					{
						name: 'Dispatch and Wait for Completion',
						value: 'dispatchAndWait',
						description:
							'Dispatch a workflow event and wait for a webhook to be called before proceeding',
						action: 'Dispatch a workflow event and wait for completion',
					},
					{
						name: 'Enable',
						value: 'enable',
						description: 'Enable a workflow',
						action: 'Enable a workflow',
					},
					{
						name: 'Get',
						value: 'get',
						description: 'Get a workflow',
						action: 'Get a workflow',
					},
					{
						name: 'Get Usage',
						value: 'getUsage',
						description: 'Get the usage of a workflow',
						action: 'Get the usage of a workflow',
					},
					{
						name: 'List',
						value: 'list',
						description: 'List workflows',
						action: 'List workflows',
					},
				],
				default: 'dispatch',
			},
			{
				displayName:
					'Your execution will pause until a webhook is called. This URL will be generated at runtime and passed to your Github workflow as a resumeUrl input.',
				name: 'webhookNotice',
				type: 'notice',
				displayOptions: {
					show: {
						resource: ['workflow'],
						operation: ['dispatchAndWait'],
					},
				},
				default: '',
			},

			// ----------------------------------
			//         shared
			// ----------------------------------
			{
				displayName: 'Repository Owner',
				name: 'owner',
				type: 'resourceLocator',
				default: { mode: 'list', value: '' },
				required: true,
				modes: [
					{
						displayName: 'Repository Owner',
						name: 'list',
						type: 'list',
						placeholder: 'Select an owner...',
						typeOptions: {
							searchListMethod: 'getUsers',
							searchable: true,
							searchFilterRequired: false,
						},
					},
					{
						displayName: 'Link',
						name: 'url',
						type: 'string',
						placeholder: 'e.g. https://github.com/n8n-io',
						extractValue: {
							type: 'regex',
							regex: 'https:\\/\\/github.com\\/([-_0-9a-zA-Z]+)',
						},
						validation: [
							{
								type: 'regex',
								properties: {
									regex: 'https:\\/\\/github.com\\/([-_0-9a-zA-Z]+)(?:.*)',
									errorMessage: 'Not a valid Github URL',
								},
							},
						],
					},
					{
						displayName: 'By Name',
						name: 'name',
						type: 'string',
						placeholder: 'e.g. n8n-io',
						validation: [
							{
								type: 'regex',
								properties: {
									regex: '[-_a-zA-Z0-9]+',
									errorMessage: 'Not a valid Github Owner Name',
								},
							},
						],
						url: '=https://github.com/{{$value}}',
					},
				],
				displayOptions: {
					hide: {
						operation: ['invite'],
					},
				},
			},
			{
				displayName: 'Repository Name',
				name: 'repository',
				type: 'resourceLocator',
				default: {
					mode: 'list',
					value: '',
				},
				required: true,
				modes: [
					{
						displayName: 'Repository Name',
						name: 'list',
						type: 'list',
						placeholder: 'Select an Repository...',
						typeOptions: {
							searchListMethod: 'getRepositories',
							searchable: true,
						},
					},
					{
						displayName: 'Link',
						name: 'url',
						type: 'string',
						placeholder: 'e.g. https://github.com/n8n-io/n8n',
						extractValue: {
							type: 'regex',
							regex: 'https:\\/\\/github.com\\/(?:[-_0-9a-zA-Z]+)\\/([-_.0-9a-zA-Z]+)',
						},
						validation: [
							{
								type: 'regex',
								properties: {
									regex: 'https:\\/\\/github.com\\/(?:[-_0-9a-zA-Z]+)\\/([-_.0-9a-zA-Z]+)(?:.*)',
									errorMessage: 'Not a valid Github Repository URL',
								},
							},
						],
					},
					{
						displayName: 'By Name',
						name: 'name',
						type: 'string',
						placeholder: 'e.g. n8n',
						validation: [
							{
								type: 'regex',
								properties: {
									regex: '[-_.0-9a-zA-Z]+',
									errorMessage: 'Not a valid Github Repository Name',
								},
							},
						],
						url: '=https://github.com/{{$parameter["owner"]}}/{{$value}}',
					},
				],
				displayOptions: {
					hide: {
						resource: ['user', 'organization'],
						operation: ['getRepositories'],
					},
				},
			},

			// ----------------------------------
			//         workflow
			// ----------------------------------
			{
				displayName: 'Workflow',
				name: 'workflowId',
				type: 'resourceLocator',
				default: {
					mode: 'list',
					value: '',
				},
				required: true,
				modes: [
					{
						displayName: 'Workflow',
						name: 'list',
						type: 'list',
						placeholder: 'Select a workflow...',
						typeOptions: {
							searchListMethod: 'getWorkflows',
							searchable: true,
						},
					},
					{
						displayName: 'By File Name',
						name: 'filename',
						type: 'string',
						placeholder: 'e.g. main.yaml or main.yml',
						validation: [
							{
								type: 'regex',
								properties: {
									regex: '[a-zA-Z0-9_-]+.(yaml|yml)',
									errorMessage: 'Not a valid Github Workflow File Name',
								},
							},
						],
					},
					{
						displayName: 'By ID',
						name: 'name',
						type: 'string',
						placeholder: 'e.g. 12345678',
						validation: [
							{
								type: 'regex',
								properties: {
									regex: '\\d+',
									errorMessage: 'Not a valid Github Workflow ID',
								},
							},
						],
					},
				],
				displayOptions: {
					show: {
						resource: ['workflow'],
						operation: ['disable', 'dispatch', 'dispatchAndWait', 'get', 'getUsage', 'enable'],
					},
				},
				description: 'The workflow to dispatch',
			},
			{
				displayName: 'Ref',
				name: 'ref',
				type: 'string',
				default: 'main',
				required: true,
				displayOptions: {
					show: {
						resource: ['workflow'],
						operation: ['dispatch', 'dispatchAndWait'],
						'@version': [{ _cnd: { lte: 1 } }],
					},
				},
				description: 'The git reference for the workflow dispatch (branch or tag name)',
			},
			{
				displayName: 'Ref',
				name: 'ref',
				type: 'resourceLocator',
				default: {
					mode: 'list',
					value: '',
				},
				required: true,
				modes: [
					{
						displayName: 'From List',
						name: 'list',
						type: 'list',
						placeholder: 'Select a branch, tag, or commit...',
						typeOptions: {
							searchListMethod: 'getRefs',
							searchable: true,
						},
					},
					{
						displayName: 'By Name',
						name: 'name',
						type: 'string',
						placeholder: 'e.g. main',
						validation: [
							{
								type: 'regex',
								properties: {
									regex: '^[a-zA-Z0-9/._-]+$',
									errorMessage: 'Not a valid branch, tag',
								},
							},
						],
					},
				],
				displayOptions: {
					show: {
						resource: ['workflow'],
						operation: ['dispatch', 'dispatchAndWait'],
						'@version': [{ _cnd: { gte: 1.1 } }],
					},
				},
				description: 'The git reference for the workflow dispatch (branch, tag, or commit SHA)',
			},
			{
				displayName: 'Inputs',
				name: 'inputs',
				type: 'json',
				default: '{}',
				displayOptions: {
					show: {
						resource: ['workflow'],
						operation: ['dispatch', 'dispatchAndWait'],
					},
				},
				description: 'JSON object with input parameters for the workflow',
			},

			// ----------------------------------
			//         file
			// ----------------------------------

			// ----------------------------------
			//         file:create/delete/edit/get
			// ----------------------------------
			{
				displayName: 'File Path',
				name: 'filePath',
				type: 'string',
				default: '',
				required: true,
				displayOptions: {
					show: {
						resource: ['file'],
					},
					hide: {
						operation: ['list'],
					},
				},
				placeholder: 'docs/README.md',
				description: 'The file path of the file. Has to contain the full path.',
			},

			// ----------------------------------
			//         file:list
			// ----------------------------------
			{
				displayName: 'Path',
				name: 'filePath',
				type: 'string',
				default: '',
				displayOptions: {
					show: {
						resource: ['file'],
						operation: ['list'],
					},
				},
				placeholder: 'docs/',
				description: 'The path of the folder to list',
			},

			// ----------------------------------
			//         file:create/edit
			// ----------------------------------
			{
				displayName: 'Binary File',
				name: 'binaryData',
				type: 'boolean',
				default: false,
				required: true,
				displayOptions: {
					show: {
						operation: ['create', 'edit'],
						resource: ['file'],
					},
				},
				description: 'Whether the data to upload should be taken from binary field',
			},
			{
				displayName: 'File Content',
				name: 'fileContent',
				type: 'string',
				default: '',
				required: true,
				displayOptions: {
					show: {
						binaryData: [false],
						operation: ['create', 'edit'],
						resource: ['file'],
					},
				},
				placeholder: '',
				description: 'The text content of the file',
			},
			{
				displayName: 'Input Binary Field',
				name: 'binaryPropertyName',
				type: 'string',
				default: 'data',
				required: true,
				displayOptions: {
					show: {
						binaryData: [true],
						operation: ['create', 'edit'],
						resource: ['file'],
					},
				},
				placeholder: '',
				hint: 'The name of the input binary field containing the file to be written',
			},
			{
				displayName: 'Commit Message',
				name: 'commitMessage',
				type: 'string',
				default: '',
				required: true,
				displayOptions: {
					show: {
						operation: ['create', 'delete', 'edit'],
						resource: ['file'],
					},
				},
			},
			{
				displayName: 'Additional Parameters',
				name: 'additionalParameters',
				placeholder: 'Add Parameter',
				description: 'Additional fields to add',
				type: 'fixedCollection',
				default: {},
				displayOptions: {
					show: {
						operation: ['create', 'delete', 'edit'],
						resource: ['file'],
					},
				},
				options: [
					{
						name: 'author',
						displayName: 'Author',
						values: [
							{
								displayName: 'Name',
								name: 'name',
								type: 'string',
								default: '',
								description: 'The name of the author of the commit',
							},
							{
								displayName: 'Email',
								name: 'email',
								type: 'string',
								placeholder: 'name@email.com',
								default: '',
								description: 'The email of the author of the commit',
							},
						],
					},
					{
						name: 'branch',
						displayName: 'Branch',
						values: [
							{
								displayName: 'Branch',
								name: 'branch',
								type: 'string',
								default: '',
								description:
									'The branch to commit to. If not set the repository’s default branch (usually master) is used.',
							},
						],
					},
					{
						name: 'committer',
						displayName: 'Committer',
						values: [
							{
								displayName: 'Name',
								name: 'name',
								type: 'string',
								default: '',
								description: 'The name of the committer of the commit',
							},
							{
								displayName: 'Email',
								name: 'email',
								type: 'string',
								placeholder: 'name@email.com',
								default: '',
								description: 'The email of the committer of the commit',
							},
						],
					},
				],
			},

			// ----------------------------------
			//         file:get
			// ----------------------------------
			{
				displayName: 'As Binary Property',
				name: 'asBinaryProperty',
				type: 'boolean',
				default: true,
				displayOptions: {
					show: {
						operation: ['get'],
						resource: ['file'],
					},
				},
				description:
					'Whether to set the data of the file as binary property instead of returning the raw API response',
			},
			{
				displayName: 'Put Output File in Field',
				name: 'binaryPropertyName',
				type: 'string',
				default: 'data',
				required: true,
				displayOptions: {
					show: {
						asBinaryProperty: [true],
						operation: ['get'],
						resource: ['file'],
					},
				},
				placeholder: '',
				hint: 'The name of the output binary field to put the file in',
			},
			{
				displayName: 'Additional Parameters',
				name: 'additionalParameters',
				placeholder: 'Add Parameter',
				description: 'Additional fields to add',
				type: 'collection',
				default: {},
				displayOptions: {
					show: {
						operation: ['get'],
						resource: ['file'],
					},
				},
				options: [
					{
						displayName: 'Reference',
						name: 'reference',
						type: 'string',
						default: '',
						placeholder: 'master',
						description:
							'The name of the commit/branch/tag. Default: the repository’s default branch (usually master).',
					},
				],
			},

			// ----------------------------------
			//         issue
			// ----------------------------------

			// ----------------------------------
			//         issue:create
			// ----------------------------------
			{
				displayName: 'Title',
				name: 'title',
				type: 'string',
				default: '',
				required: true,
				displayOptions: {
					show: {
						operation: ['create'],
						resource: ['issue'],
					},
				},
				description: 'The title of the issue',
			},
			{
				displayName: 'Body',
				name: 'body',
				type: 'string',
				typeOptions: {
					rows: 5,
				},
				default: '',
				displayOptions: {
					show: {
						operation: ['create'],
						resource: ['issue'],
					},
				},
				description: 'The body of the issue',
			},
			{
				displayName: 'Labels',
				name: 'labels',
				type: 'collection',
				typeOptions: {
					multipleValues: true,
					multipleValueButtonText: 'Add Label',
				},
				displayOptions: {
					show: {
						operation: ['create'],
						resource: ['issue'],
					},
				},
				default: { label: '' },
				options: [
					{
						displayName: 'Label',
						name: 'label',
						type: 'string',
						default: '',
						description: 'Label to add to issue',
					},
				],
			},
			{
				displayName: 'Assignees',
				name: 'assignees',
				type: 'collection',
				typeOptions: {
					multipleValues: true,
					multipleValueButtonText: 'Add Assignee',
				},
				displayOptions: {
					show: {
						operation: ['create'],
						resource: ['issue'],
					},
				},
				default: { assignee: '' },
				options: [
					{
						displayName: 'Assignee',
						name: 'assignee',
						type: 'string',
						default: '',
						description: 'User to assign issue too',
					},
				],
			},

			// ----------------------------------
			//         issue:createComment
			// ----------------------------------
			{
				displayName: 'Issue Number',
				name: 'issueNumber',
				type: 'number',
				default: 0,
				required: true,
				displayOptions: {
					show: {
						operation: ['createComment'],
						resource: ['issue'],
					},
				},
				description: 'The number of the issue on which to create the comment on',
			},
			{
				displayName: 'Body',
				name: 'body',
				type: 'string',
				typeOptions: {
					rows: 5,
				},
				displayOptions: {
					show: {
						operation: ['createComment'],
						resource: ['issue'],
					},
				},
				default: '',
				description: 'The body of the comment',
			},

			// ----------------------------------
			//         issue:edit
			// ----------------------------------
			{
				displayName: 'Issue Number',
				name: 'issueNumber',
				type: 'number',
				default: 0,
				required: true,
				displayOptions: {
					show: {
						operation: ['edit'],
						resource: ['issue'],
					},
				},
				description: 'The number of the issue edit',
			},
			{
				displayName: 'Edit Fields',
				name: 'editFields',
				type: 'collection',
				typeOptions: {
					multipleValueButtonText: 'Add Field',
				},
				displayOptions: {
					show: {
						operation: ['edit'],
						resource: ['issue'],
					},
				},
				default: {},
				options: [
					{
						displayName: 'Assignees',
						name: 'assignees',
						type: 'collection',
						typeOptions: {
							multipleValues: true,
							multipleValueButtonText: 'Add Assignee',
						},
						default: { assignee: '' },
						options: [
							{
								displayName: 'Assignees',
								name: 'assignee',
								type: 'string',
								default: '',
								description: 'User to assign issue to',
							},
						],
					},
					{
						displayName: 'Body',
						name: 'body',
						type: 'string',
						typeOptions: {
							rows: 5,
						},
						default: '',
						description: 'The body of the issue',
					},
					{
						displayName: 'Labels',
						name: 'labels',
						type: 'collection',
						typeOptions: {
							multipleValues: true,
							multipleValueButtonText: 'Add Label',
						},
						default: { label: '' },
						options: [
							{
								displayName: 'Label',
								name: 'label',
								type: 'string',
								default: '',
								description: 'Label to add to issue',
							},
						],
					},
					{
						displayName: 'State',
						name: 'state',
						type: 'options',
						options: [
							{
								name: 'Closed',
								value: 'closed',
								description: 'Set the state to "closed"',
							},
							{
								name: 'Open',
								value: 'open',
								description: 'Set the state to "open"',
							},
						],
						default: 'open',
						description: 'The state to set',
					},
					{
						displayName: 'State Reason',
						name: 'state_reason',
						type: 'options',
						options: [
							{
								name: 'Completed',
								value: 'completed',
								description: 'Issue is completed',
							},
							{
								name: 'Not Planned',
								value: 'not_planned',
								description: 'Issue is not planned',
							},
							{
								name: 'Reopened',
								value: 'reopened',
								description: 'Issue is reopened',
							},
						],
						default: 'completed',
						description: 'The reason for the state change',
					},
					{
						displayName: 'Title',
						name: 'title',
						type: 'string',
						default: '',
						description: 'The title of the issue',
					},
				],
			},

			// ----------------------------------
			//         issue:get
			// ----------------------------------
			{
				displayName: 'Issue Number',
				name: 'issueNumber',
				type: 'number',
				default: 0,
				required: true,
				displayOptions: {
					show: {
						operation: ['get'],
						resource: ['issue'],
					},
				},
				description: 'The issue number to get data for',
			},

			// ----------------------------------
			//         issue:lock
			// ----------------------------------
			{
				displayName: 'Issue Number',
				name: 'issueNumber',
				type: 'number',
				default: 0,
				required: true,
				displayOptions: {
					show: {
						operation: ['lock'],
						resource: ['issue'],
					},
				},
				description: 'The issue number to lock',
			},
			{
				displayName: 'Lock Reason',
				name: 'lockReason',
				type: 'options',
				displayOptions: {
					show: {
						operation: ['lock'],
						resource: ['issue'],
					},
				},
				options: [
					{
						name: 'Off-Topic',
						value: 'off-topic',
						description: 'The issue is Off-Topic',
					},
					{
						name: 'Too Heated',
						value: 'too heated',
						description: 'The discussion is too heated',
					},
					{
						name: 'Resolved',
						value: 'resolved',
						description: 'The issue got resolved',
					},
					{
						name: 'Spam',
						value: 'spam',
						description: 'The issue is spam',
					},
				],
				default: 'resolved',
				description: 'The reason for locking the issue',
			},

			// ----------------------------------
			//         release
			// ----------------------------------

			// ----------------------------------
			//         release:create
			// ----------------------------------
			{
				displayName: 'Tag',
				name: 'releaseTag',
				type: 'string',
				default: '',
				required: true,
				displayOptions: {
					show: {
						operation: ['create'],
						resource: ['release'],
					},
				},
				description: 'The tag of the release',
			},
			{
				displayName: 'Additional Fields',
				name: 'additionalFields',
				type: 'collection',
				typeOptions: {
					multipleValueButtonText: 'Add Field',
				},
				displayOptions: {
					show: {
						operation: ['create'],
						resource: ['release'],
					},
				},
				default: {},
				options: [
					{
						displayName: 'Name',
						name: 'name',
						type: 'string',
						default: '',
						description: 'The name of the issue',
					},
					{
						displayName: 'Body',
						name: 'body',
						type: 'string',
						typeOptions: {
							rows: 5,
						},
						default: '',
						description: 'The body of the release',
					},
					{
						displayName: 'Draft',
						name: 'draft',
						type: 'boolean',
						default: false,
						description:
							'Whether to create a draft (unpublished) release, "false" to create a published one',
					},
					{
						displayName: 'Prerelease',
						name: 'prerelease',
						type: 'boolean',
						default: false,
						description: 'Whether to point out that the release is non-production ready',
					},
					{
						displayName: 'Target Commitish',
						name: 'target_commitish',
						type: 'string',
						default: '',
						description:
							"Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch(usually master).",
					},
				],
			},

			// ----------------------------------
			//         release:get/delete/update
			// ----------------------------------
			{
				displayName: 'Release ID',
				name: 'release_id',
				type: 'string',
				default: '',
				required: true,
				displayOptions: {
					show: {
						resource: ['release'],
						operation: ['get', 'delete', 'update'],
					},
				},
			},

			// ----------------------------------
			//         release:update
			// ----------------------------------
			{
				displayName: 'Additional Fields',
				name: 'additionalFields',
				type: 'collection',
				typeOptions: {
					multipleValueButtonText: 'Add Field',
				},
				displayOptions: {
					show: {
						operation: ['update'],
						resource: ['release'],
					},
				},
				default: {},
				options: [
					{
						displayName: 'Body',
						name: 'body',
						type: 'string',
						typeOptions: {
							rows: 5,
						},
						default: '',
						description: 'The body of the release',
					},
					{
						displayName: 'Draft',
						name: 'draft',
						type: 'boolean',
						default: false,
						description:
							'Whether to create a draft (unpublished) release, "false" to create a published one',
					},
					{
						displayName: 'Name',
						name: 'name',
						type: 'string',
						default: '',
						description: 'The name of the release',
					},
					{
						displayName: 'Prerelease',
						name: 'prerelease',
						type: 'boolean',
						default: false,
						description: 'Whether to point out that the release is non-production ready',
					},
					{
						displayName: 'Tag Name',
						name: 'tag_name',
						type: 'string',
						default: '',
						description: 'The name of the tag',
					},
					{
						displayName: 'Target Commitish',
						name: 'target_commitish',
						type: 'string',
						default: '',
						description:
							"Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch(usually master).",
					},
				],
			},

			// ----------------------------------
			//         release:getAll
			// ----------------------------------
			{
				displayName: 'Return All',
				name: 'returnAll',
				type: 'boolean',
				displayOptions: {
					show: {
						resource: ['release'],
						operation: ['getAll'],
					},
				},
				default: false,
				description: 'Whether to return all results or only up to a given limit',
			},
			{
				displayName: 'Limit',
				name: 'limit',
				type: 'number',
				displayOptions: {
					show: {
						resource: ['release'],
						operation: ['getAll'],
						returnAll: [false],
					},
				},
				typeOptions: {
					minValue: 1,
					maxValue: 100,
				},
				default: 50,
				description: 'Max number of results to return',
			},

			// ----------------------------------
			//         repository
			// ----------------------------------

			// ----------------------------------
			//         repository:getIssues
			// ----------------------------------
			{
				displayName: 'Return All',
				name: 'returnAll',
				type: 'boolean',
				displayOptions: {
					show: {
						resource: ['repository'],
						operation: ['getIssues'],
					},
				},
				default: false,
				description: 'Whether to return all results or only up to a given limit',
			},
			{
				displayName: 'Limit',
				name: 'limit',
				type: 'number',
				displayOptions: {
					show: {
						resource: ['repository'],
						operation: ['getIssues'],
						returnAll: [false],
					},
				},
				typeOptions: {
					minValue: 1,
					maxValue: 100,
				},
				default: 50,
				description: 'Max number of results to return',
			},
			{
				displayName: 'Filters',
				name: 'getRepositoryIssuesFilters',
				type: 'collection',
				typeOptions: {
					multipleValueButtonText: 'Add Filter',
				},
				displayOptions: {
					show: {
						operation: ['getIssues'],
						resource: ['repository'],
					},
				},
				default: {},
				options: [
					{
						displayName: 'Assignee',
						name: 'assignee',
						type: 'string',
						default: '',
						description: 'Return only issues which are assigned to a specific user',
					},
					{
						displayName: 'Creator',
						name: 'creator',
						type: 'string',
						default: '',
						description: 'Return only issues which were created by a specific user',
					},
					{
						displayName: 'Mentioned',
						name: 'mentioned',
						type: 'string',
						default: '',
						description: 'Return only issues in which a specific user was mentioned',
					},
					{
						displayName: 'Labels',
						name: 'labels',
						type: 'string',
						default: '',
						description:
							'Return only issues with the given labels. Multiple labels can be separated by comma.',
					},
					{
						displayName: 'Updated Since',
						name: 'since',
						type: 'dateTime',
						default: '',
						description: 'Return only issues updated at or after this time',
					},
					{
						displayName: 'State',
						name: 'state',
						type: 'options',
						options: [
							{
								name: 'All',
								value: 'all',
								description: 'Returns issues with any state',
							},
							{
								name: 'Closed',
								value: 'closed',
								description: 'Return issues with "closed" state',
							},
							{
								name: 'Open',
								value: 'open',
								description: 'Return issues with "open" state',
							},
						],
						default: 'open',
						description: 'The state to set',
					},
					{
						displayName: 'Sort',
						name: 'sort',
						type: 'options',
						options: [
							{
								name: 'Created',
								value: 'created',
								description: 'Sort by created date',
							},
							{
								name: 'Updated',
								value: 'updated',
								description: 'Sort by updated date',
							},
							{
								name: 'Comments',
								value: 'comments',
								description: 'Sort by comments',
							},
						],
						default: 'created',
						description: 'The order the issues should be returned in',
					},
					{
						displayName: 'Direction',
						name: 'direction',
						type: 'options',
						options: [
							{
								name: 'Ascending',
								value: 'asc',
								description: 'Sort in ascending order',
							},
							{
								name: 'Descending',
								value: 'desc',
								description: 'Sort in descending order',
							},
						],
						default: 'desc',
						description: 'The sort order',
					},
				],
			},

			// ----------------------------------
			//         repository:getPullRequests
			// ----------------------------------
			{
				displayName: 'Return All',
				name: 'returnAll',
				type: 'boolean',
				displayOptions: {
					show: {
						resource: ['repository'],
						operation: ['getPullRequests'],
					},
				},
				default: false,
				description: 'Whether to return all results or only up to a given limit',
			},
			{
				displayName: 'Limit',
				name: 'limit',
				type: 'number',
				displayOptions: {
					show: {
						resource: ['repository'],
						operation: ['getPullRequests'],
						returnAll: [false],
					},
				},
				typeOptions: {
					minValue: 1,
					maxValue: 100,
				},
				default: 50,
				// eslint-disable-next-line n8n-nodes-base/node-param-description-wrong-for-limit
				description:
					'Max number of results to return. Maximum value is <a href="https://docs.github.com/en/rest/pulls/pulls?apiVersion=2022-11-28#list-pull-requests">100</a>.',
			},
			{
				displayName: 'Filters',
				name: 'getRepositoryPullRequestsFilters',
				type: 'collection',
				typeOptions: {
					multipleValueButtonText: 'Add Filter',
				},
				displayOptions: {
					show: {
						operation: ['getPullRequests'],
						resource: ['repository'],
					},
				},
				default: {},
				options: [
					{
						displayName: 'State',
						name: 'state',
						type: 'options',
						options: [
							{
								name: 'All',
								value: 'all',
								description: 'Returns pull requests with any state',
							},
							{
								name: 'Closed',
								value: 'closed',
								description: 'Return pull requests with "closed" state',
							},
							{
								name: 'Open',
								value: 'open',
								description: 'Return pull requests with "open" state',
							},
						],
						default: 'open',
						description: 'The state to set',
					},
					{
						displayName: 'Sort',
						name: 'sort',
						type: 'options',
						options: [
							{
								name: 'Created',
								value: 'created',
								description: 'Sort by created date',
							},
							{
								name: 'Updated',
								value: 'updated',
								description: 'Sort by updated date',
							},
							{
								name: 'Popularity',
								value: 'popularity',
								description: 'Sort by number of comments',
							},
							{
								name: 'Long-Running',
								value: 'long-running',
								description:
									'Sort by date created and will limit the results to pull requests that have been open for more than a month and have had activity within the past month',
							},
						],
						default: 'created',
						description: 'The order the pull requests should be returned in',
					},
					{
						displayName: 'Direction',
						name: 'direction',
						type: 'options',
						options: [
							{
								name: 'Ascending',
								value: 'asc',
								description: 'Sort in ascending order',
							},
							{
								name: 'Descending',
								value: 'desc',
								description: 'Sort in descending order',
							},
						],
						default: 'desc',
						description: 'The sort order',
					},
				],
			},

			// ----------------------------------
			//         rerview
			// ----------------------------------

			// ----------------------------------
			//         review:getAll
			// ----------------------------------
			{
				displayName: 'PR Number',
				name: 'pullRequestNumber',
				type: 'number',
				default: 0,
				required: true,
				displayOptions: {
					show: {
						operation: ['get', 'update'],
						resource: ['review'],
					},
				},
				description: 'The number of the pull request',
			},
			{
				displayName: 'Review ID',
				name: 'reviewId',
				type: 'string',
				default: '',
				required: true,
				displayOptions: {
					show: {
						operation: ['get', 'update'],
						resource: ['review'],
					},
				},
				description: 'ID of the review',
			},

			// ----------------------------------
			//         review:getAll
			// ----------------------------------
			{
				displayName: 'PR Number',
				name: 'pullRequestNumber',
				type: 'number',
				default: 0,
				required: true,
				displayOptions: {
					show: {
						operation: ['getAll'],
						resource: ['review'],
					},
				},
				description: 'The number of the pull request',
			},
			{
				displayName: 'Return All',
				name: 'returnAll',
				type: 'boolean',
				displayOptions: {
					show: {
						resource: ['review'],
						operation: ['getAll'],
					},
				},
				default: false,
				description: 'Whether to return all results or only up to a given limit',
			},
			{
				displayName: 'Limit',
				name: 'limit',
				type: 'number',
				displayOptions: {
					show: {
						resource: ['review'],
						operation: ['getAll'],
						returnAll: [false],
					},
				},
				typeOptions: {
					minValue: 1,
					maxValue: 100,
				},
				default: 50,
				description: 'Max number of results to return',
			},

			// ----------------------------------
			//         review:create
			// ----------------------------------
			{
				displayName: 'PR Number',
				name: 'pullRequestNumber',
				type: 'number',
				default: 0,
				required: true,
				displayOptions: {
					show: {
						operation: ['create'],
						resource: ['review'],
					},
				},
				description: 'The number of the pull request to review',
			},
			{
				displayName: 'Event',
				name: 'event',
				type: 'options',
				displayOptions: {
					show: {
						operation: ['create'],
						resource: ['review'],
					},
				},
				options: [
					{
						name: 'Approve',
						value: 'approve',
						description: 'Approve the pull request',
					},
					{
						name: 'Request Change',
						value: 'requestChanges',
						description: 'Request code changes',
					},
					{
						name: 'Comment',
						value: 'comment',
						description: 'Add a comment without approval or change requests',
					},
					{
						name: 'Pending',
						value: 'pending',
						description: 'You will need to submit the pull request review when you are ready',
					},
				],
				default: 'approve',
				description: 'The review action you want to perform',
			},
			{
				displayName: 'Body',
				name: 'body',
				type: 'string',
				displayOptions: {
					show: {
						operation: ['create'],
						resource: ['review'],
						event: ['requestChanges', 'comment'],
					},
				},
				default: '',
				description: 'The body of the review (required for events Request Changes or Comment)',
			},
			{
				displayName: 'Additional Fields',
				name: 'additionalFields',
				placeholder: 'Add Field',
				type: 'collection',
				default: {},
				displayOptions: {
					show: {
						operation: ['create'],
						resource: ['review'],
					},
				},
				options: [
					{
						displayName: 'Commit ID',
						name: 'commitId',
						type: 'string',
						default: '',
						description: 'The SHA of the commit that needs a review, if different from the latest',
					},
				],
			},

			// ----------------------------------
			//         review:update
			// ----------------------------------
			{
				displayName: 'Body',
				name: 'body',
				type: 'string',
				displayOptions: {
					show: {
						operation: ['update'],
						resource: ['review'],
					},
				},
				default: '',
				description: 'The body of the review',
			},

			// ----------------------------------
			//       user:getRepositories
			// ----------------------------------
			{
				displayName: 'Return All',
				name: 'returnAll',
				type: 'boolean',
				displayOptions: {
					show: {
						resource: ['user'],
						operation: ['getRepositories'],
					},
				},
				default: false,
				description: 'Whether to return all results or only up to a given limit',
			},
			{
				displayName: 'Limit',
				name: 'limit',
				type: 'number',
				displayOptions: {
					show: {
						resource: ['user'],
						operation: ['getRepositories'],
						returnAll: [false],
					},
				},
				typeOptions: {
					minValue: 1,
					maxValue: 100,
				},
				default: 50,
				description: 'Max number of results to return',
			},

			// ----------------------------------
			//         user:invite
			// ----------------------------------
			{
				displayName: 'Organization',
				name: 'organization',
				type: 'string',
				default: '',
				required: true,
				displayOptions: {
					show: {
						operation: ['invite'],
						resource: ['user'],
					},
				},
				description: 'The GitHub organization that the user is being invited to',
			},
			{
				displayName: 'Email',
				name: 'email',
				type: 'string',
				placeholder: 'name@email.com',
				default: '',
				required: true,
				displayOptions: {
					show: {
						operation: ['invite'],
						resource: ['user'],
					},
				},
				description: 'The email address of the invited user',
			},

			// ----------------------------------
			//    organization:getRepositories
			// ----------------------------------
			{
				displayName: 'Return All',
				name: 'returnAll',
				type: 'boolean',
				displayOptions: {
					show: {
						resource: ['organization'],
						operation: ['getRepositories'],
					},
				},
				default: false,
				description: 'Whether to return all results or only up to a given limit',
			},
			{
				displayName: 'Limit',
				name: 'limit',
				type: 'number',
				displayOptions: {
					show: {
						resource: ['organization'],
						operation: ['getRepositories'],
						returnAll: [false],
					},
				},
				typeOptions: {
					minValue: 1,
					maxValue: 100,
				},
				default: 50,
				description: 'Max number of results to return',
			},
		],
	};

	methods = {
		listSearch: {
			getRefs,
			getRepositories,
			getUsers,
			getWorkflows,
		},
	};

	async webhook(this: IWebhookFunctions): Promise<IWebhookResponseData> {
		const requestObject = this.getRequestObject();

		return {
			workflowData: [this.helpers.returnJsonArray(requestObject.body)],
		};
	}

	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
		const items = this.getInputData();
		const returnData: INodeExecutionData[] = [];

		let returnAll = false;

		let responseData;

		// Operations which overwrite the returned data
		const overwriteDataOperations = [
			'file:create',
			'file:delete',
			'file:edit',
			'file:get',
			'issue:create',
			'issue:createComment',
			'issue:edit',
			'issue:get',
			'release:create',
			'release:delete',
			'release:get',
			'release:update',
			'repository:get',
			'repository:getLicense',
			'repository:getProfile',
			'review:create',
			'review:get',
			'review:update',
			'user:invite',
			'workflow:disable',
			'workflow:dispatch',
			'workflow:enable',
			'workflow:get',
			'workflow:getUsage',
			'workflow:list',
		];
		// Operations which overwrite the returned data and return arrays
		// and has so to be merged with the data of other items
		const overwriteDataOperationsArray = [
			'file:list',
			'repository:getIssues',
			'repository:getPullRequests',
			'repository:listPopularPaths',
			'repository:listReferrers',
			'user:getRepositories',
			'release:getAll',
			'review:getAll',
			'organization:getRepositories',
		];

		// For Post
		let body: IDataObject;
		// For Query string
		let qs: IDataObject;

		let requestMethod: IHttpRequestMethods;
		let endpoint: string;

		const operation = this.getNodeParameter('operation', 0);
		const resource = this.getNodeParameter('resource', 0);
		const fullOperation = `${resource}:${operation}`;

		if (resource === 'workflow' && operation === 'dispatchAndWait') {
			const owner = this.getNodeParameter('owner', 0, '', { extractValue: true }) as string;
			const repository = this.getNodeParameter('repository', 0, '', {
				extractValue: true,
			}) as string;
			const workflowId = this.getNodeParameter('workflowId', 0, '', {
				extractValue: true,
			}) as string;
			const ref = this.getNodeParameter('ref', 0, '', { extractValue: true }) as string;

			const inputs = validateJSON(this.getNodeParameter('inputs', 0) as string) as IDataObject;
			if (!inputs) {
				throw new NodeOperationError(this.getNode(), 'Inputs: Invalid JSON');
			}

			endpoint = `/repos/${owner}/${repository}/actions/workflows/${workflowId}/dispatches`;

			body = {
				ref,
				inputs,
			};

			// Generate a webhook URL for the GitHub workflow to call when done
			const resumeUrl = this.getWorkflowDataProxy(0).$execution.resumeUrl;

			body.inputs = {
				...inputs,
				resumeUrl,
			};

			try {
				responseData = await githubApiRequest.call(this, 'POST', endpoint, body);
			} catch (error) {
				if (error.httpCode === '404' || error.statusCode === 404) {
					throw new NodeOperationError(
						this.getNode(),
						'The workflow to dispatch could not be found. Adjust the "workflow" parameter setting to dispatch the workflow correctly.',
						{ itemIndex: 0 },
					);
				}
				throw new NodeApiError(this.getNode(), error as JsonObject);
			}

			await this.putExecutionToWait(WAIT_INDEFINITELY);
			return [this.getInputData()];
		}

		for (let i = 0; i < items.length; i++) {
			try {
				// Reset all values
				requestMethod = 'GET';
				endpoint = '';
				body = {};
				qs = {};

				let owner = '';
				if (fullOperation !== 'user:invite') {
					// Request the parameters which almost all operations need
					owner = this.getNodeParameter('owner', i, '', { extractValue: true }) as string;
				}

				let repository = '';
				if (
					fullOperation !== 'user:getRepositories' &&
					fullOperation !== 'user:invite' &&
					fullOperation !== 'organization:getRepositories'
				) {
					repository = this.getNodeParameter('repository', i, '', { extractValue: true }) as string;
				}

				if (resource === 'file') {
					if (['create', 'edit'].includes(operation)) {
						// ----------------------------------
						//         create/edit
						// ----------------------------------

						requestMethod = 'PUT';

						const filePath = removeTrailingSlash(this.getNodeParameter('filePath', i));

						const additionalParameters = this.getNodeParameter(
							'additionalParameters',
							i,
							{},
						) as IDataObject;
						if (additionalParameters.author) {
							body.author = additionalParameters.author;
						}
						if (additionalParameters.committer) {
							body.committer = additionalParameters.committer;
						}
						if (
							additionalParameters.branch &&
							(additionalParameters.branch as IDataObject).branch
						) {
							body.branch = (additionalParameters.branch as IDataObject).branch;
						}

						if (operation === 'edit') {
							// If the file should be updated the request has to contain the SHA
							// of the file which gets replaced.
							body.sha = await getFileSha.call(
								this,
								owner,
								repository,
								filePath,
								body.branch as string | undefined,
							);
						}

						body.message = this.getNodeParameter('commitMessage', i) as string;

						if (this.getNodeParameter('binaryData', i)) {
							// Currently internally n8n uses base64 and also Github expects it base64 encoded.
							// If that ever changes the data has to get converted here.
							const binaryPropertyName = this.getNodeParameter('binaryPropertyName', i);
							const binaryData = this.helpers.assertBinaryData(i, binaryPropertyName);
							// TODO: Does this work with filesystem mode
							body.content = binaryData.data;
						} else {
							const fileContent = this.getNodeParameter('fileContent', i) as string;
							if (isBase64(fileContent)) {
								body.content = fileContent;
							} else {
								body.content = Buffer.from(fileContent).toString('base64');
							}
						}

						endpoint = `/repos/${owner}/${repository}/contents/${encodeURIComponent(filePath)}`;
					} else if (operation === 'delete') {
						// ----------------------------------
						//         delete
						// ----------------------------------

						requestMethod = 'DELETE';

						const additionalParameters = this.getNodeParameter(
							'additionalParameters',
							i,
							{},
						) as IDataObject;
						if (additionalParameters.author) {
							body.author = additionalParameters.author;
						}
						if (additionalParameters.committer) {
							body.committer = additionalParameters.committer;
						}
						if (
							additionalParameters.branch &&
							(additionalParameters.branch as IDataObject).branch
						) {
							body.branch = (additionalParameters.branch as IDataObject).branch;
						}

						const filePath = removeTrailingSlash(this.getNodeParameter('filePath', i));
						body.message = this.getNodeParameter('commitMessage', i) as string;

						body.sha = await getFileSha.call(
							this,
							owner,
							repository,
							filePath,
							body.branch as string | undefined,
						);

						endpoint = `/repos/${owner}/${repository}/contents/${encodeURIComponent(filePath)}`;
					} else if (operation === 'get') {
						requestMethod = 'GET';

						const filePath = removeTrailingSlash(this.getNodeParameter('filePath', i));
						const additionalParameters = this.getNodeParameter(
							'additionalParameters',
							i,
						) as IDataObject;

						if (additionalParameters.reference) {
							qs.ref = additionalParameters.reference;
						}

						endpoint = `/repos/${owner}/${repository}/contents/${encodeURIComponent(filePath)}`;
					} else if (operation === 'list') {
						requestMethod = 'GET';
						const filePath = removeTrailingSlash(this.getNodeParameter('filePath', i));
						endpoint = `/repos/${owner}/${repository}/contents/${encodeURIComponent(filePath)}`;
					}
				} else if (resource === 'issue') {
					if (operation === 'create') {
						// ----------------------------------
						//         create
						// ----------------------------------

						requestMethod = 'POST';

						body.title = this.getNodeParameter('title', i) as string;
						body.body = this.getNodeParameter('body', i) as string;
						const labels = this.getNodeParameter('labels', i) as IDataObject[];

						const assignees = this.getNodeParameter('assignees', i) as IDataObject[];

						body.labels = labels.map((data) => data.label);
						body.assignees = assignees.map((data) => data.assignee);

						endpoint = `/repos/${owner}/${repository}/issues`;
					} else if (operation === 'createComment') {
						// ----------------------------------
						//         createComment
						// ----------------------------------
						requestMethod = 'POST';

						const issueNumber = this.getNodeParameter('issueNumber', i) as string;

						body.body = this.getNodeParameter('body', i) as string;

						endpoint = `/repos/${owner}/${repository}/issues/${issueNumber}/comments`;
					} else if (operation === 'edit') {
						// ----------------------------------
						//         edit
						// ----------------------------------

						requestMethod = 'PATCH';

						const issueNumber = this.getNodeParameter('issueNumber', i) as string;

						body = this.getNodeParameter('editFields', i, {}) as IDataObject;

						if (body.labels !== undefined) {
							body.labels = (body.labels as IDataObject[]).map((data) => data.label);
						}
						if (body.assignees !== undefined) {
							body.assignees = (body.assignees as IDataObject[]).map((data) => data.assignee);
						}

						endpoint = `/repos/${owner}/${repository}/issues/${issueNumber}`;
					} else if (operation === 'get') {
						// ----------------------------------
						//         get
						// ----------------------------------

						requestMethod = 'GET';

						const issueNumber = this.getNodeParameter('issueNumber', i) as string;

						endpoint = `/repos/${owner}/${repository}/issues/${issueNumber}`;
					} else if (operation === 'lock') {
						// ----------------------------------
						//         lock
						// ----------------------------------

						requestMethod = 'PUT';

						const issueNumber = this.getNodeParameter('issueNumber', i) as string;

						qs.lock_reason = this.getNodeParameter('lockReason', i) as string;

						endpoint = `/repos/${owner}/${repository}/issues/${issueNumber}/lock`;
					}
				} else if (resource === 'release') {
					if (operation === 'create') {
						// ----------------------------------
						//         create
						// ----------------------------------

						requestMethod = 'POST';

						body = this.getNodeParameter('additionalFields', i, {});

						body.tag_name = this.getNodeParameter('releaseTag', i) as string;

						endpoint = `/repos/${owner}/${repository}/releases`;
					}
					if (operation === 'delete') {
						// ----------------------------------
						//         delete
						// ----------------------------------

						requestMethod = 'DELETE';

						const releaseId = this.getNodeParameter('release_id', i) as string;

						endpoint = `/repos/${owner}/${repository}/releases/${releaseId}`;
					}
					if (operation === 'get') {
						// ----------------------------------
						//         get
						// ----------------------------------

						requestMethod = 'GET';

						const releaseId = this.getNodeParameter('release_id', i) as string;

						endpoint = `/repos/${owner}/${repository}/releases/${releaseId}`;
					}
					if (operation === 'getAll') {
						// ----------------------------------
						//         getAll
						// ----------------------------------

						requestMethod = 'GET';

						endpoint = `/repos/${owner}/${repository}/releases`;

						returnAll = this.getNodeParameter('returnAll', 0);

						if (!returnAll) {
							qs.per_page = this.getNodeParameter('limit', 0);
						}
					}
					if (operation === 'update') {
						// ----------------------------------
						//         update
						// ----------------------------------

						requestMethod = 'PATCH';

						const releaseId = this.getNodeParameter('release_id', i) as string;

						body = this.getNodeParameter('additionalFields', i, {});

						endpoint = `/repos/${owner}/${repository}/releases/${releaseId}`;
					}
				} else if (resource === 'repository') {
					if (operation === 'listPopularPaths') {
						// ----------------------------------
						//         listPopularPaths
						// ----------------------------------

						requestMethod = 'GET';

						endpoint = `/repos/${owner}/${repository}/traffic/popular/paths`;
					} else if (operation === 'listReferrers') {
						// ----------------------------------
						//         listReferrers
						// ----------------------------------

						requestMethod = 'GET';

						endpoint = `/repos/${owner}/${repository}/traffic/popular/referrers`;
					} else if (operation === 'get') {
						// ----------------------------------
						//         get
						// ----------------------------------

						requestMethod = 'GET';

						endpoint = `/repos/${owner}/${repository}`;
					} else if (operation === 'getLicense') {
						// ----------------------------------
						//         getLicense
						// ----------------------------------

						requestMethod = 'GET';

						endpoint = `/repos/${owner}/${repository}/license`;
					} else if (operation === 'getIssues') {
						// ----------------------------------
						//         getIssues
						// ----------------------------------

						requestMethod = 'GET';

						qs = this.getNodeParameter('getRepositoryIssuesFilters', i) as IDataObject;

						endpoint = `/repos/${owner}/${repository}/issues`;

						returnAll = this.getNodeParameter('returnAll', 0);

						if (!returnAll) {
							qs.per_page = this.getNodeParameter('limit', 0);
						}
					} else if (operation === 'getPullRequests') {
						// ----------------------------------
						//         getPullRequests
						// ----------------------------------

						requestMethod = 'GET';

						qs = this.getNodeParameter('getRepositoryPullRequestsFilters', i) as IDataObject;

						endpoint = `/repos/${owner}/${repository}/pulls`;

						returnAll = this.getNodeParameter('returnAll', 0);

						if (!returnAll) {
							qs.per_page = this.getNodeParameter('limit', 0);
						}
					}
				} else if (resource === 'review') {
					if (operation === 'get') {
						// ----------------------------------
						//         get
						// ----------------------------------
						requestMethod = 'GET';

						const reviewId = this.getNodeParameter('reviewId', i) as string;

						const pullRequestNumber = this.getNodeParameter('pullRequestNumber', i) as string;

						endpoint = `/repos/${owner}/${repository}/pulls/${pullRequestNumber}/reviews/${reviewId}`;
					} else if (operation === 'getAll') {
						// ----------------------------------
						//         getAll
						// ----------------------------------
						requestMethod = 'GET';

						returnAll = this.getNodeParameter('returnAll', 0);

						const pullRequestNumber = this.getNodeParameter('pullRequestNumber', i) as string;

						if (!returnAll) {
							qs.per_page = this.getNodeParameter('limit', 0);
						}

						endpoint = `/repos/${owner}/${repository}/pulls/${pullRequestNumber}/reviews`;
					} else if (operation === 'create') {
						// ----------------------------------
						//         create
						// ----------------------------------
						requestMethod = 'POST';

						const pullRequestNumber = this.getNodeParameter('pullRequestNumber', i) as string;
						const additionalFields = this.getNodeParameter('additionalFields', i);
						Object.assign(body, additionalFields);

						body.event = snakeCase(this.getNodeParameter('event', i) as string).toUpperCase();
						if (body.event === 'REQUEST_CHANGES' || body.event === 'COMMENT') {
							body.body = this.getNodeParameter('body', i) as string;
						}

						endpoint = `/repos/${owner}/${repository}/pulls/${pullRequestNumber}/reviews`;
					} else if (operation === 'update') {
						// ----------------------------------
						//         update
						// ----------------------------------
						requestMethod = 'PUT';

						const pullRequestNumber = this.getNodeParameter('pullRequestNumber', i) as string;
						const reviewId = this.getNodeParameter('reviewId', i) as string;

						body.body = this.getNodeParameter('body', i) as string;

						endpoint = `/repos/${owner}/${repository}/pulls/${pullRequestNumber}/reviews/${reviewId}`;
					}
				} else if (resource === 'user') {
					if (operation === 'getRepositories') {
						// ----------------------------------
						//         getRepositories
						// ----------------------------------

						requestMethod = 'GET';

						endpoint = `/users/${owner}/repos`;

						returnAll = this.getNodeParameter('returnAll', 0);

						if (!returnAll) {
							qs.per_page = this.getNodeParameter('limit', 0);
						}
					} else if (operation === 'invite') {
						// ----------------------------------
						//            invite
						// ----------------------------------

						requestMethod = 'POST';
						const org = this.getNodeParameter('organization', i) as string;
						endpoint = `/orgs/${org}/invitations`;
						body.email = this.getNodeParameter('email', i) as string;
					}
				} else if (resource === 'organization') {
					if (operation === 'getRepositories') {
						// ----------------------------------
						//         getRepositories
						// ----------------------------------

						requestMethod = 'GET';

						endpoint = `/orgs/${owner}/repos`;
						returnAll = this.getNodeParameter('returnAll', 0);

						if (!returnAll) {
							qs.per_page = this.getNodeParameter('limit', 0);
						}
					}
				} else if (resource === 'workflow') {
					if (operation === 'disable') {
						// ----------------------------------
						//         disable
						// ----------------------------------

						requestMethod = 'PUT';

						const workflowId = this.getNodeParameter('workflowId', i, '', {
							extractValue: true,
						}) as string;

						endpoint = `/repos/${owner}/${repository}/actions/workflows/${workflowId}/disable`;
					}
					if (operation === 'dispatch') {
						// ----------------------------------
						//         dispatch
						// ----------------------------------

						requestMethod = 'POST';

						const workflowId = this.getNodeParameter('workflowId', i, '', {
							extractValue: true,
						}) as string;

						endpoint = `/repos/${owner}/${repository}/actions/workflows/${workflowId}/dispatches`;

						const ref = this.getNodeParameter('ref', i, '', { extractValue: true }) as string;
						body.ref = ref;

						const inputs = validateJSON(
							this.getNodeParameter('inputs', i) as string,
						) as IDataObject;
						if (inputs === undefined) {
							throw new NodeOperationError(this.getNode(), 'Inputs: Invalid JSON', {
								itemIndex: i,
							});
						}
						body.inputs = inputs;
					} else if (operation === 'enable') {
						// ----------------------------------
						//         enable
						// ----------------------------------

						requestMethod = 'PUT';

						const workflowId = this.getNodeParameter('workflowId', i, '', {
							extractValue: true,
						}) as string;

						endpoint = `/repos/${owner}/${repository}/actions/workflows/${workflowId}/enable`;
					} else if (operation === 'get') {
						// ----------------------------------
						//         get
						// ----------------------------------

						requestMethod = 'GET';

						const workflowId = this.getNodeParameter('workflowId', i, '', {
							extractValue: true,
						}) as string;

						endpoint = `/repos/${owner}/${repository}/actions/workflows/${workflowId}`;
					} else if (operation === 'getUsage') {
						// ----------------------------------
						//         getUsage
						// ----------------------------------

						requestMethod = 'GET';

						const workflowId = this.getNodeParameter('workflowId', i, '', {
							extractValue: true,
						}) as string;

						endpoint = `/repos/${owner}/${repository}/actions/workflows/${workflowId}/timing`;
					} else if (operation === 'list') {
						// ----------------------------------
						//         list
						// ----------------------------------

						requestMethod = 'GET';

						endpoint = `/repos/${owner}/${repository}/actions/workflows`;
					}
				} else {
					throw new NodeOperationError(this.getNode(), `The resource "${resource}" is not known!`, {
						itemIndex: i,
					});
				}

				const asBinaryProperty = this.getNodeParameter('asBinaryProperty', i, false) as boolean;
				if (returnAll) {
					responseData = await githubApiRequestAllItems.call(
						this,
						requestMethod,
						endpoint,
						body,
						qs,
					);
				} else {
					responseData = await githubApiRequest.call(this, requestMethod, endpoint, body, qs);
				}

				if (fullOperation === 'file:get') {
					if (asBinaryProperty) {
						if (Array.isArray(responseData) && responseData.length > 1) {
							throw new NodeOperationError(this.getNode(), 'File Path is a folder, not a file.', {
								itemIndex: i,
							});
						}
						// Add the returned data to the item as binary property
						const binaryPropertyName = this.getNodeParameter('binaryPropertyName', i);

						const newItem: INodeExecutionData = {
							json: items[i].json,
							binary: {},
							pairedItem: items[i].pairedItem,
						};

						if (items[i].binary !== undefined) {
							// Create a shallow copy of the binary data so that the old
							// data references which do not get changed still stay behind
							// but the incoming data does not get changed.
							Object.assign(newItem.binary as object, items[i].binary!);
						}
						const { content, path } = responseData;
						newItem.binary![binaryPropertyName] = await this.helpers.prepareBinaryData(
							Buffer.from(content as string, 'base64'),
							path as string,
						);

						returnData.push(newItem);
						continue;
					}
				}

				if (fullOperation === 'release:delete') {
					responseData = { success: true };
				}

				if (
					overwriteDataOperations.includes(fullOperation) ||
					overwriteDataOperationsArray.includes(fullOperation)
				) {
					const executionData = this.helpers.constructExecutionMetaData(
						this.helpers.returnJsonArray(responseData as IDataObject[]),
						{ itemData: { item: i } },
					);
					returnData.push(...executionData);
				}
			} catch (error) {
				if (this.continueOnFail()) {
					if (
						overwriteDataOperations.includes(fullOperation) ||
						overwriteDataOperationsArray.includes(fullOperation)
					) {
						const executionErrorData = this.helpers.constructExecutionMetaData(
							[
								{
									json: {
										error: error.message,
									},
								},
							],
							{ itemData: { item: i } },
						);
						returnData.push(...executionErrorData);
					} else {
						items[i].json = { error: error.message };
					}
					continue;
				}
				throw error;
			}
		}

		if (
			overwriteDataOperations.includes(fullOperation) ||
			overwriteDataOperationsArray.includes(fullOperation)
		) {
			// Return data gets replaced
			return [returnData];
		} else {
			// For all other ones simply return the unchanged items
			return [items];
		}
	}
}


// === File: GithubTrigger.node.ts ===
import type {
	IHookFunctions,
	IWebhookFunctions,
	IDataObject,
	INodeType,
	INodeTypeDescription,
	IWebhookResponseData,
	JsonObject,
} from 'n8n-workflow';
import { NodeConnectionTypes, NodeApiError, NodeOperationError } from 'n8n-workflow';

import { githubApiRequest } from './GenericFunctions';
import { getRepositories, getUsers } from './SearchFunctions';

export class GithubTrigger implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'Github Trigger',
		name: 'githubTrigger',
		icon: { light: 'file:github.svg', dark: 'file:github.dark.svg' },
		group: ['trigger'],
		version: 1,
		subtitle:
			'={{$parameter["owner"] + "/" + $parameter["repository"] + ": " + $parameter["events"].join(", ")}}',
		description: 'Starts the workflow when Github events occur',
		defaults: {
			name: 'Github Trigger',
		},
		inputs: [],
		outputs: [NodeConnectionTypes.Main],
		credentials: [
			{
				name: 'githubApi',
				required: true,
				displayOptions: {
					show: {
						authentication: ['accessToken'],
					},
				},
			},
			{
				name: 'githubOAuth2Api',
				required: true,
				displayOptions: {
					show: {
						authentication: ['oAuth2'],
					},
				},
			},
		],
		webhooks: [
			{
				name: 'default',
				httpMethod: 'POST',
				responseMode: 'onReceived',
				path: 'webhook',
			},
		],
		properties: [
			{
				displayName:
					'Only members with owner privileges for an organization or admin privileges for a repository can set up the webhooks this node requires.',
				name: 'notice',
				type: 'notice',
				default: '',
			},
			{
				displayName: 'Authentication',
				name: 'authentication',
				type: 'options',
				options: [
					{
						name: 'Access Token',
						value: 'accessToken',
					},
					{
						name: 'OAuth2',
						value: 'oAuth2',
					},
				],
				default: 'accessToken',
			},
			{
				displayName: 'Repository Owner',
				name: 'owner',
				type: 'resourceLocator',
				default: { mode: 'list', value: '' },
				required: true,
				modes: [
					{
						displayName: 'Repository Owner',
						name: 'list',
						type: 'list',
						placeholder: 'Select an owner...',
						typeOptions: {
							searchListMethod: 'getUsers',
							searchable: true,
							searchFilterRequired: true,
						},
					},
					{
						displayName: 'Link',
						name: 'url',
						type: 'string',
						placeholder: 'e.g. https://github.com/n8n-io',
						extractValue: {
							type: 'regex',
							regex: 'https:\\/\\/github.com\\/([-_0-9a-zA-Z]+)',
						},
						validation: [
							{
								type: 'regex',
								properties: {
									regex: 'https:\\/\\/github.com\\/([-_0-9a-zA-Z]+)(?:.*)',
									errorMessage: 'Not a valid Github URL',
								},
							},
						],
					},
					{
						displayName: 'By Name',
						name: 'name',
						type: 'string',
						placeholder: 'e.g. n8n-io',
						validation: [
							{
								type: 'regex',
								properties: {
									regex: '[-_a-zA-Z0-9]+',
									errorMessage: 'Not a valid Github Owner Name',
								},
							},
						],
						url: '=https://github.com/{{$value}}',
					},
				],
			},
			{
				displayName: 'Repository Name',
				name: 'repository',
				type: 'resourceLocator',
				default: { mode: 'list', value: '' },
				required: true,
				modes: [
					{
						displayName: 'Repository Name',
						name: 'list',
						type: 'list',
						placeholder: 'Select an Repository...',
						typeOptions: {
							searchListMethod: 'getRepositories',
							searchable: true,
						},
					},
					{
						displayName: 'Link',
						name: 'url',
						type: 'string',
						placeholder: 'e.g. https://github.com/n8n-io/n8n',
						extractValue: {
							type: 'regex',
							regex: 'https:\\/\\/github.com\\/(?:[-_0-9a-zA-Z]+)\\/([-_.0-9a-zA-Z]+)',
						},
						validation: [
							{
								type: 'regex',
								properties: {
									regex: 'https:\\/\\/github.com\\/(?:[-_0-9a-zA-Z]+)\\/([-_.0-9a-zA-Z]+)(?:.*)',
									errorMessage: 'Not a valid Github Repository URL',
								},
							},
						],
					},
					{
						displayName: 'By Name',
						name: 'name',
						type: 'string',
						placeholder: 'e.g. n8n',
						validation: [
							{
								type: 'regex',
								properties: {
									regex: '[-_.0-9a-zA-Z]+',
									errorMessage: 'Not a valid Github Repository Name',
								},
							},
						],
						url: '=https://github.com/{{$parameter["owner"]}}/{{$value}}',
					},
				],
			},
			{
				displayName: 'Events',
				name: 'events',
				type: 'multiOptions',
				options: [
					{
						name: '*',
						value: '*',
						description: 'Any time any event is triggered (Wildcard Event)',
					},
					{
						name: 'Check Run',
						value: 'check_run',
						description:
							'Triggered when a check run is created, rerequested, completed, or has a requested_action',
					},
					{
						name: 'Check Suite',
						value: 'check_suite',
						description: 'Triggered when a check suite is completed, requested, or rerequested',
					},
					{
						name: 'Commit Comment',
						value: 'commit_comment',
						description: 'Triggered when a commit comment is created',
					},
					{
						name: 'Create',
						value: 'create',
						description: 'Represents a created repository, branch, or tag',
					},
					{
						name: 'Delete',
						value: 'delete',
						description: 'Represents a deleted branch or tag',
					},
					{
						name: 'Deploy Key',
						value: 'deploy_key',
						description: 'Triggered when a deploy key is added or removed from a repository',
					},
					{
						name: 'Deployment',
						value: 'deployment',
						description: 'Represents a deployment',
					},
					{
						name: 'Deployment Status',
						value: 'deployment_status',
						description: 'Represents a deployment status',
					},
					{
						name: 'Fork',
						value: 'fork',
						description: 'Triggered when a user forks a repository',
					},
					{
						name: 'Github App Authorization',
						value: 'github_app_authorization',
						description: 'Triggered when someone revokes their authorization of a GitHub App',
					},
					{
						name: 'Gollum',
						value: 'gollum',
						description: 'Triggered when a Wiki page is created or updated',
					},
					{
						name: 'Installation',
						value: 'installation',
						description:
							'Triggered when someone installs (created), uninstalls (deleted), or accepts new permissions (new_permissions_accepted) for a GitHub App. When a GitHub App owner requests new permissions, the person who installed the GitHub App must accept the new permissions request.',
					},
					{
						name: 'Installation Repositories',
						value: 'installation_repositories',
						description: 'Triggered when a repository is added or removed from an installation',
					},
					{
						name: 'Issue Comment',
						value: 'issue_comment',
						description: 'Triggered when an issue comment is created, edited, or deleted',
					},
					{
						name: 'Issues',
						value: 'issues',
						description:
							'Triggered when an issue is opened, edited, deleted, transferred, pinned, unpinned, closed, reopened, assigned, unassigned, labeled, unlabeled, locked, unlocked, milestoned, or demilestoned',
					},
					{
						name: 'Label',
						value: 'label',
						description: "Triggered when a repository's label is created, edited, or deleted",
					},
					{
						name: 'Marketplace Purchase',
						value: 'marketplace_purchase',
						description:
							'Triggered when someone purchases a GitHub Marketplace plan, cancels their plan, upgrades their plan (effective immediately), downgrades a plan that remains pending until the end of the billing cycle, or cancels a pending plan change',
					},
					{
						name: 'Member',
						value: 'member',
						description:
							'Triggered when a user accepts an invitation or is removed as a collaborator to a repository, or has their permissions changed',
					},
					{
						name: 'Membership',
						value: 'membership',
						description:
							'Triggered when a user is added or removed from a team. Organization hooks only.',
					},
					{
						name: 'Meta',
						value: 'meta',
						description: 'Triggered when the webhook that this event is configured on is deleted',
					},
					{
						name: 'Milestone',
						value: 'milestone',
						description:
							'Triggered when a milestone is created, closed, opened, edited, or deleted',
					},
					{
						name: 'Org Block',
						value: 'org_block',
						description:
							'Triggered when an organization blocks or unblocks a user. Organization hooks only.',
					},
					{
						name: 'Organization',
						value: 'organization',
						description:
							'Triggered when an organization is deleted and renamed, and when a user is added, removed, or invited to an organization. Organization hooks only.',
					},
					{
						name: 'Page Build',
						value: 'page_build',
						description:
							'Triggered on push to a GitHub Pages enabled branch (gh-pages for project pages, master for user and organization pages)',
					},
					{
						name: 'Project',
						value: 'project',
						description:
							'Triggered when a project is created, updated, closed, reopened, or deleted',
					},
					{
						name: 'Project Card',
						value: 'project_card',
						description:
							'Triggered when a project card is created, edited, moved, converted to an issue, or deleted',
					},
					{
						name: 'Project Column',
						value: 'project_column',
						description: 'Triggered when a project column is created, updated, moved, or deleted',
					},
					{
						name: 'Public',
						value: 'public',
						description: 'Triggered when a private repository is open sourced',
					},
					{
						name: 'Pull Request',
						value: 'pull_request',
						description:
							'Triggered when a pull request is assigned, unassigned, labeled, unlabeled, opened, edited, closed, reopened, synchronize, ready_for_review, locked, unlocked, a pull request review is requested, or a review request is removed',
					},
					{
						name: 'Pull Request Review',
						value: 'pull_request_review',
						description:
							'Triggered when a pull request review is submitted into a non-pending state, the body is edited, or the review is dismissed',
					},
					{
						name: 'Pull Request Review Comment',
						value: 'pull_request_review_comment',
						description:
							"Triggered when a comment on a pull request's unified diff is created, edited, or deleted (in the Files Changed tab)",
					},
					{
						name: 'Push',
						value: 'push',
						description:
							'Triggered on a push to a repository branch. Branch pushes and repository tag pushes also trigger webhook push events. This is the default event.',
					},
					{
						name: 'Release',
						value: 'release',
						description:
							'Triggered when a release is published, unpublished, created, edited, deleted, or prereleased',
					},
					{
						name: 'Repository',
						value: 'repository',
						description:
							'Triggered when a repository is created, archived, unarchived, renamed, edited, transferred, made public, or made private. Organization hooks are also triggered when a repository is deleted.',
					},
					{
						name: 'Repository Import',
						value: 'repository_import',
						description:
							'Triggered when a successful, cancelled, or failed repository import finishes for a GitHub organization or a personal repository',
					},
					{
						name: 'Repository Vulnerability Alert',
						value: 'repository_vulnerability_alert',
						description: 'Triggered when a security alert is created, dismissed, or resolved',
					},
					{
						name: 'Security Advisory',
						value: 'security_advisory',
						description:
							'Triggered when a new security advisory is published, updated, or withdrawn',
					},
					{
						name: 'Star',
						value: 'star',
						description: 'Triggered when a star is added or removed from a repository',
					},
					{
						name: 'Status',
						value: 'status',
						description: 'Triggered when the status of a Git commit changes',
					},
					{
						name: 'Team',
						value: 'team',
						description:
							"Triggered when an organization's team is created, deleted, edited, added_to_repository, or removed_from_repository. Organization hooks only.",
					},
					{
						name: 'Team Add',
						value: 'team_add',
						description: 'Triggered when a repository is added to a team',
					},
					{
						name: 'Watch',
						value: 'watch',
						description: 'Triggered when someone stars a repository',
					},
				],
				required: true,
				default: [],
				description: 'The events to listen to',
			},
			{
				displayName: 'Options',
				name: 'options',
				type: 'collection',
				placeholder: 'Add option',
				default: {},
				options: [
					{
						displayName: 'Insecure SSL',
						name: 'insecureSSL',
						type: 'boolean',
						default: false,
						description:
							'Whether the SSL certificate of the n8n host be verified by GitHub when delivering payloads',
					},
				],
			},
		],
	};

	webhookMethods = {
		default: {
			async checkExists(this: IHookFunctions): Promise<boolean> {
				const webhookData = this.getWorkflowStaticData('node');

				if (webhookData.webhookId === undefined) {
					// No webhook id is set so no webhook can exist
					return false;
				}

				// Webhook got created before so check if it still exists
				const owner = this.getNodeParameter('owner', '', { extractValue: true }) as string;
				const repository = this.getNodeParameter('repository', '', {
					extractValue: true,
				}) as string;
				const endpoint = `/repos/${owner}/${repository}/hooks/${webhookData.webhookId}`;

				try {
					await githubApiRequest.call(this, 'GET', endpoint, {});
				} catch (error) {
					if (error.httpCode === '404') {
						// Webhook does not exist
						delete webhookData.webhookId;
						delete webhookData.webhookEvents;

						return false;
					}

					// Some error occurred
					throw error;
				}
				// If it did not error then the webhook exists
				return true;
			},
			async create(this: IHookFunctions): Promise<boolean> {
				const webhookUrl = this.getNodeWebhookUrl('default') as string;

				if (webhookUrl.includes('//localhost')) {
					throw new NodeOperationError(
						this.getNode(),
						'The Webhook can not work on "localhost". Please, either setup n8n on a custom domain or start with "--tunnel"!',
					);
				}

				const owner = this.getNodeParameter('owner', '', { extractValue: true }) as string;
				const repository = this.getNodeParameter('repository', '', {
					extractValue: true,
				}) as string;
				const events = this.getNodeParameter('events', []);

				const endpoint = `/repos/${owner}/${repository}/hooks`;
				const options = this.getNodeParameter('options') as { insecureSSL: boolean };

				const body = {
					name: 'web',
					config: {
						url: webhookUrl,
						content_type: 'json',
						insecure_ssl: options.insecureSSL ? '1' : '0',
					},
					events,
					active: true,
				};

				const webhookData = this.getWorkflowStaticData('node');

				let responseData;
				try {
					responseData = await githubApiRequest.call(this, 'POST', endpoint, body);
				} catch (error) {
					if (error.httpCode === '422') {
						// Webhook exists already

						// Get the data of the already registered webhook
						responseData = await githubApiRequest.call(this, 'GET', endpoint, body);

						for (const webhook of responseData as IDataObject[]) {
							if ((webhook.config! as IDataObject).url! === webhookUrl) {
								// Webhook got found
								if (JSON.stringify(webhook.events) === JSON.stringify(events)) {
									// Webhook with same events exists already so no need to
									// create it again simply save the webhook-id
									webhookData.webhookId = webhook.id as string;
									webhookData.webhookEvents = webhook.events as string[];
									return true;
								}
							}
						}

						throw new NodeOperationError(
							this.getNode(),
							'A webhook with the identical URL probably exists already. Please delete it manually on Github!',
							{ level: 'warning' },
						);
					}

					if (error.httpCode === '404') {
						throw new NodeOperationError(
							this.getNode(),
							'Check that the repository exists and that you have permission to create the webhooks this node requires',
							{ level: 'warning' },
						);
					}

					throw error;
				}

				if (responseData.id === undefined || responseData.active !== true) {
					// Required data is missing so was not successful
					throw new NodeApiError(this.getNode(), responseData as JsonObject, {
						message: 'Github webhook creation response did not contain the expected data.',
					});
				}

				webhookData.webhookId = responseData.id as string;
				webhookData.webhookEvents = responseData.events as string[];

				return true;
			},
			async delete(this: IHookFunctions): Promise<boolean> {
				const webhookData = this.getWorkflowStaticData('node');

				if (webhookData.webhookId !== undefined) {
					const owner = this.getNodeParameter('owner', '', { extractValue: true }) as string;
					const repository = this.getNodeParameter('repository', '', {
						extractValue: true,
					}) as string;
					const endpoint = `/repos/${owner}/${repository}/hooks/${webhookData.webhookId}`;
					const body = {};

					try {
						await githubApiRequest.call(this, 'DELETE', endpoint, body);
					} catch (error) {
						return false;
					}

					// Remove from the static workflow data so that it is clear
					// that no webhooks are registered anymore
					delete webhookData.webhookId;
					delete webhookData.webhookEvents;
				}

				return true;
			},
		},
	};

	methods = {
		listSearch: {
			getUsers,
			getRepositories,
		},
	};

	async webhook(this: IWebhookFunctions): Promise<IWebhookResponseData> {
		const bodyData = this.getBodyData();

		// Check if the webhook is only the ping from Github to confirm if it workshook_id
		if (bodyData.hook_id !== undefined && bodyData.action === undefined) {
			// Is only the ping and not an actual webhook call. So return 'OK'
			// but do not start the workflow.

			return {
				webhookResponse: 'OK',
			};
		}

		// Is a regular webhook call

		// TODO: Add headers & requestPath
		const returnData: IDataObject[] = [];

		returnData.push({
			body: bodyData,
			headers: this.getHeaderData(),
			query: this.getQueryData(),
		});

		return {
			workflowData: [this.helpers.returnJsonArray(returnData)],
		};
	}
}


// === File: SearchFunctions.ts ===
import type {
	ILoadOptionsFunctions,
	INodeListSearchItems,
	INodeListSearchResult,
} from 'n8n-workflow';

import { githubApiRequest } from './GenericFunctions';

type UserSearchItem = {
	login: string;
	html_url: string;
};

type RepositorySearchItem = {
	name: string;
	html_url: string;
};

type UserSearchResponse = {
	items: UserSearchItem[];
	total_count: number;
};

type RepositorySearchResponse = {
	items: RepositorySearchItem[];
	total_count: number;
};

type RefItem = {
	ref: string;
};

export async function getUsers(
	this: ILoadOptionsFunctions,
	filter?: string,
	paginationToken?: string,
): Promise<INodeListSearchResult> {
	const page = paginationToken ? +paginationToken : 1;
	const per_page = 100;

	let responseData: UserSearchResponse = {
		items: [],
		total_count: 0,
	};

	try {
		responseData = await githubApiRequest.call(
			this,
			'GET',
			'/search/users',
			{},
			{ q: filter, page, per_page },
		);
	} catch {
		// will fail if the owner does not have any users
	}

	const results: INodeListSearchItems[] = responseData.items.map((item: UserSearchItem) => ({
		name: item.login,
		value: item.login,
		url: item.html_url,
	}));

	const nextPaginationToken = page * per_page < responseData.total_count ? page + 1 : undefined;
	return { results, paginationToken: nextPaginationToken };
}

export async function getRepositories(
	this: ILoadOptionsFunctions,
	filter?: string,
	paginationToken?: string,
): Promise<INodeListSearchResult> {
	const owner = this.getCurrentNodeParameter('owner', { extractValue: true });
	const page = paginationToken ? +paginationToken : 1;
	const per_page = 100;
	const q = `${filter ?? ''} user:${owner} fork:true`;
	let responseData: RepositorySearchResponse = {
		items: [],
		total_count: 0,
	};

	try {
		responseData = await githubApiRequest.call(
			this,
			'GET',
			'/search/repositories',
			{},
			{ q, page, per_page },
		);
	} catch {
		// will fail if the owner does not have any repositories
	}

	const results: INodeListSearchItems[] = responseData.items.map((item: RepositorySearchItem) => ({
		name: item.name,
		value: item.name,
		url: item.html_url,
	}));

	const nextPaginationToken = page * per_page < responseData.total_count ? page + 1 : undefined;
	return { results, paginationToken: nextPaginationToken };
}

export async function getWorkflows(
	this: ILoadOptionsFunctions,
	paginationToken?: string,
): Promise<INodeListSearchResult> {
	const owner = this.getCurrentNodeParameter('owner', { extractValue: true });
	const repository = this.getCurrentNodeParameter('repository', { extractValue: true });
	const page = paginationToken ? +paginationToken : 1;
	const per_page = 100;
	const endpoint = `/repos/${owner}/${repository}/actions/workflows`;
	let responseData: { workflows: Array<{ id: string; name: string }>; total_count: number } = {
		workflows: [],
		total_count: 0,
	};

	try {
		responseData = await githubApiRequest.call(this, 'GET', endpoint, {}, { page, per_page });
	} catch {
		// will fail if the repository does not have any workflows
	}

	const results: INodeListSearchItems[] = responseData.workflows.map((workflow) => ({
		name: workflow.name,
		value: workflow.id,
	}));

	const nextPaginationToken = page * per_page < responseData.total_count ? page + 1 : undefined;
	return { results, paginationToken: nextPaginationToken };
}

export async function getRefs(
	this: ILoadOptionsFunctions,
	filter?: string,
	paginationToken?: string,
): Promise<INodeListSearchResult> {
	const owner = this.getCurrentNodeParameter('owner', { extractValue: true });
	const repository = this.getCurrentNodeParameter('repository', { extractValue: true });
	const page = paginationToken ? +paginationToken : 1;
	const per_page = 100;

	const responseData: RefItem[] = await githubApiRequest.call(
		this,
		'GET',
		`/repos/${owner}/${repository}/git/refs`,
		{},
		{ page, per_page },
	);

	const refs: INodeListSearchItems[] = [];

	for (const ref of responseData) {
		const refPath = ref.ref.split('/');
		const refType = refPath[1];
		const refName = refPath.slice(2).join('/');

		let description = '';
		if (refType === 'heads') {
			description = `Branch: ${refName}`;
		} else if (refType === 'tags') {
			description = `Tag: ${refName}`;
		} else {
			description = `${refType}: ${refName}`;
		}

		refs.push({
			name: refName,
			value: refName,
			description,
		});
	}

	if (filter) {
		const filteredRefs = refs.filter((ref) =>
			ref.name.toLowerCase().includes(filter.toLowerCase()),
		);
		return { results: filteredRefs };
	}
	const nextPaginationToken = responseData.length === per_page ? page + 1 : undefined;
	return { results: refs, paginationToken: nextPaginationToken };
}


// === File: __tests__/GenericFunctions.test.ts ===
import type { IExecuteFunctions, IHookFunctions } from 'n8n-workflow';
import { NodeApiError, NodeOperationError } from 'n8n-workflow';

import {
	githubApiRequest,
	getFileSha,
	githubApiRequestAllItems,
	isBase64,
	validateJSON,
} from '../GenericFunctions';

const mockExecuteHookFunctions = {
	getNodeParameter: jest.fn().mockImplementation((param: string) => {
		if (param === 'authentication') return 'accessToken';
		return undefined;
	}),
	getCredentials: jest.fn().mockResolvedValue({
		server: 'https://api.github.com',
	}),
	helpers: {
		requestWithAuthentication: jest.fn(),
	},
	getCurrentNodeParameter: jest.fn(),
	getWebhookName: jest.fn(),
	getWebhookDescription: jest.fn(),
	getNodeWebhookUrl: jest.fn(),
	getNode: jest.fn().mockReturnValue({
		id: 'test-node-id',
		name: 'test-node',
	}),
} as unknown as IExecuteFunctions | IHookFunctions;

describe('GenericFunctions', () => {
	beforeEach(() => {
		jest.clearAllMocks();
	});

	describe('githubApiRequest', () => {
		it('should make a successful API request', async () => {
			const method = 'GET';
			const endpoint = '/repos/test-owner/test-repo';
			const body = {};
			const responseData = { id: 123, name: 'test-repo' };

			(mockExecuteHookFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await githubApiRequest.call(mockExecuteHookFunctions, method, endpoint, body);

			expect(result).toEqual(responseData);
			expect(mockExecuteHookFunctions.helpers.requestWithAuthentication).toHaveBeenCalledWith(
				'githubApi',
				{
					method: 'GET',
					headers: { 'User-Agent': 'n8n' },
					body: {},
					qs: undefined,
					uri: 'https://api.github.com/repos/test-owner/test-repo',
					json: true,
				},
			);
		});

		it('should throw a NodeApiError on API failure', async () => {
			const method = 'GET';
			const endpoint = '/repos/test-owner/test-repo';
			const body = {};
			const error = new Error('API Error');

			(mockExecuteHookFunctions.helpers.requestWithAuthentication as jest.Mock).mockRejectedValue(
				error,
			);

			await expect(
				githubApiRequest.call(mockExecuteHookFunctions, method, endpoint, body),
			).rejects.toThrow(NodeApiError);
		});
	});

	describe('getFileSha', () => {
		it('should return the SHA of a file', async () => {
			const owner = 'test-owner';
			const repository = 'test-repo';
			const filePath = 'README.md';
			const branch = 'main';
			const responseData = { sha: 'abc123' };

			(mockExecuteHookFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await getFileSha.call(
				mockExecuteHookFunctions,
				owner,
				repository,
				filePath,
				branch,
			);

			expect(result).toBe('abc123');
			expect(mockExecuteHookFunctions.helpers.requestWithAuthentication).toHaveBeenCalledWith(
				'githubApi',
				{
					method: 'GET',
					headers: { 'User-Agent': 'n8n' },
					body: {},
					qs: { ref: 'main' },
					uri: 'https://api.github.com/repos/test-owner/test-repo/contents/README.md',
					json: true,
				},
			);
		});

		it('should throw a NodeOperationError if SHA is missing', async () => {
			const owner = 'test-owner';
			const repository = 'test-repo';
			const filePath = 'README.md';
			const responseData = {};

			(mockExecuteHookFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			await expect(
				getFileSha.call(mockExecuteHookFunctions, owner, repository, filePath),
			).rejects.toThrow(NodeOperationError);
		});
	});

	describe('githubApiRequestAllItems', () => {
		it('should fetch all items with pagination', async () => {
			const method = 'GET';
			const endpoint = '/repos/test-owner/test-repo/issues';
			const body = {};
			const query = { state: 'open' };
			const responseData1 = [{ id: 1, title: 'Issue 1' }];
			const responseData2 = [{ id: 2, title: 'Issue 2' }];

			(mockExecuteHookFunctions.helpers.requestWithAuthentication as jest.Mock)
				.mockResolvedValueOnce({ headers: { link: 'next' }, body: responseData1 })
				.mockResolvedValueOnce({ headers: {}, body: responseData2 });

			const result = await githubApiRequestAllItems.call(
				mockExecuteHookFunctions,
				method,
				endpoint,
				body,
				query,
			);

			expect(result).toEqual([...responseData1, ...responseData2]);
			expect(mockExecuteHookFunctions.helpers.requestWithAuthentication).toHaveBeenCalledTimes(2);
		});
	});

	describe('isBase64', () => {
		it('should return true for valid Base64 strings', () => {
			expect(isBase64('aGVsbG8gd29ybGQ=')).toBe(true);
			expect(isBase64('Zm9vYmFy')).toBe(true);
		});

		it('should return false for invalid Base64 strings', () => {
			expect(isBase64('not base64')).toBe(false);
			expect(isBase64('123!@#')).toBe(false);
		});
	});

	describe('validateJSON', () => {
		it('should return parsed JSON for valid JSON strings', () => {
			const jsonString = '{"key": "value"}';
			const result = validateJSON(jsonString);

			expect(result).toEqual({ key: 'value' });
		});

		it('should return undefined for invalid JSON strings', () => {
			const invalidJsonString = 'not json';
			const result = validateJSON(invalidJsonString);

			expect(result).toBeUndefined();
		});
	});
});


// === File: __tests__/SearchFunctions.test.ts ===
import type { ILoadOptionsFunctions } from 'n8n-workflow';

import { getUsers, getRepositories, getWorkflows, getRefs } from '../SearchFunctions';

const mockLoadOptionsFunctions = {
	getNodeParameter: jest.fn(),
	getCredentials: jest.fn().mockResolvedValue({
		server: 'https://api.github.com',
	}),
	helpers: {
		requestWithAuthentication: jest.fn(),
	},
	getCurrentNodeParameter: jest.fn(),
} as unknown as ILoadOptionsFunctions;

describe('Search Functions', () => {
	beforeEach(() => {
		jest.clearAllMocks();
	});

	describe('getUsers', () => {
		it('should fetch users', async () => {
			const filter = 'test-user';
			const responseData = {
				items: [
					{ login: 'test-user-1', html_url: 'https://github.com/test-user-1' },
					{ login: 'test-user-2', html_url: 'https://github.com/test-user-2' },
				],
				total_count: 2,
			};

			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await getUsers.call(mockLoadOptionsFunctions, filter);

			expect(result).toEqual({
				results: [
					{ name: 'test-user-1', value: 'test-user-1', url: 'https://github.com/test-user-1' },
					{ name: 'test-user-2', value: 'test-user-2', url: 'https://github.com/test-user-2' },
				],
				paginationToken: undefined,
			});

			expect(mockLoadOptionsFunctions.helpers.requestWithAuthentication).toHaveBeenCalledWith(
				'githubOAuth2Api',
				expect.objectContaining({
					method: 'GET',
					qs: expect.objectContaining({ page: 1 }),
				}),
			);
		});

		it('should handle pagination', async () => {
			const filter = 'test-user';
			const responseData = {
				items: [
					{ login: 'test-user-1', html_url: 'https://github.com/test-user-1' },
					{ login: 'test-user-2', html_url: 'https://github.com/test-user-2' },
				],
				total_count: 200,
			};

			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await getUsers.call(mockLoadOptionsFunctions, filter);

			expect(result).toEqual({
				results: [
					{ name: 'test-user-1', value: 'test-user-1', url: 'https://github.com/test-user-1' },
					{ name: 'test-user-2', value: 'test-user-2', url: 'https://github.com/test-user-2' },
				],
				paginationToken: 2,
			});
		});

		it('should use paginationToken when provided', async () => {
			const filter = 'test-user';
			const paginationToken = '3';
			const responseData = {
				items: [
					{ login: 'test-user-5', html_url: 'https://github.com/test-user-5' },
					{ login: 'test-user-6', html_url: 'https://github.com/test-user-6' },
				],
				total_count: 200,
			};

			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await getUsers.call(mockLoadOptionsFunctions, filter, paginationToken);

			expect(result).toEqual({
				results: [
					{ name: 'test-user-5', value: 'test-user-5', url: 'https://github.com/test-user-5' },
					{ name: 'test-user-6', value: 'test-user-6', url: 'https://github.com/test-user-6' },
				],
				paginationToken: undefined,
			});

			expect(mockLoadOptionsFunctions.helpers.requestWithAuthentication).toHaveBeenCalledWith(
				'githubOAuth2Api',
				expect.objectContaining({
					method: 'GET',
					qs: expect.objectContaining({ page: 3 }),
				}),
			);
		});
	});

	describe('getRepositories', () => {
		it('should fetch repositories', async () => {
			const filter = 'test-repo';
			const owner = 'test-owner';
			const responseData = {
				items: [
					{ name: 'test-repo-1', html_url: 'https://github.com/test-owner/test-repo-1' },
					{ name: 'test-repo-2', html_url: 'https://github.com/test-owner/test-repo-2' },
				],
				total_count: 2,
			};

			(mockLoadOptionsFunctions.getCurrentNodeParameter as jest.Mock).mockReturnValue(owner);
			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await getRepositories.call(mockLoadOptionsFunctions, filter);

			expect(result).toEqual({
				results: [
					{
						name: 'test-repo-1',
						value: 'test-repo-1',
						url: 'https://github.com/test-owner/test-repo-1',
					},
					{
						name: 'test-repo-2',
						value: 'test-repo-2',
						url: 'https://github.com/test-owner/test-repo-2',
					},
				],
				paginationToken: undefined,
			});
		});

		it('should fetch repositories without filter', async () => {
			const owner = 'test-owner';
			const responseData = {
				items: [
					{ name: 'test-repo-1', html_url: 'https://github.com/test-owner/test-repo-1' },
					{ name: 'test-repo-2', html_url: 'https://github.com/test-owner/test-repo-2' },
				],
				total_count: 2,
			};

			(mockLoadOptionsFunctions.getCurrentNodeParameter as jest.Mock).mockReturnValue(owner);
			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await getRepositories.call(mockLoadOptionsFunctions);

			expect(result).toEqual({
				results: [
					{
						name: 'test-repo-1',
						value: 'test-repo-1',
						url: 'https://github.com/test-owner/test-repo-1',
					},
					{
						name: 'test-repo-2',
						value: 'test-repo-2',
						url: 'https://github.com/test-owner/test-repo-2',
					},
				],
				paginationToken: undefined,
			});
		});

		it('should use paginationToken when provided', async () => {
			const filter = 'test-repo';
			const paginationToken = '3';
			const owner = 'test-owner';
			const responseData = {
				items: [
					{ name: 'test-repo-5', html_url: 'https://github.com/test-owner/test-repo-5' },
					{ name: 'test-repo-6', html_url: 'https://github.com/test-owner/test-repo-6' },
				],
				total_count: 200,
			};

			(mockLoadOptionsFunctions.getCurrentNodeParameter as jest.Mock).mockReturnValue(owner);
			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await getRepositories.call(mockLoadOptionsFunctions, filter, paginationToken);

			expect(result).toEqual({
				results: [
					{
						name: 'test-repo-5',
						value: 'test-repo-5',
						url: 'https://github.com/test-owner/test-repo-5',
					},
					{
						name: 'test-repo-6',
						value: 'test-repo-6',
						url: 'https://github.com/test-owner/test-repo-6',
					},
				],
				paginationToken: undefined,
			});

			expect(mockLoadOptionsFunctions.helpers.requestWithAuthentication).toHaveBeenCalledWith(
				'githubOAuth2Api',
				expect.objectContaining({
					method: 'GET',
					qs: expect.objectContaining({ page: 3 }),
				}),
			);
		});

		it('should handle empty repositories', async () => {
			const filter = 'test-repo';
			const owner = 'test-owner';
			const responseData = {
				items: [],
				total_count: 0,
			};

			(mockLoadOptionsFunctions.getCurrentNodeParameter as jest.Mock).mockReturnValue(owner);
			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await getRepositories.call(mockLoadOptionsFunctions, filter);

			expect(result).toEqual({
				results: [],
				paginationToken: undefined,
			});
		});
	});

	describe('getWorkflows', () => {
		it('should fetch workflows', async () => {
			const owner = 'test-owner';
			const repository = 'test-repo';
			const responseData = {
				workflows: [
					{ id: '1', name: 'workflow-1' },
					{ id: '2', name: 'workflow-2' },
				],
				total_count: 2,
			};

			(mockLoadOptionsFunctions.getCurrentNodeParameter as jest.Mock)
				.mockReturnValueOnce(owner)
				.mockReturnValueOnce(repository);
			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await getWorkflows.call(mockLoadOptionsFunctions);

			expect(result).toEqual({
				results: [
					{ name: 'workflow-1', value: '1' },
					{ name: 'workflow-2', value: '2' },
				],
				paginationToken: undefined,
			});
		});

		it('should handle pagination', async () => {
			const owner = 'test-owner';
			const repository = 'test-repo';
			const responseData = {
				workflows: [
					{ id: '1', name: 'workflow-1' },
					{ id: '2', name: 'workflow-2' },
				],
				total_count: 200,
			};

			(mockLoadOptionsFunctions.getCurrentNodeParameter as jest.Mock)
				.mockReturnValueOnce(owner)
				.mockReturnValueOnce(repository);
			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await getWorkflows.call(mockLoadOptionsFunctions);

			expect(result).toEqual({
				results: [
					{ name: 'workflow-1', value: '1' },
					{ name: 'workflow-2', value: '2' },
				],
				paginationToken: 2,
			});
		});

		it('should use paginationToken when provided and return next page token', async () => {
			const paginationToken = '1';
			const owner = 'test-owner';
			const repository = 'test-repo';
			const responseData = {
				workflows: [
					{ id: '3', name: 'workflow-3' },
					{ id: '4', name: 'workflow-4' },
				],
				total_count: 300,
			};

			(mockLoadOptionsFunctions.getCurrentNodeParameter as jest.Mock)
				.mockReturnValueOnce(owner)
				.mockReturnValueOnce(repository);
			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await getWorkflows.call(mockLoadOptionsFunctions, paginationToken);

			expect(result).toEqual({
				results: [
					{ name: 'workflow-3', value: '3' },
					{ name: 'workflow-4', value: '4' },
				],
				paginationToken: 2,
			});

			expect(mockLoadOptionsFunctions.helpers.requestWithAuthentication).toHaveBeenCalledWith(
				'githubOAuth2Api',
				expect.objectContaining({
					method: 'GET',
					qs: expect.objectContaining({ page: 1 }),
				}),
			);
		});

		it('should handle empty workflows', async () => {
			const owner = 'test-owner';
			const repository = 'test-repo';
			const responseData = {
				workflows: [],
				total_count: 0,
			};

			(mockLoadOptionsFunctions.getCurrentNodeParameter as jest.Mock)
				.mockReturnValueOnce(owner)
				.mockReturnValueOnce(repository);
			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				responseData,
			);

			const result = await getWorkflows.call(mockLoadOptionsFunctions);

			expect(result).toEqual({
				results: [],
				paginationToken: undefined,
			});
		});
	});

	describe('getRefs', () => {
		it('should fetch branches and tags using git/refs endpoint', async () => {
			const owner = 'test-owner';
			const repository = 'test-repo';
			const refsResponse = [
				{ ref: 'refs/heads/Main' },
				{ ref: 'refs/heads/Dev' },
				{ ref: 'refs/tags/v1.0.0' },
				{ ref: 'refs/tags/v2.0.0' },
				{ ref: 'refs/Pull/123/head' },
			];

			(mockLoadOptionsFunctions.getCurrentNodeParameter as jest.Mock).mockImplementation(
				(param: string) => {
					if (param === 'owner') return owner;
					if (param === 'repository') return repository;
				},
			);

			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				refsResponse,
			);

			const result = await getRefs.call(mockLoadOptionsFunctions);

			expect(result).toEqual({
				results: [
					{ name: 'Main', value: 'Main', description: 'Branch: Main' },
					{ name: 'Dev', value: 'Dev', description: 'Branch: Dev' },
					{ name: 'v1.0.0', value: 'v1.0.0', description: 'Tag: v1.0.0' },
					{ name: 'v2.0.0', value: 'v2.0.0', description: 'Tag: v2.0.0' },
					{ name: '123/head', value: '123/head', description: 'Pull: 123/head' },
				],
				paginationToken: undefined,
			});
		});

		it('should use paginationToken when provided', async () => {
			const paginationToken = '3';
			const owner = 'test-owner';
			const repository = 'test-repo';
			const refsResponse = [{ ref: 'refs/heads/branch-5' }, { ref: 'refs/heads/branch-6' }];

			(mockLoadOptionsFunctions.getCurrentNodeParameter as jest.Mock).mockImplementation(
				(param: string) => {
					if (param === 'owner') return owner;
					if (param === 'repository') return repository;
				},
			);

			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				refsResponse,
			);

			const result = await getRefs.call(mockLoadOptionsFunctions, undefined, paginationToken);

			expect(result).toEqual({
				results: [
					{ name: 'branch-5', value: 'branch-5', description: 'Branch: branch-5' },
					{ name: 'branch-6', value: 'branch-6', description: 'Branch: branch-6' },
				],
				paginationToken: undefined,
			});

			expect(mockLoadOptionsFunctions.helpers.requestWithAuthentication).toHaveBeenCalledWith(
				'githubOAuth2Api',
				expect.objectContaining({
					method: 'GET',
					qs: expect.objectContaining({ page: 3 }),
				}),
			);
		});

		it('should filter refs based on the provided filter', async () => {
			const owner = 'test-owner';
			const repository = 'test-repo';
			const refsResponse = [
				{ ref: 'refs/heads/main' },
				{ ref: 'refs/heads/dev' },
				{ ref: 'refs/tags/v1.0.0' },
				{ ref: 'refs/tags/v2.0.0' },
			];

			(mockLoadOptionsFunctions.getCurrentNodeParameter as jest.Mock).mockImplementation(
				(param: string) => {
					if (param === 'owner') return owner;
					if (param === 'repository') return repository;
				},
			);

			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				refsResponse,
			);

			const result = await getRefs.call(mockLoadOptionsFunctions, 'v1');

			expect(result).toEqual({
				results: [{ name: 'v1.0.0', value: 'v1.0.0', description: 'Tag: v1.0.0' }],
			});
		});

		it('should handle pagination correctly', async () => {
			const owner = 'test-owner';
			const repository = 'test-repo';
			const refsResponse = Array(100)
				.fill(0)
				.map((_, i) => ({
					ref: i % 2 === 0 ? `refs/heads/branch-${i}` : `refs/tags/tag-${i}`,
				}));

			(mockLoadOptionsFunctions.getCurrentNodeParameter as jest.Mock).mockImplementation(
				(param: string) => {
					if (param === 'owner') return owner;
					if (param === 'repository') return repository;
				},
			);

			(mockLoadOptionsFunctions.helpers.requestWithAuthentication as jest.Mock).mockResolvedValue(
				refsResponse,
			);

			const result = await getRefs.call(mockLoadOptionsFunctions);

			expect(result.paginationToken).toBe(2);
			expect(result.results.length).toBe(100);
		});
	});
});


// === File: __tests__/node/Github.dispatchAndWait.node.test.ts ===
import { NodeTestHarness } from '@nodes-testing/node-test-harness';
import nock from 'nock';

describe('Test Github Node - Dispatch and Wait', () => {
	describe('Workflow Dispatch and Wait', () => {
		const now = 1683028800000;
		const owner = 'Owner';
		const repository = 'test-github-actions';
		const workflowId = 145370278;
		const ref = 'test-branch';

		const usersResponse = {
			total_count: 1,
			items: [
				{
					login: owner,
					id: 1,
				},
			],
		};

		const repositoriesResponse = {
			total_count: 1,
			items: [
				{
					id: 3081286,
					name: repository,
				},
			],
		};

		const workflowsResponse = {
			total_count: 1,
			workflows: [
				{
					id: workflowId,
					node_id: 'MDg6V29ya2Zsb3cxNjEzMzU=',
					name: 'New Test Workflow',
					path: '.github/workflows/test.yaml',
					state: 'active',
					created_at: '2020-01-08T23:48:37.000-08:00',
					updated_at: '2020-01-08T23:50:21.000-08:00',
					url: `https://api.github.com/repos/${owner}/${repository}/actions/workflows/${workflowId}`,
					html_url: `https://github.com/${owner}/${repository}/blob/master/.github/workflows/test.yaml`,
					badge_url: `https://github.com/${owner}/${repository}/workflows/New%20Test%20Workflow/badge.svg`,
				},
			],
		};

		const refsResponse = [{ ref: `refs/heads/${ref}` }];

		beforeAll(async () => {
			jest.useFakeTimers({ doNotFake: ['nextTick'], now });
		});

		beforeEach(async () => {
			const baseUrl = 'https://api.github.com';
			nock.cleanAll();
			nock(baseUrl)
				.persist()
				.defaultReplyHeaders({ 'Content-Type': 'application/json' })
				.get('/search/users')
				.query(true)
				.reply(200, usersResponse)
				.get('/search/repositories')
				.query(true)
				.reply(200, repositoriesResponse)
				.get(`/repos/${owner}/${repository}/actions/workflows`)
				.reply(200, workflowsResponse)
				.get(`/repos/${owner}/${repository}/git/refs`)
				.reply(200, refsResponse)
				.post(
					`/repos/${owner}/${repository}/actions/workflows/${workflowId}/dispatches`,
					(body) => {
						return body.ref === ref && body.inputs?.resumeUrl;
					},
				)
				.reply(200, {});
		});

		afterEach(() => {
			nock.cleanAll();
		});

		new NodeTestHarness().setupTests({
			workflowFiles: ['GithubDispatchAndWaitWorkflow.json'],
		});
	});
});


// === File: __tests__/node/Github.node.test.ts ===
import { NodeTestHarness } from '@nodes-testing/node-test-harness';
import { NodeApiError, NodeOperationError } from 'n8n-workflow';
import nock from 'nock';

import * as utilities from '../../../../utils/utilities';
import { Github } from '../../Github.node';

describe('Test Github Node', () => {
	describe('Workflow Dispatch', () => {
		const now = 1683028800000;
		const owner = 'testOwner';
		const repository = 'testRepository';
		const workflowId = 147025216;
		const usersResponse = {
			total_count: 12,
			items: [
				{
					login: 'testOwner',
					id: 1,
				},
			],
		};
		const repositoriesResponse = {
			total_count: 40,
			items: [
				{
					id: 3081286,
					name: 'testRepository',
				},
			],
		};
		const workflowsResponse = {
			total_count: 2,
			workflows: [
				{
					id: workflowId,
					node_id: 'MDg6V29ya2Zsb3cxNjEzMzU=',
					name: 'CI',
					path: '.github/workflows/blank.yaml',
					state: 'active',
					created_at: '2020-01-08T23:48:37.000-08:00',
					updated_at: '2020-01-08T23:50:21.000-08:00',
					url: 'https://api.github.com/repos/octo-org/octo-repo/actions/workflows/161335',
					html_url: 'https://github.com/octo-org/octo-repo/blob/master/.github/workflows/161335',
					badge_url: 'https://github.com/octo-org/octo-repo/workflows/CI/badge.svg',
				},
				{
					id: 269289,
					node_id: 'MDE4OldvcmtmbG93IFNlY29uZGFyeTI2OTI4OQ==',
					name: 'Linter',
					path: '.github/workflows/linter.yaml',
					state: 'active',
					created_at: '2020-01-08T23:48:37.000-08:00',
					updated_at: '2020-01-08T23:50:21.000-08:00',
					url: 'https://api.github.com/repos/octo-org/octo-repo/actions/workflows/269289',
					html_url: 'https://github.com/octo-org/octo-repo/blob/master/.github/workflows/269289',
					badge_url: 'https://github.com/octo-org/octo-repo/workflows/Linter/badge.svg',
				},
			],
		};

		beforeAll(async () => {
			jest.useFakeTimers({ doNotFake: ['nextTick'], now });
		});

		describe('removeTrailingSlash Function', () => {
			let githubNode: Github;
			let mockExecutionContext: any;

			beforeEach(() => {
				githubNode = new Github();
				mockExecutionContext = {
					getNode: jest.fn().mockReturnValue({ name: 'Github' }),
					getNodeParameter: jest.fn(),
					getInputData: jest.fn().mockReturnValue([{ json: {} }]),
					continueOnFail: jest.fn().mockReturnValue(false),
					getCredentials: jest.fn().mockResolvedValue({
						server: 'https://api.github.com',
						user: 'test',
						accessToken: 'test',
					}),
					helpers: {
						returnJsonArray: jest.fn().mockReturnValue([{ json: {} }]),
						requestWithAuthentication: jest.fn().mockResolvedValue({}),
						constructExecutionMetaData: jest.fn().mockReturnValue([{ json: {} }]),
					},
				};

				jest.spyOn(utilities, 'removeTrailingSlash');
				jest.mock('../../../../utils/utilities', () => ({
					...jest.requireActual('../../../../utils/utilities'),
					getFileSha: jest.fn().mockResolvedValue('mockedSHA'),
				}));
			});

			it('should call remove trailing slash', async () => {
				mockExecutionContext.getNodeParameter.mockImplementation((parameterName: string) => {
					if (parameterName === 'operation') {
						return 'list';
					}
					if (parameterName === 'resource') {
						return 'file';
					}
					if (parameterName === 'filePath') {
						return 'path/to/file/';
					}
					if (parameterName === 'owner') {
						return 'me';
					}
					if (parameterName === 'repository') {
						return 'repo';
					}
					return '';
				});

				await githubNode.execute.call(mockExecutionContext);

				expect(utilities.removeTrailingSlash).toHaveBeenCalledWith('path/to/file/');
				expect(mockExecutionContext.helpers.requestWithAuthentication).toHaveBeenCalledWith(
					'githubOAuth2Api',
					{
						body: {},
						headers: { 'User-Agent': 'n8n' },
						json: true,
						method: 'GET',
						qs: {},
						uri: 'https://api.github.com/repos/me/repo/contents/path%2Fto%2Ffile',
					},
				);
			});
		});

		beforeEach(async () => {
			const baseUrl = 'https://api.github.com';
			nock(baseUrl)
				.persist()
				.defaultReplyHeaders({ 'Content-Type': 'application/json' })
				.get('/search/users')
				.query(true)
				.reply(200, usersResponse)
				.get('/search/repositories')
				.query(true)
				.reply(200, repositoriesResponse)
				.get(`/repos/${owner}/${repository}/actions/workflows`)
				.reply(200, workflowsResponse)
				.post(`/repos/${owner}/${repository}/actions/workflows/${workflowId}/dispatches`, {
					ref: 'main',
					inputs: {},
				})
				.reply(200, {});
		});

		new NodeTestHarness().setupTests({
			workflowFiles: ['GithubTestWorkflow.json'],
		});
	});

	describe('Error Handling', () => {
		let githubNode: Github;
		let mockExecutionContext: any;

		beforeEach(() => {
			githubNode = new Github();
			mockExecutionContext = {
				getNode: jest.fn().mockReturnValue({ name: 'Github' }),
				getNodeParameter: jest.fn(),
				getInputData: jest.fn().mockReturnValue([{ json: {} }]),
				continueOnFail: jest.fn().mockReturnValue(false),
				putExecutionToWait: jest.fn(),
				getCredentials: jest.fn().mockResolvedValue({
					server: 'https://api.github.com',
					user: 'test',
					accessToken: 'test',
				}),
				helpers: {
					returnJsonArray: jest.fn().mockReturnValue([{ json: {} }]),
					httpRequest: jest.fn(),
					httpRequestWithAuthentication: jest.fn(),
					requestWithAuthentication: jest
						.fn()
						.mockImplementation(async (_credentialType, options) => {
							if (options.uri.includes('dispatches') && options.method === 'POST') {
								const error: any = new Error('Not Found');
								error.statusCode = 404;
								error.message = 'Not Found';
								throw error;
							}
							return {};
						}),
					request: jest.fn(),
					constructExecutionMetaData: jest.fn().mockReturnValue([{ json: {} }]),
					assertBinaryData: jest.fn(),
					prepareBinaryData: jest.fn(),
				},
				getWorkflowDataProxy: jest.fn().mockReturnValue({
					$execution: {
						resumeUrl: 'https://example.com/webhook',
					},
				}),
			};
		});

		it('should throw NodeOperationError for invalid JSON inputs', async () => {
			mockExecutionContext.getNodeParameter.mockImplementation((parameterName: string) => {
				if (parameterName === 'inputs') {
					return 'invalid json';
				}
				if (parameterName === 'resource') {
					return 'workflow';
				}
				if (parameterName === 'operation') {
					return 'dispatchAndWait';
				}
				if (parameterName === 'authentication') {
					return 'accessToken';
				}
				return '';
			});

			await expect(async () => {
				await githubNode.execute.call(mockExecutionContext);
			}).rejects.toThrow(NodeOperationError);
		});

		it('should throw NodeOperationError for 404 errors when dispatching a workflow', async () => {
			const owner = 'testOwner';
			const repository = 'testRepository';
			const workflowId = 147025216;

			mockExecutionContext.helpers.requestWithAuthentication.mockRejectedValueOnce({
				statusCode: 404,
				message: 'Not Found',
			});

			mockExecutionContext.getNodeParameter.mockImplementation((parameterName: string) => {
				if (parameterName === 'owner') {
					return owner;
				}
				if (parameterName === 'repository') {
					return repository;
				}
				if (parameterName === 'workflowId') {
					return workflowId;
				}
				if (parameterName === 'inputs') {
					return '{}';
				}
				if (parameterName === 'ref') {
					return 'main';
				}
				if (parameterName === 'resource') {
					return 'workflow';
				}
				if (parameterName === 'operation') {
					return 'dispatchAndWait';
				}
				if (parameterName === 'authentication') {
					return 'accessToken';
				}
				return '';
			});

			await expect(async () => {
				await githubNode.execute.call(mockExecutionContext);
			}).rejects.toThrow(/The workflow to dispatch could not be found/);
		});

		it('should throw NodeApiError for general API errors', async () => {
			const owner = 'testOwner';
			const repository = 'testRepository';
			const workflowId = 147025216;

			mockExecutionContext.helpers.requestWithAuthentication.mockRejectedValueOnce({
				statusCode: 500,
				message: 'Internal Server Error',
			});

			mockExecutionContext.getNodeParameter.mockImplementation((parameterName: string) => {
				if (parameterName === 'owner') {
					return owner;
				}
				if (parameterName === 'repository') {
					return repository;
				}
				if (parameterName === 'workflowId') {
					return workflowId;
				}
				if (parameterName === 'inputs') {
					return '{}';
				}
				if (parameterName === 'ref') {
					return 'main';
				}
				if (parameterName === 'resource') {
					return 'workflow';
				}
				if (parameterName === 'operation') {
					return 'dispatch';
				}
				if (parameterName === 'authentication') {
					return 'accessToken';
				}
				return '';
			});

			await expect(async () => {
				await githubNode.execute.call(mockExecutionContext);
			}).rejects.toThrow();
		});

		it('should throw NodeApiError for general API errors in dispatchAndWait operation', async () => {
			const owner = 'testOwner';
			const repository = 'testRepository';
			const workflowId = 147025216;

			mockExecutionContext.getWorkflowDataProxy = jest.fn().mockReturnValue({
				$execution: {
					resumeUrl: 'https://example.com/webhook',
				},
			});

			mockExecutionContext.helpers.requestWithAuthentication.mockRejectedValueOnce({
				statusCode: 500,
				message: 'Internal Server Error',
			});

			mockExecutionContext.getNodeParameter.mockImplementation((parameterName: string) => {
				if (parameterName === 'owner') {
					return owner;
				}
				if (parameterName === 'repository') {
					return repository;
				}
				if (parameterName === 'workflowId') {
					return workflowId;
				}
				if (parameterName === 'inputs') {
					return '{}';
				}
				if (parameterName === 'ref') {
					return 'main';
				}
				if (parameterName === 'resource') {
					return 'workflow';
				}
				if (parameterName === 'operation') {
					return 'dispatchAndWait';
				}
				if (parameterName === 'authentication') {
					return 'accessToken';
				}
				return '';
			});

			await expect(async () => {
				await githubNode.execute.call(mockExecutionContext);
			}).rejects.toThrow(NodeApiError);

			expect(mockExecutionContext.helpers.requestWithAuthentication).toHaveBeenCalledWith(
				expect.any(String),
				expect.objectContaining({
					method: 'POST',
					uri: expect.stringContaining(
						`/repos/${owner}/${repository}/actions/workflows/${workflowId}/dispatches`,
					),
					body: expect.objectContaining({
						ref: 'main',
						inputs: expect.objectContaining({
							resumeUrl: 'https://example.com/webhook',
						}),
					}),
				}),
			);
		});
	});

	describe('Workflow Operations', () => {
		let githubNode: Github;
		let mockExecutionContext: any;

		beforeEach(() => {
			githubNode = new Github();
			mockExecutionContext = {
				getNode: jest.fn().mockReturnValue({ name: 'Github' }),
				getNodeParameter: jest.fn(),
				getInputData: jest.fn().mockReturnValue([{ json: {} }]),
				continueOnFail: jest.fn().mockReturnValue(false),
				getCredentials: jest.fn().mockResolvedValue({
					server: 'https://api.github.com',
					user: 'test',
					accessToken: 'test',
				}),
				helpers: {
					returnJsonArray: jest.fn().mockReturnValue([{ json: {} }]),
					requestWithAuthentication: jest.fn().mockResolvedValue({}),
					constructExecutionMetaData: jest.fn().mockReturnValue([{ json: {} }]),
				},
			};
		});

		it('should use extractValue for workflowId in disable operation', async () => {
			const owner = 'testOwner';
			const repository = 'testRepository';
			const workflowId = 147025216;

			mockExecutionContext.getNodeParameter.mockImplementation(
				(parameterName: string, _itemIndex: number, defaultValue: string, options?: any) => {
					if (parameterName === 'owner') {
						return owner;
					}
					if (parameterName === 'repository') {
						return repository;
					}
					if (parameterName === 'workflowId') {
						expect(options).toBeDefined();
						expect(options.extractValue).toBe(true);
						return workflowId;
					}
					if (parameterName === 'resource') {
						return 'workflow';
					}
					if (parameterName === 'operation') {
						return 'disable';
					}
					if (parameterName === 'authentication') {
						return 'accessToken';
					}
					return defaultValue;
				},
			);

			await githubNode.execute.call(mockExecutionContext);

			expect(mockExecutionContext.helpers.requestWithAuthentication).toHaveBeenCalledWith(
				expect.any(String),
				expect.objectContaining({
					method: 'PUT',
					uri: `https://api.github.com/repos/${owner}/${repository}/actions/workflows/${workflowId}/disable`,
				}),
			);
		});

		it('should use extractValue for workflowId in enable operation', async () => {
			const owner = 'testOwner';
			const repository = 'testRepository';
			const workflowId = 147025216;

			mockExecutionContext.getNodeParameter.mockImplementation(
				(parameterName: string, _itemIndex: number, defaultValue: string, options?: any) => {
					if (parameterName === 'owner') {
						return owner;
					}
					if (parameterName === 'repository') {
						return repository;
					}
					if (parameterName === 'workflowId') {
						expect(options).toBeDefined();
						expect(options.extractValue).toBe(true);
						return workflowId;
					}
					if (parameterName === 'resource') {
						return 'workflow';
					}
					if (parameterName === 'operation') {
						return 'enable';
					}
					if (parameterName === 'authentication') {
						return 'accessToken';
					}
					return defaultValue;
				},
			);

			await githubNode.execute.call(mockExecutionContext);

			expect(mockExecutionContext.helpers.requestWithAuthentication).toHaveBeenCalledWith(
				expect.any(String),
				expect.objectContaining({
					method: 'PUT',
					uri: `https://api.github.com/repos/${owner}/${repository}/actions/workflows/${workflowId}/enable`,
				}),
			);
		});

		it('should use extractValue for workflowId in get operation', async () => {
			const owner = 'testOwner';
			const repository = 'testRepository';
			const workflowId = 147025216;

			mockExecutionContext.getNodeParameter.mockImplementation(
				(parameterName: string, _itemIndex: number, defaultValue: string, options?: any) => {
					if (parameterName === 'owner') {
						return owner;
					}
					if (parameterName === 'repository') {
						return repository;
					}
					if (parameterName === 'workflowId') {
						expect(options).toBeDefined();
						expect(options.extractValue).toBe(true);
						return workflowId;
					}
					if (parameterName === 'resource') {
						return 'workflow';
					}
					if (parameterName === 'operation') {
						return 'get';
					}
					if (parameterName === 'authentication') {
						return 'accessToken';
					}
					return defaultValue;
				},
			);

			await githubNode.execute.call(mockExecutionContext);

			expect(mockExecutionContext.helpers.requestWithAuthentication).toHaveBeenCalledWith(
				expect.any(String),
				expect.objectContaining({
					method: 'GET',
					uri: `https://api.github.com/repos/${owner}/${repository}/actions/workflows/${workflowId}`,
				}),
			);
		});

		it('should use extractValue for workflowId in getUsage operation', async () => {
			const owner = 'testOwner';
			const repository = 'testRepository';
			const workflowId = 147025216;

			mockExecutionContext.getNodeParameter.mockImplementation(
				(parameterName: string, _itemIndex: number, defaultValue: string, options?: any) => {
					if (parameterName === 'owner') {
						return owner;
					}
					if (parameterName === 'repository') {
						return repository;
					}
					if (parameterName === 'workflowId') {
						expect(options).toBeDefined();
						expect(options.extractValue).toBe(true);
						return workflowId;
					}
					if (parameterName === 'resource') {
						return 'workflow';
					}
					if (parameterName === 'operation') {
						return 'getUsage';
					}
					if (parameterName === 'authentication') {
						return 'accessToken';
					}
					return defaultValue;
				},
			);

			await githubNode.execute.call(mockExecutionContext);

			expect(mockExecutionContext.helpers.requestWithAuthentication).toHaveBeenCalledWith(
				expect.any(String),
				expect.objectContaining({
					method: 'GET',
					uri: `https://api.github.com/repos/${owner}/${repository}/actions/workflows/${workflowId}/timing`,
				}),
			);
		});
	});

	describe('Parameter Extraction', () => {
		it('should use extractValue for workflowId parameter', () => {
			const githubNode = new Github();
			const description = githubNode.description;

			const workflowIdParam = description.properties.find((prop) => prop.name === 'workflowId');

			expect(workflowIdParam).toBeDefined();
			expect(workflowIdParam?.type).toBe('resourceLocator');

			const workflowOperations = description.properties.find(
				(prop) =>
					prop.name === 'operation' && prop.displayOptions?.show?.resource?.includes('workflow'),
			);

			expect(workflowOperations).toBeDefined();
			expect(workflowOperations?.options).toEqual(
				expect.arrayContaining([
					expect.objectContaining({ value: 'disable' }),
					expect.objectContaining({ value: 'dispatch' }),
					expect.objectContaining({ value: 'enable' }),
					expect.objectContaining({ value: 'get' }),
					expect.objectContaining({ value: 'getUsage' }),
				]),
			);
		});
	});
});


// === File: __tests__/node/Github.webhook.test.ts ===
import type { IWebhookFunctions } from 'n8n-workflow';

import { Github } from '../../Github.node';

describe('Github Node - Webhook Method', () => {
	let githubNode: Github;
	let mockWebhookFunctions: IWebhookFunctions;

	beforeEach(() => {
		githubNode = new Github();

		mockWebhookFunctions = {
			getRequestObject: jest.fn(),
			getResponseObject: jest.fn(),
			getNodeParameter: jest.fn(),
			getNode: jest.fn(),
			helpers: {
				returnJsonArray: jest.fn(),
			},
		} as unknown as IWebhookFunctions;
	});

	it('should process webhook request and return workflowData', async () => {
		const sampleWebhookBody = {
			action: 'opened',
			issue: {
				number: 123,
				title: 'Test Issue',
				body: 'This is a test issue',
				user: {
					login: 'testuser',
				},
			},
			repository: {
				name: 'test-repo',
				owner: {
					login: 'test-owner',
				},
			},
		};

		const mockRequestObject = {
			body: sampleWebhookBody,
			headers: {
				'x-github-event': 'issues',
				'x-github-delivery': '72d3162e-cc78-11e3-81ab-4c9367dc0958',
			},
		};

		(mockWebhookFunctions.getRequestObject as jest.Mock).mockReturnValue(mockRequestObject);
		(mockWebhookFunctions.helpers.returnJsonArray as jest.Mock).mockReturnValue([
			sampleWebhookBody,
		]);

		const result = await githubNode.webhook.call(mockWebhookFunctions);

		expect(result).toEqual({
			workflowData: [[sampleWebhookBody]],
		});

		expect(mockWebhookFunctions.getRequestObject).toHaveBeenCalled();
		expect(mockWebhookFunctions.helpers.returnJsonArray).toHaveBeenCalledWith(sampleWebhookBody);
	});
});


// === File: __tests__/node/GithubTrigger.node.test.ts ===
import { GithubTrigger } from '../../GithubTrigger.node';
import * as GenericFunctions from '../../GenericFunctions';
import { NodeOperationError } from 'n8n-workflow';

describe('GithubTrigger Node', () => {
	describe('checkExists webhook method', () => {
		let webhookData: Record<string, any>;
		let mockThis: any;

		beforeEach(() => {
			webhookData = {
				webhookId: '123456',
				webhookEvents: ['push'],
			};

			mockThis = {
				getWorkflowStaticData: () => webhookData,
				getNodeParameter: jest.fn().mockImplementation((name: string) => {
					if (name === 'owner') return 'some-owner';
					if (name === 'repository') return 'some-repo';
				}),
			};
		});

		it('should delete webhook data and return false when webhook is not found (404)', async () => {
			jest.spyOn(GenericFunctions, 'githubApiRequest').mockRejectedValue({ httpCode: '404' });

			const trigger = new GithubTrigger();
			const result = await trigger.webhookMethods.default.checkExists.call(mockThis);

			expect(result).toBe(false);
			expect(webhookData.webhookId).toBeUndefined();
			expect(webhookData.webhookEvents).toBeUndefined();
		});
	});

	describe('create webhook method', () => {
		let mockThis: any;
		let webhookData: Record<string, any>;

		beforeEach(() => {
			webhookData = {};
			mockThis = {
				getNodeWebhookUrl: () => 'https://example.com/webhook',
				getNodeParameter: jest.fn().mockImplementation((name: string) => {
					if (name === 'owner') return 'some-owner';
					if (name === 'repository') return 'some-repo';
					if (name === 'events') return ['push'];
					if (name === 'options') return { insecureSSL: false };
				}),
				getWorkflowStaticData: () => webhookData,
				getNode: () => ({}),
			};
		});

		it('should return true and set webhookId when creation succeeds', async () => {
			const createdWebhook = { id: '789', active: true };

			jest.spyOn(GenericFunctions, 'githubApiRequest').mockResolvedValueOnce(createdWebhook); // Simulate successful POST

			const trigger = new GithubTrigger();
			const result = await trigger.webhookMethods.default.create.call(mockThis);

			expect(result).toBe(true);
			expect(webhookData.webhookId).toBe('789');
		});

		it('should handle 422 by checking for existing matching webhook', async () => {
			const existingWebhook = {
				id: '123',
				events: ['push'],
				config: { url: 'https://example.com/webhook' },
			};

			jest
				.spyOn(GenericFunctions, 'githubApiRequest')
				.mockRejectedValueOnce({ httpCode: '422' }) // POST fails
				.mockResolvedValueOnce([existingWebhook]); // GET returns matching

			const trigger = new GithubTrigger();
			const result = await trigger.webhookMethods.default.create.call(mockThis);

			expect(result).toBe(true);
			expect(webhookData.webhookId).toBe('123');
		});

		it('should throw NodeOperationError if repo is not found (404)', async () => {
			jest.spyOn(GenericFunctions, 'githubApiRequest').mockRejectedValue({ httpCode: '404' });

			const trigger = new GithubTrigger();

			await expect(trigger.webhookMethods.default.create.call(mockThis)).rejects.toThrow(
				NodeOperationError,
			);

			await expect(trigger.webhookMethods.default.create.call(mockThis)).rejects.toThrow(
				/Check that the repository exists/,
			);
		});
	});
});


// === File: __tests__/oauth2-credentials-expression/setup.test.ts ===
import { NodeTestHarness } from '@nodes-testing/node-test-harness';

describe('Test Github Oauth2 Credentials Expression', () => {
	new NodeTestHarness().setupTests();
});
