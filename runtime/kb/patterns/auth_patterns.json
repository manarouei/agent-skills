[
  {
    "id": "auth-001",
    "version": "1.0.0",
    "name": "BaseCredential Structure",
    "category": "auth",
    "description": "Base credential class with properties array pattern - all credentials extend this",
    "pattern": {
      "type": "auth",
      "auth_type": "custom",
      "credential_fields": ["name", "display_name", "properties"],
      "implementation_notes": "All credentials inherit from BaseCredential. Properties is a list of CredentialProperty with name, display_name, type (string|number|boolean|options), required, default, and description. Implement test() for connection testing and validate() for required field checks."
    },
    "examples": [
      {
        "input": "class PostgresApiCredential(BaseCredential):",
        "output": "name = 'postgresApi'\ndisplay_name = 'Postgres'\nproperties = [\n    CredentialProperty(name='host', display_name='Host', type='string', required=True, default='localhost'),\n    CredentialProperty(name='port', display_name='Port', type='number', required=True, default=5432),\n    CredentialProperty(name='database', display_name='Database', type='string', required=True),\n]",
        "notes": "Each property defines UI field with validation"
      }
    ],
    "applicability": {
      "services": [],
      "node_types": ["credential"]
    },
    "created_at": "2025-01-15T00:00:00Z"
  },
  {
    "id": "auth-002",
    "version": "1.0.0",
    "name": "OAuth2 Stateless Token Refresh",
    "category": "auth",
    "description": "OAuth2 credential with stateless token refresh - returns new token data without mutating instance",
    "pattern": {
      "type": "auth",
      "auth_type": "oauth2",
      "credential_fields": ["client_id", "client_secret", "access_token", "refresh_token", "token_type", "expires_at"],
      "implementation_notes": "TOKEN_EXPIRY_BUFFER = 60 seconds. refresh_token() is stateless - returns dict with new tokens. has_access_token() checks expiry. get_authorization_url() builds OAuth redirect with optional PKCE. exchange_code_for_token() handles authorization_code grant. Expression resolution: {{$self['field']}} pattern for self-referencing fields."
    },
    "examples": [
      {
        "input": "def refresh_token(self, credentials_data: dict) -> dict:",
        "output": "response = self._http.post(\n    self.token_url,\n    data={\n        'grant_type': 'refresh_token',\n        'refresh_token': credentials_data['refresh_token'],\n        'client_id': credentials_data['client_id'],\n        'client_secret': credentials_data['client_secret'],\n    },\n    timeout=30,\n)\nresponse.raise_for_status()\ntoken_data = response.json()\nreturn {\n    'access_token': token_data['access_token'],\n    'refresh_token': token_data.get('refresh_token', credentials_data['refresh_token']),\n    'expires_at': datetime.now(timezone.utc) + timedelta(seconds=token_data.get('expires_in', 3600)),\n}",
        "notes": "Stateless - returns new data, caller persists"
      },
      {
        "input": "def get_authorization_url(self, state: str, redirect_uri: str, pkce_code_challenge: str | None = None) -> str:",
        "output": "params = {\n    'client_id': self.client_id,\n    'redirect_uri': redirect_uri,\n    'response_type': 'code',\n    'state': state,\n    'scope': ' '.join(self.scopes),\n}\nif pkce_code_challenge:\n    params['code_challenge'] = pkce_code_challenge\n    params['code_challenge_method'] = 'S256'\nreturn f'{self.authorization_url}?{urlencode(params)}'",
        "notes": "PKCE support is optional"
      }
    ],
    "applicability": {
      "services": ["google", "microsoft", "salesforce", "slack", "github"],
      "node_types": ["credential"]
    },
    "created_at": "2025-01-15T00:00:00Z"
  },
  {
    "id": "auth-003",
    "version": "1.0.0",
    "name": "Service-Specific OAuth2 Extension",
    "category": "auth",
    "description": "Pattern for extending OAuth2ApiCredential with service-specific scopes and token handling",
    "pattern": {
      "type": "auth",
      "auth_type": "oauth2",
      "credential_fields": ["user_scopes", "bot_scopes", "team_id"],
      "implementation_notes": "Define USER_SCOPES and BOT_SCOPES as class constants. Override _build_properties() to add/modify parent properties. Override exchange_code_for_token() if service returns non-standard response (e.g., Slack returns 'authed_user' and 'team' objects). Always call super() methods where appropriate."
    },
    "examples": [
      {
        "input": "class SlackOAuth2ApiCredential(OAuth2ApiCredential):",
        "output": "USER_SCOPES = ['channels:history', 'channels:read', 'chat:write', 'files:read', 'users:read']\nBOT_SCOPES = ['channels:history', 'channels:read', 'chat:write', 'files:read', 'users:read', 'reactions:read']\n\ndef _build_properties(self) -> list[CredentialProperty]:\n    props = super()._build_properties()\n    props.append(CredentialProperty(\n        name='team_id',\n        display_name='Team ID',\n        type='string',\n        required=False,\n    ))\n    return props",
        "notes": "Slack has separate user and bot token scopes"
      },
      {
        "input": "def exchange_code_for_token(self, code: str, redirect_uri: str) -> dict:",
        "output": "# Slack returns non-standard OAuth response\ntoken_data = super().exchange_code_for_token(code, redirect_uri)\nif 'authed_user' in token_data:\n    return {\n        'access_token': token_data['authed_user']['access_token'],\n        'refresh_token': token_data['authed_user'].get('refresh_token'),\n        'team_id': token_data.get('team', {}).get('id'),\n    }\nreturn token_data",
        "notes": "Handle service-specific response formats"
      }
    ],
    "applicability": {
      "services": ["slack", "discord", "teams"],
      "node_types": ["credential"]
    },
    "created_at": "2025-01-15T00:00:00Z"
  },
  {
    "id": "auth-004",
    "version": "1.0.0",
    "name": "API Key Credential",
    "category": "auth",
    "description": "Simple API key credential pattern with header or query parameter authentication",
    "pattern": {
      "type": "auth",
      "auth_type": "api_key",
      "credential_fields": ["api_key"],
      "implementation_notes": "Single api_key property. test() method makes lightweight API call to verify. Common header formats: 'Authorization: Bearer {key}', 'X-API-Key: {key}', 'Api-Key: {key}'. Some APIs use query param: ?api_key={key}"
    },
    "examples": [
      {
        "input": "class OpenAIApiCredential(BaseCredential):",
        "output": "name = 'openaiApi'\ndisplay_name = 'OpenAI'\nproperties = [\n    CredentialProperty(name='api_key', display_name='API Key', type='string', required=True),\n]\n\nasync def test(self, credentials_data: dict) -> bool:\n    response = self._http.get(\n        'https://api.openai.com/v1/models',\n        headers={'Authorization': f\"Bearer {credentials_data['api_key']}\"},\n        timeout=10,\n    )\n    return response.status_code == 200",
        "notes": "test() validates API key works"
      }
    ],
    "applicability": {
      "services": ["openai", "stripe", "sendgrid", "twilio"],
      "node_types": ["credential"]
    },
    "created_at": "2025-01-15T00:00:00Z"
  },
  {
    "id": "auth-005",
    "version": "1.0.0",
    "name": "Database Connection Credential",
    "category": "auth",
    "description": "Pattern for database connection credentials with connection string building",
    "pattern": {
      "type": "auth",
      "auth_type": "custom",
      "credential_fields": ["host", "port", "database", "user", "password", "ssl", "connectionTimeout"],
      "implementation_notes": "Properties include host, port (number), database, user, password, ssl (boolean), connectionTimeout (number, optional). Implement _build_connection_string() for driver-specific format. test() should attempt actual connection. validate() checks required fields."
    },
    "examples": [
      {
        "input": "def _build_connection_string(self, credentials_data: dict) -> str:",
        "output": "host = credentials_data['host']\nport = credentials_data.get('port', 5432)\ndatabase = credentials_data['database']\nuser = credentials_data['user']\npassword = credentials_data['password']\nssl_mode = 'require' if credentials_data.get('ssl', False) else 'disable'\nreturn f'postgresql://{user}:{password}@{host}:{port}/{database}?sslmode={ssl_mode}'",
        "notes": "Connection string format varies by database driver"
      },
      {
        "input": "async def test(self, credentials_data: dict) -> bool:",
        "output": "import psycopg2\nconn_str = self._build_connection_string(credentials_data)\ntry:\n    conn = psycopg2.connect(conn_str, connect_timeout=5)\n    conn.close()\n    return True\nexcept Exception:\n    return False",
        "notes": "test() attempts real connection"
      }
    ],
    "applicability": {
      "services": ["postgres", "mysql", "mongodb", "redis"],
      "node_types": ["credential"]
    },
    "created_at": "2025-01-15T00:00:00Z"
  }
]
